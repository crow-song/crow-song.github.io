<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[jdbcToMyBatis]]></title>
    <url>%2F2018%2F07%2F25%2FjdbcToMyBatis%2F</url>
    <content type="text"><![CDATA[css 设置不显示问题： 将 resources 放入了 WEB-INF 文件夹中（这文件夹中的内容只能根据内部跳转或重定向等网页操作才能访问，不能直接访问） request.getContextPath() 获取的是上下文路径。是你的web项目的根路径，就是 webContent (MyEclipse中是webRoot) 或者 idea 中的 web 路径 拼装当前网页相对路径 url-pattern 配置 此文为 jdbc 版，如已了解直接转至 mybatis版 第一版大体框架 123456789101112131415161718192021222324package com.imooc.servlet;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;/** * 列表页面初始化控制 */@WebServlet(name="ListServlet" ,urlPatterns = "/List.action")public class ListServlet extends HttpServlet&#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; req.getRequestDispatcher("/WEB-INF/jsp/back/list.jsp").forward(req,resp); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; this.doGet(req, resp); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;&lt;%--拼接当前网页相对路径--%&gt;&lt;% String path = request.getContextPath(); String basePath = request.getScheme()+"://"+request.getServerName()+":"+request.getServerPort()+path;%&gt;&lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /&gt;&lt;meta http-equiv="X-UA-Compatible"content="IE=9; IE=8; IE=7; IE=EDGE" /&gt;&lt;title&gt;内容列表页面&lt;/title&gt;&lt;%--css 文件的相对路径--%&gt;&lt;link href="resources/css/all.css" rel="stylesheet" type="text/css" /&gt;&lt;/head&gt;&lt;body style="background: #e1e9eb;"&gt; &lt;form action="" id="mainForm" method="post"&gt; &lt;div class="right"&gt; &lt;div class="current"&gt;当前位置：&lt;br/&gt; &lt;a href="javascript:void(0)" style="color:#6E6E6E;"&gt; 内容管理 &lt;/a&gt; &amp;gt; 内容列表 &lt;/div&gt; &lt;div class="rightCont"&gt; &lt;p class="g_title fix"&gt;内容列表 &lt;a class="btn03" href="#"&gt;新 增&lt;/a&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;a class="btn03" href="#"&gt;删 除&lt;/a&gt; &lt;/p&gt; &lt;table class="tab1"&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td width="90" align="right"&gt;演示字段1：&lt;/td&gt; &lt;td&gt; &lt;input type="text" class="allInput" value=""/&gt; &lt;/td&gt; &lt;td width="90" align="right"&gt;演示字段2：&lt;/td&gt; &lt;td&gt; &lt;input type="text" class="allInput" value=""/&gt; &lt;/td&gt; &lt;td width="85" align="right"&gt; &lt;input type="submit" class="tabSub" value="查 询" /&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;div class="zixun fix"&gt; &lt;table class="tab2" width="100%"&gt; &lt;tbody&gt; &lt;tr&gt; &lt;th&gt;&lt;input type="checkbox" id="all" onclick="#"/&gt;&lt;/th&gt; &lt;th&gt;序号&lt;/th&gt; &lt;th&gt;演示字段1&lt;/th&gt; &lt;th&gt;演示字段2&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;input type="checkbox" /&gt;&lt;/td&gt; &lt;td&gt;1&lt;/td&gt; &lt;td&gt;演示值1&lt;/td&gt; &lt;td&gt;演示值2&lt;/td&gt; &lt;td&gt; &lt;a href="#"&gt;修改&lt;/a&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;a href="#"&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr style="background-color:#ECF6EE;"&gt; &lt;td&gt;&lt;input type="checkbox" /&gt;&lt;/td&gt; &lt;td&gt;2&lt;/td&gt; &lt;td&gt;演示值1&lt;/td&gt; &lt;td&gt;演示值2&lt;/td&gt; &lt;td&gt; &lt;a href="#"&gt;修改&lt;/a&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;a href="#"&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;input type="checkbox" /&gt;&lt;/td&gt; &lt;td&gt;3&lt;/td&gt; &lt;td&gt;演示值1&lt;/td&gt; &lt;td&gt;演示值2&lt;/td&gt; &lt;td&gt; &lt;a href="#"&gt;修改&lt;/a&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;a href="#"&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr style="background-color:#ECF6EE;"&gt; &lt;td&gt;&lt;input type="checkbox" /&gt;&lt;/td&gt; &lt;td&gt;4&lt;/td&gt; &lt;td&gt;演示值1&lt;/td&gt; &lt;td&gt;演示值2&lt;/td&gt; &lt;td&gt; &lt;a href="#"&gt;修改&lt;/a&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;a href="#"&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;div class='page fix'&gt; 共 &lt;b&gt;4&lt;/b&gt; 条 &lt;a href='###' class='first'&gt;首页&lt;/a&gt; &lt;a href='###' class='pre'&gt;上一页&lt;/a&gt; 当前第&lt;span&gt;1/1&lt;/span&gt;页 &lt;a href='###' class='next'&gt;下一页&lt;/a&gt; &lt;a href='###' class='last'&gt;末页&lt;/a&gt; 跳至&amp;nbsp;&lt;input type='text' value='1' class='allInput w28' /&gt;&amp;nbsp;页&amp;nbsp; &lt;a href='###' class='go'&gt;GO&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011121314151617181920212223&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd" version="3.1"&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt;/*此处可用 servlet 中的注释代替*/ &lt;!--&lt;servlet&gt;--&gt; &lt;!--&lt;servlet-name&gt;ListServlet&lt;/servlet-name&gt;--&gt; &lt;!--&lt;servlet-class&gt;com.imooc.servlet.ListServlet&lt;/servlet-class&gt;--&gt; &lt;!--&lt;/servlet&gt;--&gt; &lt;!--&lt;servlet-mapping&gt;--&gt; &lt;!--&lt;servlet-name&gt;ListServlet&lt;/servlet-name&gt;--&gt; &lt;!--访问 http://localhost:8080/List.action 后跳转到 list.jsp 页面--&gt; &lt;!--&lt;url-pattern&gt;/List.action&lt;/url-pattern&gt;--&gt; &lt;!--&lt;/servlet-mapping&gt;--&gt;&lt;/web-app&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package com.imooc.bean;public class Message &#123; /** * 主键 */ private String id; /** * 指令名称 */ private String command; /** * 描述 */ private String description; /** * 内容 */ private String content; public String getId() &#123; return id; &#125; public void setId(String id) &#123; this.id = id; &#125; public String getCommand() &#123; return command; &#125; public void setCommand(String command) &#123; this.command = command; &#125; public String getDescription() &#123; return description; &#125; public void setDescription(String description) &#123; this.description = description; &#125; public String getContent() &#123; return content; &#125; public void setContent(String content) &#123; this.content = content; &#125;&#125; 第一版完善 完善 list.jsp 及 ListSerlvet.java 的相关部分 sql 语句 1234567891011//sql preparedstatement 语句// ? 占位符// 用缺省值的方式，使用 List 在后面遍历填充字段信息比较方便stringsql = "select * from people p where p.id = ? and p.name = ?";preparedstatement ps = connection.preparestatement(sql);//设置缺省值的值//index 的值从 1 开始ps.setint(1,id);ps.setstring(2,name);//执行 sql 语句resultset rs = ps.executequery(); list.jsp 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;&lt;%--使用 jstl--%&gt;&lt;%@taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %&gt;&lt;%--拼接当前网页相对路径--%&gt;&lt;% String path = request.getContextPath(); String basePath = request.getScheme()+"://"+request.getServerName()+":"+request.getServerPort()+path;%&gt;&lt;html xmlns="http://www.w3.org/1999/xhtml"&gt; &lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /&gt; &lt;meta http-equiv="X-UA-Compatible"content="IE=9; IE=8; IE=7; IE=EDGE" /&gt; &lt;title&gt;内容列表页面&lt;/title&gt; &lt;%--css 文件的相对路径--%&gt; &lt;link href="&lt;%=basePath%&gt;/resources/css/all.css" rel="stylesheet" type="text/css" /&gt; &lt;/head&gt; &lt;body style="background: #e1e9eb;"&gt; &lt;%--提交到 ListServlet 上进行初始化与查询--%&gt; &lt;form action="&lt;%=basePath%&gt;/List.action" id="mainForm" method="post"&gt; &lt;div class="right"&gt; &lt;div class="current"&gt;当前位置：&lt;a href="javascript:void(0)" style="color:#6E6E6E;"&gt;内容管理&lt;/a&gt; &amp;gt; 内容列表&lt;/div&gt; &lt;div class="rightCont"&gt; &lt;p class="g_title fix"&gt;内容列表 &lt;a class="btn03" href="#"&gt;新 增&lt;/a&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;a class="btn03" href="#"&gt;删 除&lt;/a&gt;&lt;/p&gt; &lt;table class="tab1"&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td width="90" align="right"&gt;指令名称：&lt;/td&gt; &lt;td&gt; &lt;input name="command" type="text" class="allInput" value="$&#123;command&#125;"/&gt; &lt;/td&gt; &lt;td width="90" align="right"&gt;描述：&lt;/td&gt; &lt;td&gt; &lt;input name="description" type="text" class="allInput" value="$&#123;description&#125;"/&gt; &lt;/td&gt; &lt;td width="85" align="right"&gt;&lt;input type="submit" class="tabSub" value="查 询" /&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;div class="zixun fix"&gt; &lt;table class="tab2" width="100%"&gt; &lt;tbody&gt; &lt;tr&gt; &lt;th&gt;&lt;input type="checkbox" id="all" onclick="#"/&gt;&lt;/th&gt; &lt;th&gt;序号&lt;/th&gt; &lt;th&gt;演示字段1&lt;/th&gt; &lt;th&gt;演示字段2&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;c:forEach items="$&#123;messageList&#125;" var="message" varStatus="status"&gt; &lt;tr &lt;c:if test="$&#123;status.index % 2 != 0&#125;"&gt;style='background-color:#ECF6EE;'&lt;/c:if&gt;&gt; &lt;td&gt;&lt;input type="checkbox" /&gt;&lt;/td&gt; &lt;td&gt;$&#123;status.index + 1&#125;&lt;/td&gt; &lt;td&gt;$&#123;message.command&#125;&lt;/td&gt; &lt;td&gt;$&#123;message.description&#125;&lt;/td&gt; &lt;td&gt; &lt;a href="#"&gt;修改&lt;/a&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;a href="#"&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;div class='page fix'&gt; 共 &lt;b&gt;4&lt;/b&gt; 条 &lt;a href='###' class='first'&gt;首页&lt;/a&gt; &lt;a href='###' class='pre'&gt;上一页&lt;/a&gt; 当前第&lt;span&gt;1/1&lt;/span&gt;页 &lt;a href='###' class='next'&gt;下一页&lt;/a&gt; &lt;a href='###' class='last'&gt;末页&lt;/a&gt; 跳至&amp;nbsp;&lt;input type='text' value='1' class='allInput w28' /&gt;&amp;nbsp;页&amp;nbsp; &lt;a href='###' class='go'&gt;GO&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; ListServlet 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081package com.imooc.servlet;import com.imooc.bean.Message;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.sql.*;import java.util.ArrayList;import java.util.List;/** * 列表页面初始化控制 */@WebServlet(name="ListServlet" ,urlPatterns = "/List.action")public class ListServlet extends HttpServlet&#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; try &#123; //得到表单文本框提交的数据 req.setCharacterEncoding("utf-8"); String command = req.getParameter("command"); String description = req.getParameter("description"); //将查询完的值保留在查询栏中 req.setAttribute("command",command); req.setAttribute("description",description); Class.forName("com.mysql.jdbc.Driver"); Connection conn = DriverManager.getConnection("jdbc:mysql://127.0.0.1:3306/micro_message", "root","dfwhj43815"); StringBuilder sql = new StringBuilder("select ID,COMMAND,DESCRIPTION,CONTENT from MESSAGE where 1=1"); //创建一个 List 将需要拼接的 sql 语句查询内容装进去，最后用 for 循环取出，set 到 PreparedStatement 后执行 List&lt;String&gt; paramList = new ArrayList&lt;String&gt;(); //.trim() 方法返回一个 String 的副本，用来去除首尾的空格 if(command != null &amp;&amp; !"".equals(command.trim()))&#123; //查询sql语句拼接不用sql.append(" and command = '"+command+"'") 因为容易被SQL注入攻击 sql.append(" and COMMAND=?"); paramList.add(command); &#125; if(description != null &amp;&amp; !"".equals(description.trim()))&#123; sql.append(" and DESCRIPTION like '%' ? '%'"); paramList.add(description); &#125; PreparedStatement ps = conn.prepareStatement(sql.toString()); //在 sql 语句执行前，将参数加进去 for (int i = 0; i &lt; paramList.size(); i++) &#123; ps.setString(i + 1,paramList.get(i)); &#125; ResultSet rs = ps.executeQuery(); List&lt;Message&gt;messageList = new ArrayList&lt;Message&gt;(); while(rs.next())&#123; Message message = new Message(); //添加到容器中的不是对象本身，此时操作对象仍可以改变在容器中的内容。 //也可以将对象在最后添加到容器 message.setId(rs.getString("ID")); message.setCommand(rs.getString("COMMAND")); message.setDescription(rs.getString("DESCRIPTION")); message.setContent(rs.getString("CONTENT")); messageList.add(message); &#125; //将容器添加到 request 的 attribute 可以在页面上显示出来 req.setAttribute("messageList",messageList); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; req.getRequestDispatcher("/WEB-INF/jsp/back/list.jsp").forward(req,resp); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; this.doGet(req, resp); &#125;&#125; idea 引入 c 标签 网页有框架没有数据，提示找不到 jdbc，没有正确导入 Driver 包； You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ‘message’ at line 1 ​ at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method) at sun.reflect.NativeConstructorAccessorImpl.newInstance(Unknown Source) at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(Unknown Source) at java.lang.reflect.Constructor.newInstance(Unknown Source) Sql 语句有语法错误：from 写成了 form 第一版代码重构 将原来 servlet 的功能分出去 servlet 的功能 设置编码 接受页面的值 向页面传值 dao 层的功能 根据查询条件查询消息列表，跟表 Message 相关的所有操作都在这层 service 层的功能 调用 MessageDao 进行数据操作，再由 ListServlet 调用。将值返回给 ListServlet ListSerlvet 123456789101112131415161718192021222324252627282930313233343536373839404142package com.imooc.servlet;import com.imooc.bean.Message;import com.imooc.service.ListService;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.sql.*;import java.util.ArrayList;import java.util.List;/** * 列表页面初始化控制 */@WebServlet(name="ListServlet" ,urlPatterns = "/List.action")public class ListServlet extends HttpServlet&#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //设置编码 req.setCharacterEncoding("utf-8"); //接受页面的值 String command = req.getParameter("command"); String description = req.getParameter("description"); //向页面传值 req.setAttribute("command",command); req.setAttribute("description",description); //查询消息列表并传给页面。调用 ListService 的函数，将查询的结果放到 req 中 ListService listService = new ListService(); req.setAttribute("messageList",listService.queryMessageList(command,description)); //向页面跳转 req.getRequestDispatcher("/WEB-INF/jsp/back/list.jsp").forward(req,resp); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; this.doGet(req, resp); &#125;&#125; MessageDao 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package com.imooc.dao;import com.imooc.bean.Message;import java.sql.*;import java.util.ArrayList;import java.util.List;//Dao 层跟表相关，此 dao 包含跟 message 表相关的操作public class MessageDao &#123; /** * 根据查询条件查询消息列表 */ public List&lt;Message&gt; queryMessageList(String command,String description)&#123; List&lt;Message&gt;messageList = new ArrayList&lt;Message&gt;(); try &#123; Class.forName("com.mysql.jdbc.Driver"); Connection conn = DriverManager.getConnection("jdbc:mysql://127.0.0.1:3306/micro_message", "root","dfwhj43815"); StringBuilder sql = new StringBuilder("select ID,COMMAND,DESCRIPTION,CONTENT from MESSAGE where 1=1"); //创建一个 List 将需要拼接的 sql 语句查询内容装进去，最后用 for 循环取出，set 到 PreparedStatement 后执行 List&lt;String&gt; paramList = new ArrayList&lt;String&gt;(); //.trim() 方法返回一个 String 的副本，用来去除首尾的空格 if(command != null &amp;&amp; !"".equals(command.trim()))&#123; //查询sql语句拼接不用sql.append(" and command = '"+command+"'") 因为容易被SQL注入攻击 sql.append(" and COMMAND=?"); paramList.add(command); &#125; if(description != null &amp;&amp; !"".equals(description.trim()))&#123; sql.append(" and DESCRIPTION like '%' ? '%'"); paramList.add(description); &#125; PreparedStatement ps = conn.prepareStatement(sql.toString()); //在 sql 语句执行前，将参数加进去 for (int i = 0; i &lt; paramList.size(); i++) &#123; ps.setString(i + 1,paramList.get(i)); &#125; ResultSet rs = ps.executeQuery(); while(rs.next())&#123; Message message = new Message(); //添加到容器中的不是对象本身，此时操作对象仍可以改变在容器中的内容。 //也可以将对象在最后添加到容器 message.setId(rs.getString("ID")); message.setCommand(rs.getString("COMMAND")); message.setDescription(rs.getString("DESCRIPTION")); message.setContent(rs.getString("CONTENT")); messageList.add(message); &#125; &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return messageList; &#125;&#125; ListService 1234567891011121314package com.imooc.service;import com.imooc.bean.Message;import com.imooc.dao.MessageDao;import java.util.List;public class ListService &#123; //调用 MessageDao 进行数据操作，再由 ListServlet 调用。将值返回给 ListServlet public List&lt;Message&gt; queryMessageList(String command, String description)&#123; MessageDao messageDao = new MessageDao(); return messageDao.queryMessageList(command,description); &#125;&#125;]]></content>
      <tags>
        <tag>jdbc,myBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis]]></title>
    <url>%2F2018%2F07%2F23%2FMyBatis%2F</url>
    <content type="text"><![CDATA[用 mybatis 替代 jdbc mybatis 下载地址 jdbc 版跳转此处 dao 层需求 ： 能与数据库交互 能执行 sql 语句 mybatis ：向 dao 层提供对象 SqlSession SqlSession 作用： 向 sql 语句传入参数 执行 sql 语句 获取执行 sql 语句的结果 事务的控制 如何得到 SqlSession： 通过配置文件获取数据库连接的相关信息 通过配置信息构建 SqlSessionFactory 通过 SqlSessionFactory 打开 数据库会话（SqlSession） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package com.imooc.bean;public class Message &#123; /** * 主键 */ private String id; /** * 指令名称 */ private String command; /** * 描述 */ private String description; /** * 内容 */ private String content; public String getId() &#123; return id; &#125; public void setId(String id) &#123; this.id = id; &#125; public String getCommand() &#123; return command; &#125; public void setCommand(String command) &#123; this.command = command; &#125; public String getDescription() &#123; return description; &#125; public void setDescription(String description) &#123; this.description = description; &#125; public String getContent() &#123; return content; &#125; public void setContent(String content) &#123; this.content = content; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!-- Copyright 2009-2016 the original author or authors. Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.--&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;!--类似于 java package 的用法，用来区分不同项目,namespace 必须添加--&gt;&lt;mapper namespace="Message"&gt; &lt;!--对应 jdbc 的 message.setId(rs.getString("ID")); 等方法--&gt; &lt;!--type 表示的是数据库字段对应 java 中哪个类的对象；id 随意取名；--&gt; &lt;!--如果在数据库中为主键，则配 id colum,否则配 result colum 标签；--&gt; &lt;!--colum 对应数据库列的属性名；property 是数据库对应 java bean对象中的属性名--&gt; &lt;!--jdbcType 对应数据库中属性的类型 Int、varchar 等--&gt; &lt;resultMap type="com.imooc.bean.Message" id="MessageResult"&gt; &lt;id column="ID" jdbcType="INTEGER" property="id"/&gt; &lt;result column="COMMAND" jdbcType="VARCHAR" property="command"/&gt; &lt;result column="DESCRIPTION" jdbcType="VARCHAR" property="description"/&gt; &lt;result column="CONTENT" jdbcType="VARCHAR" property="content"/&gt; &lt;/resultMap&gt; &lt;!--select id 必须是唯一的，但与 resultMap 中的 id 可以重名--&gt; &lt;!--resultMap 指向 resultMap 标签的 id--&gt; &lt;select id="queryMessageList" resultMap="MessageResult"&gt; select ID,COMMAND,DESCRIPTION,CONTENT from MESSAGE where 1=1 &lt;/select&gt;&lt;/mapper&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!-- Copyright 2009-2016 the original author or authors. Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.--&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;!-- &lt;settings&gt; &lt;setting name="useGeneratedKeys" value="false"/&gt; &lt;setting name="useColumnLabel" value="true"/&gt; &lt;/settings&gt; &lt;typeAliases&gt; &lt;typeAlias alias="UserAlias" type="org.apache.ibatis.submitted.complex_property.User"/&gt; &lt;/typeAliases&gt; --&gt; &lt;environments default="development"&gt; &lt;environment id="development"&gt; &lt;transactionManager type="JDBC"&gt; &lt;property name="" value=""/&gt; &lt;/transactionManager&gt; &lt;dataSource type="UNPOOLED"&gt; &lt;property name="driver" value="com.mysql.jdbc.Driver"/&gt; &lt;property name="url" value="jdbc:mysql://127.0.0.1:3306/micro_message"/&gt; &lt;property name="username" value="root"/&gt; &lt;property name="password" value="dfwhj43815"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!--用来引入 sqlxml 配置文件的内容--&gt; &lt;mappers&gt; &lt;!--mapper 可以多个--&gt; &lt;mapper resource="com/imooc/config/sqlxml/Message.xml"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.imooc.dao;import com.imooc.bean.Message;import com.imooc.db.DBAccess;import org.apache.ibatis.session.SqlSession;import java.io.IOException;import java.sql.*;import java.util.ArrayList;import java.util.List;//Dao 层跟表相关，此 dao 包含跟 message 表相关的操作public class MessageDao &#123; /** * mybytis 根据查询条件查询消息列表 (mybatis 方法) */ public List&lt;Message&gt; queryMessageList(String command,String description)&#123; DBAccess dbAccess = new DBAccess(); //要在 final 中关闭此会话，所以放在外面 SqlSession sqlSession = null; //创建 List 将查询语句内容放进 List 中 List&lt;Message&gt;messageList = new ArrayList&lt;Message&gt;(); //捕获 DBAccess 抛出的异常 try &#123; sqlSession = dbAccess.getSqlSession(); //通过 sqlSession 执行 sql 语句；值为 namespace.resultMap messageList = sqlSession.selectList("Message.queryMessageList"); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally&#123; if(sqlSession!=null)&#123; sqlSession.close(); &#125; &#125; return messageList; &#125; // public static void main(String[] args) &#123;// MessageDao messageDao = new MessageDao();// messageDao.queryMessageList("","");//// &#125;&#125; 123456789101112131415161718192021222324package com.imooc.db;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import java.io.IOException;import java.io.Reader;/** * 访问数据库类 */public class DBAccess &#123; public SqlSession getSqlSession() throws IOException &#123; //通过配置文件获取数据库连接信息 Reader reader = Resources.getResourceAsReader("com/imooc/config/Configuration.xml"); //通过配置信息构建一个 SqlSessionFactory SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(reader); //通过 sqlSessionFactory 打开一个数据库会话 SqlSession sqlSession = sqlSessionFactory.openSession(); return sqlSession; &#125;&#125; 1234567891011121314package com.imooc.service;import com.imooc.bean.Message;import com.imooc.dao.MessageDao;import java.util.List;public class ListService &#123; //调用 MessageDao 进行数据操作，再由 ListServlet 调用。将值返回给 ListServlet public List&lt;Message&gt; queryMessageList(String command, String description)&#123; MessageDao messageDao = new MessageDao(); return messageDao.queryMessageList(command,description); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142package com.imooc.servlet;import com.imooc.bean.Message;import com.imooc.service.ListService;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.sql.*;import java.util.ArrayList;import java.util.List;/** * 列表页面初始化控制 */@WebServlet(name="ListServlet" ,urlPatterns = "/List.action")public class ListServlet extends HttpServlet&#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //设置编码 req.setCharacterEncoding("utf-8"); //接受页面的值 String command = req.getParameter("command"); String description = req.getParameter("description"); //向页面传值 req.setAttribute("command",command); req.setAttribute("description",description); //查询消息列表并传给页面。调用 ListService 的函数，将查询的结果放到 req 中 ListService listService = new ListService(); req.setAttribute("messageList",listService.queryMessageList(command,description)); //向页面跳转 req.getRequestDispatcher("/WEB-INF/jsp/back/list.jsp").forward(req,resp); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; this.doGet(req, resp); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;&lt;%--使用 jstl--%&gt;&lt;%@taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %&gt;&lt;%--拼接当前网页相对路径--%&gt;&lt;% String path = request.getContextPath(); String basePath = request.getScheme()+"://"+request.getServerName()+":"+request.getServerPort()+path;%&gt;&lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;&lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /&gt; &lt;meta http-equiv="X-UA-Compatible"content="IE=9; IE=8; IE=7; IE=EDGE" /&gt; &lt;title&gt;内容列表页面&lt;/title&gt; &lt;%--css 文件的相对路径--%&gt; &lt;link href="&lt;%=basePath%&gt;/resources/css/all.css" rel="stylesheet" type="text/css" /&gt;&lt;/head&gt;&lt;body style="background: #e1e9eb;"&gt;&lt;%--提交到 ListServlet 上进行初始化与查询--%&gt;&lt;form action="&lt;%=basePath%&gt;/List.action" id="mainForm" method="post"&gt; &lt;div class="right"&gt; &lt;div class="current"&gt;当前位置：&lt;a href="javascript:void(0)" style="color:#6E6E6E;"&gt;内容管理&lt;/a&gt; &amp;gt; 内容列表&lt;/div&gt; &lt;div class="rightCont"&gt; &lt;p class="g_title fix"&gt;内容列表 &lt;a class="btn03" href="#"&gt;新 增&lt;/a&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;a class="btn03" href="#"&gt;删 除&lt;/a&gt;&lt;/p&gt; &lt;table class="tab1"&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td width="90" align="right"&gt;指令名称：&lt;/td&gt; &lt;td&gt; &lt;input name="command" type="text" class="allInput" value="$&#123;command&#125;"/&gt; &lt;/td&gt; &lt;td width="90" align="right"&gt;描述：&lt;/td&gt; &lt;td&gt; &lt;input name="description" type="text" class="allInput" value="$&#123;description&#125;"/&gt; &lt;/td&gt; &lt;td width="85" align="right"&gt;&lt;input type="submit" class="tabSub" value="查 询" /&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;div class="zixun fix"&gt; &lt;table class="tab2" width="100%"&gt; &lt;tbody&gt; &lt;tr&gt; &lt;th&gt;&lt;input type="checkbox" id="all" onclick="#"/&gt;&lt;/th&gt; &lt;th&gt;序号&lt;/th&gt; &lt;th&gt;演示字段1&lt;/th&gt; &lt;th&gt;演示字段2&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;c:forEach items="$&#123;messageList&#125;" var="message" varStatus="status"&gt; &lt;tr &lt;c:if test="$&#123;status.index % 2 != 0&#125;"&gt;style='background-color:#ECF6EE;'&lt;/c:if&gt;&gt; &lt;td&gt;&lt;input type="checkbox" /&gt;&lt;/td&gt; &lt;td&gt;$&#123;status.index + 1&#125;&lt;/td&gt; &lt;td&gt;$&#123;message.command&#125;&lt;/td&gt; &lt;td&gt;$&#123;message.description&#125;&lt;/td&gt; &lt;td&gt; &lt;a href="#"&gt;修改&lt;/a&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;a href="#"&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;div class='page fix'&gt; 共 &lt;b&gt;4&lt;/b&gt; 条 &lt;a href='###' class='first'&gt;首页&lt;/a&gt; &lt;a href='###' class='pre'&gt;上一页&lt;/a&gt; 当前第&lt;span&gt;1/1&lt;/span&gt;页 &lt;a href='###' class='next'&gt;下一页&lt;/a&gt; &lt;a href='###' class='last'&gt;末页&lt;/a&gt; 跳至&amp;nbsp;&lt;input type='text' value='1' class='allInput w28' /&gt;&amp;nbsp;页&amp;nbsp; &lt;a href='###' class='go'&gt;GO&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 123456789程序未报错，但 tomcat 连接后直接停止：Connected to the target VM, address: &apos;127.0.0.1:10605&apos;, transport: &apos;socket&apos;Disconnected from the target VM, address: &apos;127.0.0.1:10605&apos;, transport: &apos;socket&apos;解决方法：把 main 测试函数注释掉，通过 tomcat 发布文件 idea 导入本地 jar 包源码 log4j.appender.Console.layout.ConversionPattern=%d [%t] %-5p [%c] - %m%n %d 日志生成的时间 %t 是产生日志所处的线程名称 %p 输出日志的级别，%-5p 将占5位字符，不足5位用空格填补，- 指的是在右边补空 %c 你输出日志的包以及类的全名 %m 是你附加的信息 %n 换行]]></content>
      <tags>
        <tag>MyBatis，java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AnnTest java 注解]]></title>
    <url>%2F2018%2F07%2F18%2FAnnTest%2F</url>
    <content type="text"><![CDATA[运行机制划分注解 源码注解：只在源码中存在，编译成 .class 文件就不存在了。 编译时注解：注解在源码和 .class 文件中都存在 @Override @Deprecated @Suppvisewarning @Override ：表示覆写了某一个方法 @Deprecated ：表示一个方法已经过期，可用 @Suppvisewarning 忽略警告 运行时注解：在运行阶段还起作用，甚至会影响运行逻辑的注解。 @Autowired 1234567891011package com.ann.test;public class Test &#123; //忽略方法中的方法过期警告，也可以放在类外，忽略整个类的过期警告 @SuppressWarnings("deprecation") public void sing()&#123; Person p = new Child(); p.sing(); &#125;&#125; 123456789package com.ann.test;public interface Person &#123; public String name(); public int age(); //提示方法已过期 @Deprecated public void sing();&#125; 解析注解 1234元注解RetentionPolicy，表明注解的生命周期：1、SOURCE：在原文件中有效，被编译器丢弃。 2、CLASS：在class文件有效，可能会被虚拟机忽略。 3、RUNTIME：在运行时有效。 @Inherited 元注解是一个标记注解，@Inherited阐述了某个被标注的类型是被继承的。 如果一个使用了@Inherited修饰的annotation类型被用于一个class，则这个annotation将被用于该class的子类。 注意：@Inherited annotation类型是被标注过的class的子类所继承。类并不从它所实现的接口继承annotation， 方法并不从它所重载的方法继承annotation。 @Inherited 对接口没作用，只会继承类 123456789101112package com.ann.test;import java.lang.annotation.*;import java.util.Map;//自定义注解，在 Child 中使用@Target(&#123;ElementType.METHOD,ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Inherited@Documentedpublic @interface Description &#123; String value();&#125; 12345678910111213141516171819package com.ann.test;@Description("i am class annotation")public class Child implements Person &#123; @Override @Description("i am method annotation") public String name() &#123; return null; &#125; @Override public int age() &#123; return 0; &#125; @Override public void sing() &#123; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.ann.test;import java.lang.annotation.Annotation;import java.lang.reflect.Method;//只能取到运行时加载public class PraseAnn &#123; public static void main(String[] args) &#123; try &#123; //使用类加载器加载类 Class c = Class.forName("com.ann.test.Child"); //找到类上的注解 boolean isExist = c.isAnnotationPresent(Description.class); if(isExist)&#123; //拿到注解实例 Description d = (Description) c.getAnnotation(Description.class); System.out.println(d.value()); &#125; //找到方法上的注解 Method[] ms = c.getMethods(); for (Method m : ms) &#123; boolean isMExist = m.isAnnotationPresent(Description.class); if(isMExist)&#123; Description d = m.getAnnotation(Description.class); System.out.println(d.value()); &#125; &#125; //另一种解析方法 for (Method m : ms) &#123; Annotation[]as = m.getAnnotations(); for (Annotation a : as) &#123; if(a instanceof Description)&#123; Description d = (Description) a; System.out.println(d.value()); &#125; &#125; &#125; &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 运行 PraseAnn 输出结果 i am class annotationi am method annotationi am method annotation java 注解 Element 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192package com.imooc.test;@Table("user")public class Filter &#123; /** Column column = field.getAnnotation(Column.class);得到的是字段上注解内容，然后通过 String columnName = column.value();得到就是此注解下的字段名， @Column("id") （好比上面的 column，不过只是比如column是一个注解对象） private int id; （columnName 就得到的是 id ） @Table("数据库中的表名") @Column("数据库中的列名/字段名:id/user_name...") */ @Column("id") private int id; @Column("user_name") private String userName; @Column("nick_name") private String nickName; @Column("age") private int age; @Column("city") private String city; @Column("email") private String email; @Column("mobile") private String mobile; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getUserName() &#123; return userName; &#125; public void setUserName(String userName) &#123; this.userName = userName; &#125; public String getNickName() &#123; return nickName; &#125; public void setNickName(String nickName) &#123; this.nickName = nickName; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getCity() &#123; return city; &#125; public void setCity(String city) &#123; this.city = city; &#125; public String getEmail() &#123; return email; &#125; public void setEmail(String email) &#123; this.email = email; &#125; public String getMobile() &#123; return mobile; &#125; public void setMobile(String mobile) &#123; this.mobile = mobile; &#125;&#125; 123456789101112131415package com.imooc.test;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;//作用域：类或接口@Target(&#123;ElementType.TYPE&#125;)//生命周期：运行时@Retention(RetentionPolicy.RUNTIME)public @interface Table &#123; //使用值只有一个：表名 user String value();&#125; 1234567891011121314package com.imooc.test;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;//作用域：字段、枚举的常量@Target(&#123;ElementType.FIELD&#125;)//生命周期：运行时有效@Retention(RetentionPolicy.RUNTIME)public @interface Column &#123; String value();&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485package com.imooc.test;import java.io.ObjectInputStream;import java.lang.reflect.Field;import java.lang.reflect.Method;public class Test &#123; public static void main(String[] args) &#123; Filter f1 = new Filter(); f1.setId(10);//查询 id 为 10 的用户 Filter f2 = new Filter(); f2.setUserName("lucy");//查询用户名为 lucy 的用户 Filter f3 = new Filter(); f3.setEmail("liu@sina.com,zh@163.com,77777@qq.com");//查询邮箱为其中任意一个用户 String sql1 = query(f1); String sql2 = query(f2); String sql3 = query(f3); System.out.println(sql1); System.out.println(sql2); System.out.println(sql3); &#125; private static String query(Filter f)&#123; StringBuilder sb = new StringBuilder(); //获取 class Class c = f.getClass(); //获取 table 的名字 boolean exists = c.isAnnotationPresent(Table.class); if(!exists)&#123; return null; &#125; Table t = (Table) c.getAnnotation(Table.class); String tableName = t.value(); /** * 例如为不定数量的查询条件，我们在后台写查询的时候， 类似于这样的语句 string sql ="select * from table where" 为了使语句通顺不报错，加上 where 1=1 */ sb.append("select * form").append(tableName).append("where 1=1"); //遍历所有的字段 Field[] fArray = c.getDeclaredFields(); for (Field field : fArray) &#123; //处理每个字段对应的 sql //拿到字段名 boolean fExists = field.isAnnotationPresent(Column.class); if(!fExists)&#123; continue; &#125; Column column = field.getAnnotation(Column.class); String columnName = column.value(); //拿到字段值 String filedName = field.getName(); String getMethodName = "get" + filedName.substring(0,1).toUpperCase()+filedName.substring(1); //通过反射取得 method System.out.println(getMethodName); Object fieldValue = null; try &#123; Method getMethod = c.getMethod(getMethodName); fieldValue = getMethod.invoke(f); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; //拼装 sql if(fieldValue==null ||(fieldValue instanceof Integer &amp;&amp; (Integer)fieldValue==0))&#123; continue; &#125; sb.append(" and ").append(filedName); if(fieldValue instanceof String)&#123; sb.append("=").append("'").append(columnName).append("'"); &#125;else if(fieldValue instanceof Integer) &#123; sb.append("=").append(columnName); &#125; &#125; return sb.toString(); &#125;&#125;]]></content>
      <tags>
        <tag>java,注解,imooc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Reflection 反射]]></title>
    <url>%2F2018%2F07%2F17%2Factive-class%2F</url>
    <content type="text"><![CDATA[反射 指的是可以于运行时加载,探知和使用编译期间完全未知的类. 程序在运行状态中, 可以动态加载一个只有名称的类, 对于任意一个已经加载的类,都能够知道这个类的所有属性和方法; 对于任意一个对象,都能调用他的任意一个方法和属性; 加载完类之后, 在堆内存中会产生一个Class类型的对象(一个类只有一个Class对象), 这个对象包含了完整的类的结构信息,而且这个Class对象就像一面镜子,透过这个镜子看到类的结构,所以被称之为:反射。 不是所有的实例化都是 new ，new 时必须知道这个类是什么，而很多时候做不到预先知道类名，很多框架如 Spring 应用了反射的原理。 new 创建的对象是 静态加载类，在编译时就需要加载所有可能用到的类，若在编译时找不到类直接报错。一个功能有问题，其他功能都无法使用。 class 为类类型/字节码（编译后的类） OfficeBetter.java 1234567891011121314151617181920212223class OfficeBetter&#123; public static void main(String args [])&#123; try&#123; //动态加载类，在运行时加载 Class c = Class.forName(args[0]); OfficeAble oa = (OfficeAble)c.newInstance(); oa.start(); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; &#125;&#125; OfficeAble.java 1234567interface OfficeAble&#123; //创建接口，由使用者来实现该接口,重写 start 方法 public void start();&#125; Word.java 123456789class Word implements OfficeAble&#123; public void start()&#123; System.out.println("word--starts"); &#125;&#125; 编译 javac *.java 运行 java OfficeBetter Word (main 类 + 实现接口类) 输出结果 word–starts 获取类的信息首先要获取类的类类型 Class c1 = int.class; //int 的类类型 String c2 = String.class //String 的类类型 void c3 = void.class System.out.println(c1.getName()); //打印包含包名的类的名称 System.out.println(c2.getSimpleName()); //打印不包含包名的类的名称 System.out.println(c3.getName()); //打印结果：void 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package com.imooc.reflect;public class ClassUtil &#123; public static void PrintClassMessage(Object obj) &#123; //传递的是哪个子类的对象，c 就是该子类的类类型 Class c = obj.getClass(); //getMethods() 获取所有 public 的函数，包括父类继承而来的 //getDeclaredMethods() 获取的是该类自己声明的方法，不问访问权限； Method [] ms = c.getMethods(); for(int i = 0; i &lt; ms.length; i++)&#123; //得到方法返回值类型的类类型 Class returnType = ms[i].getReturnType(); System.out.print(returnType.getName()+""); //得到方法的名称 System.out.print(ms[i].getName()+"("); //获取参数类型，得到的是参数列表的类型的类类型 Class [] paramTypes = ms[i].getParameterTypes(); for(Class class1:paramTypes)&#123; System.out.print(class1.getName()+","); &#125; System.out.println(")"); &#125; public static void printFieldMessage(Object obj) &#123; Class c = obj.getClass(); //成员变量也是对象； Field[] fs = c.getDeclaredFields(); for (Field field : fs) &#123; Class fieldType = field.getType(); String typeName = fieldType.getName(); //得到成员变量名称 String fieldName = field.getName(); System.out.println(typeName + " " + fieldName); &#125; &#125; //打印对象的构造函数信息 public static void printConMessage(Object obj)&#123; Class c = obj.getClass(); /*构造函数也是对象 java.lang.Constructor 封装了构造函数的信息 getConstructors 获取所有的 public 的构造函数 Constructor []cs = c.getConstructors(); */ Constructor [] cs = c.getDeclaredConstructors(); for (Constructor constructor : cs) &#123; System.out.print(constructor.getName()+"("); //获取构造函数的参数列表--&gt;得到的是参数列表的类类型 Class[] parameterTypes = constructor.getParameterTypes(); for (Class class1 : parameterTypes) &#123; System.out.print(class1.getName()+","); &#125; System.out.println(")"); &#125; &#125;&#125; 1234567891011package com.imooc.reflect;//PrintClassMessage 方法测试类public class ClassDemo3 &#123; public static void main(String[] args) &#123; String s = &quot;hello&quot;; ClassUtil.PrintClassMessage(s); Integer n1 = 1; ClassUtil.PrintClassMessage(n1); &#125;&#125; 123456789package com.imooc.reflect;//printieldMessage() 方法测试类public class ClassDemo4 &#123; public static void main(String[] args) &#123; ClassUtil.printFieldMessage(&quot;hello&quot;); System.out.println(&quot;==========&quot;); ClassUtil.printFieldMessage(new Integer(1)); &#125;&#125; 12345678package com.imooc.reflect;//printConMessage() 方法测试类public class ClassDemo5 &#123; public static void main(String[] args) &#123; ClassUtil.printConMessage(&quot;hello&quot;); ClassUtil.printConMessage(new Integer(1)); &#125;&#125; 方法的反射操作 method.invoke(对象，参数列表) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package com.imooc.reflect;import java.lang.reflect.Method;public class MethodDemo1 &#123; public static void main(String[] args) &#123; //获取print(int a,int b)方法，获取一个方法就是获取类的信息，获取类的信息就要获得类的类类型 A a1 = new A(); Class c = a1.getClass(); /** * 获取方法 名称和参数决定 * getMethod 获取的是 public 的方法 * getDelcaredMethod 自己声明的方法 */ try &#123; Method m = c.getMethod("print", int.class, int.class);// 或 Method m = c.getMethod("pirnt", new Class[]&#123;int.class, int.class&#125;); /** * 方法的反射操作 * a1.print(10,20); 方法的反射操作是用 m 对象来进行方法的调用 和 a1.print 调用效果完全相同 * 方法没有返回值，则返回 null ，有返回值则返回具体的返回值 */ Object o = m.invoke(a1, new Object[]&#123;10, 20&#125;); System.out.println("==========="); //获取方法对象 Method m1 = c.getMethod("print", String.class, String.class); //用方法进行反射操作 o = m1.invoke(a1, "Hello", "Word"); System.out.println("==========="); Method m2 = c.getMethod("print"); //或 Method m1 = c.getMethod("print", new Class[]&#123;&#125;); m2.invoke(a1); // 或m2.invoke(a1,new Object[]&#123;&#125;); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125;class A&#123; public void print(int a,int b)&#123; System.out.println(a+b); &#125; public void print(String a,String b)&#123; System.out.println(a.toUpperCase() + "," + b.toLowerCase()); &#125; public void print()&#123; System.out.println("hello Word"); &#125;&#125; 通过反射了解泛型本质 class 为类类型/字节码（编译后的类） class/method 等反射操作都是绕过编译的操作 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.imooc.reflect;import java.lang.reflect.Method;import java.util.ArrayList;public class MethodDemo4 &#123; public static void main(String[] args) &#123; ArrayList list = new ArrayList(); //泛型，只能放 String 类型； //防止加入 list1.add(10); 这种操作 ArrayList&lt;String&gt;list1 = new ArrayList&lt;&gt;(); list1.add("hello"); Class c1 = list.getClass(); Class c2 = list1.getClass(); System.out.println(c1 == c2); /** * 反射的操作都是编译之后的操作（跳过编译阶段） * c1 == c2 返回 true 说明编译之后的集合泛型是去泛型化的 * java 中集合的泛型是防止错误输入，只在编译阶段有效，绕过编译就无效 * 验证：通过方法反射操作，绕过编译 */ Method m = null; try &#123; m = c2.getMethod("add", Object.class); m.invoke(list1,10);//绕过编译操作就绕过了泛型 System.out.println(list1.size()); /** * for (String string : list1) &#123; System.out.println(string); &#125; 此时遍历会发生错误异常，提示不能将 int 转换成 String * java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String */ &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125;]]></content>
      <tags>
        <tag>imooc，reflection,反射</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo next 搭建博客]]></title>
    <url>%2F2018%2F07%2F11%2Farticle-title%2F</url>
    <content type="text"><![CDATA[hexo 安装 插入图片： node_modules：是依赖包public：存放的是生成的页面scaffolds：命令生成文章等的模板source：用命令创建的各种文章themes：主题_config.yml：整个博客的配置db.json：source解析所得到的package.json：项目所需模块项目的配置信息 接下来依次在命令行输入hexo ghexo s 在浏览器中打开http://localhost:4000/，看到网页则配置结束 将Hexo与github page 联系起来 设置Git的user name和email：(如果是第一次的话) git config --global user.name &quot;crow-song&quot;git config --global user.email &quot;crowsong.end@gmail.com&quot; 设置 ssh 密钥 参考：https://blog.csdn.net/love_fdu_llp/article/details/38752365 https://jingyan.baidu.com/article/a65957f4e91ccf24e77f9b11.html 检查本机是否有ssh key设置 $ cd ~/.ssh 或cd .ssh 如果没有则提示： No such file or directory 如果有则进入~/.ssh路径下（ls查看当前路径文件，rm * 删除所有文件) ssh-keygen -t rsa -C &quot;crowsong.end@gmail.com&quot; 生成密钥对 之后全部 enter 就行 秘钥存放路径为：c:/Users/xxxx_000/.ssh/下 查看你生成的公钥：$ cat ~/.ssh/id_rsa.pub 复制公钥到 github 账户的 AccountSettings → SSHKeys → 点击 new SSH Key title 随意填写，公钥复制进文本域内 点击确定 确认设置 验证下这个key是不是正常工作。 $ ssh -T git@github.com # Attempts to ssh to github 键入 yes 看到： Hi username! You’ve successfully authenticated, but GitHub does not # provide shell access. 就表示设置成功。 接下来使用 hexo d 不再需要输入用户和密码了 配置Deployment同样在_config.yml文件中，找到Deployment，然后按照如下修改：repo 中是仓库地址（自己的 git 发布网址） deploy: type:git repo:https://crow-song.github.io/ branch:master 写博客新建一篇博客，执行下面的命令： hexo new post “article title” 这时候在我的 电脑的目录下 ..\hexo\source\ _posts 将会看到 article title.md 文件 用MarDown编辑器打开就可以编辑文章了。文章编辑好之后，运行生成、部署命令： hexo g hexo d 参考：https://blog.csdn.net/gdutxiaoxu/article/details/53576018 hexo的next主题个性化教程 修改 css 样式，找到目标对应 css 文件，修改 background:#transparent （面板透明色） rgba(255,255,255,.9) 添加网易云音乐插件 在 mian.xxxx.css 中设置位置 .header-music {margin-top: 55px;margin-left: 0px; } nofollw 作用 添加图片 可用样式为 图片放在对应 md 文件的文件夹中 背景图 将括号里面的这里填写背景图片地址替换为你所要显示的背景图片地址，#ffffff表示背景颜色为#ffffff(白色)修改为你想要的背景颜色代码，repeat表示图片平铺，不平铺改为no-repeat，scroll表示图片随对象滚动，图片固定不滚动改为fixed。 头像旋转放大： hover 选择器使用 选择鼠标移到链接上的样式 xxx:hover(xxx 可以是 img 也可以是类选择器等。如果直接使用 img:hover 会将插入图片一起放大) .site-author-image:hover 设置网站图标 Favicon Typora markdown 语法 github fork 别人的博客后 404 错误https://github.com/qiubaiying/qiubaiying.github.io/issues/98在code下找到CNAME文件，将里面的内容改为：https://你的Github账号名.github.io，然后点底部的commit changes，应该就可以了 hexo d 或 hexo deploy 无反应解决: 配置文档中 _config.yml 冒号后需要加空格deploy:type: gitrepo: https://github.com/crow-song/crow-song.github.io.gitbranch: master hexo g 错误ERROR Process failed: _posts/article-title.mdYAMLException: can not read a block mapping entry; a multiline key may not be an implicit key at line 4, column 1:md 文档中开头 3 个标题冒号后也需要加空格title: article titledate: 2018-07-11 23:09:21tags: 博客创建]]></content>
      <tags>
        <tag>博客创建</tag>
      </tags>
  </entry>
</search>
