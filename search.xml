<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[hibernate]]></title>
    <url>%2F2019%2F01%2F15%2Fhibernate%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Listener_Filter]]></title>
    <url>%2F2018%2F12%2F25%2FListener_Filter%2F</url>
    <content type="text"><![CDATA[监听器 Listener监听器概念监听某个对象的状态变化的组件 事件源：被监听的对象 – 三个域对象 request、session、servletContext 监听器：监听事件源对象 – 事件源对象的状态变化都会触发监听器 – 6+2 注册监听器：将监听器与事件源进行绑定 相应行为：监听器监听到事件源的状态变化时所涉及的功能代码 – 需要编写 监听器分类第一维度：按照被监听对象划分：ServletRequest 域、 HttpSession 域、servletContext 域 第二维度：安装监听的内容分：监听域对象的创建与销毁 监听域对象的属性变化 监听三大域对象的创建与销毁的监听器监听 ServletContext 域的创建与销毁的监听器 ServletContextListener servlet 与的生命周期 何时创建：服务器启动创建 何时销毁：服务器关闭销毁 监听器编写步骤（重点） 编写一个监听器类去实现监听器接口 （6+2 中选） 覆盖监听器的方法 在 web.xml 中进行配置 监听方法 6个监听器 ：ServletContext、HttpSession、ServletRequest 域 + Listener / AttributeListener ServletContextListener 的主要作用 初始化的工作：初始化数据 – 加载数据库驱动、连接池的初始化 加载一些初始化的配置文件 – spring 配置文件 12345//配置 spring 的核心监听器 //ContextLoaderListener implements ServletContextListener 实现了 监听器接口&lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;listener-class&gt;&lt;/listener&gt; 以上配置监听器用来在服务器开启时加载 spring 配置文件 applicationContext.xml 任务调度 – 定时器 Timer、TimerTask httpSession 域的 创建与销毁 监听器，在一个客户端访问时会创建一个 session jsp 页面默认被转换成 sevlet 会自动添加 pageContext.getSession 方法 一般只用来记录页面访问人数 2个监听器：与 session 中的绑定对象相关的监听器（对象感知监听器） 4个状态都是针对 存放到 session 中的对象的 即将绑定到 session 的对象状态： 绑定状态：一个对象被放到 session 中 解绑状态：一个对象被 session 移除 钝化状态：将 session 内存中的对象持久化（序列化）到磁盘 活化状态 绑定与解绑监听器： HttpSessionbindingListener ：是给对象用的，对象自己知道自己被绑或解绑 感知监听器不用配置 xml 面试题：当用户很多时，怎么对服务器进行优化？ 答：把待机很久不动的用户 session （服务器内存）中的内容存到磁盘中，如果用户回来了就将磁盘中的内容返回给用户 钝化与活化监听器：HttpSessionActivationListener 钝化（服务器关闭后）tomcat 文件夹下会有一个 SESSIONS.ser 文件 ，对象需要 实现 Serializable 接口才能真正钝化（序列化）到磁盘，不然会无法活化 服务器正常关闭或启动 实现钝化活化 使用钝化与活化监听器需要在 webContent/META-INF 下配置 context.xml 过滤器 Filter过滤器概念 filter 是对客户端访问资源的过滤，符合要求的放行不符合的不放行，并且可以对目标访问资源前后进行逻辑处理 编写一个过滤器的类实现 Filter 接口 实现接口中尚未实现的方法（着重实现 doFilter 方法） 在 web.xml 中进行配置（主要对过滤哪些资源配置进行配置） 作用：权限控制、公共代码的提取、对 request 和 response 中的方法进行增强（装饰者模式/动态代理） 增强方法：在 filter 中获得 request 与 response 时进行增强再发送给客户端 核心过滤方法 ：doFilter 放行请求：doFilter(resqust,response); doFilter(ServletRequest,ServletResponse){ } doFilter 内部请求是 ServletRequest，所以无法使用一些 HttpServletRequest 的 Api 如 request.getSession()，需要把它强转成子类，servlet 内部的 doGet doPost 方法都是底层源码自动强转过的 HttpServletRequest FilterChian 对象 内部有所有 Filter 的索引与顺序 过滤器的执行顺序看 web.xml 中 配置的先后顺序 异常报错： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889HTTP Status 500 – Internal Server ErrorTypeException ReportMessage An exception occurred processing JSP page [/index.jsp] at line [27]Description The server encountered an unexpected condition that prevented it from fulfilling the request.Exceptionorg.apache.jasper.JasperException: An exception occurred processing JSP page [/index.jsp] at line [27]24: 鑼冨洿浠庡皬鍒板ぇ page鍩�(pageContext 瀵硅薄)--&gt;request鍩�--&gt;session鍩�--&gt;application鍩�(servletContext)--%&gt;25: &lt;%--&lt;%=pageContext.findAttribute(&quot;name&quot;)%&gt;--%&gt;26: &lt;!-- 寮曞叆header.jsp --&gt;27: &lt;jsp:include page=&quot;/header.jsp&quot;&gt;&lt;/jsp:include&gt;28: 29: &lt;!-- 杞挱鍥� --&gt;30: &lt;div class=&quot;container-fluid&quot;&gt;Stacktrace: org.apache.jasper.servlet.JspServletWrapper.handleJspException(JspServletWrapper.java:584) org.apache.jasper.servlet.JspServletWrapper.service(JspServletWrapper.java:466) org.apache.jasper.servlet.JspServlet.serviceJspFile(JspServlet.java:386) org.apache.jasper.servlet.JspServlet.service(JspServlet.java:330) javax.servlet.http.HttpServlet.service(HttpServlet.java:742) org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52) Root Causeorg.apache.jasper.JasperException: An exception occurred processing JSP page [/header.jsp] at line [20]17: &lt;li&gt;&lt;a href=&quot;register.jsp&quot;&gt;娉ㄥ唽&lt;/a&gt;&lt;/li&gt;18: &lt;/c:if&gt;19: &lt;c:if test=&quot;$&#123;user != null&#125;&quot;&gt;20: 娆㈣繋鎮�,$&#123;user.username &#125;21: &lt;/c:if&gt;22: &lt;li&gt;&lt;a href=&quot;cart.jsp&quot;&gt;璐墿杞�&lt;/a&gt;&lt;/li&gt;23: &lt;li&gt;&lt;a href=&quot;order_list.jsp&quot;&gt;鎴戠殑璁㈠崟&lt;/a&gt;&lt;/li&gt;Stacktrace: org.apache.jasper.servlet.JspServletWrapper.handleJspException(JspServletWrapper.java:584) org.apache.jasper.servlet.JspServletWrapper.service(JspServletWrapper.java:481) org.apache.jasper.servlet.JspServlet.serviceJspFile(JspServlet.java:386) org.apache.jasper.servlet.JspServlet.service(JspServlet.java:330) javax.servlet.http.HttpServlet.service(HttpServlet.java:742) org.apache.jasper.runtime.JspRuntimeLibrary.include(JspRuntimeLibrary.java:894) org.apache.jsp.index_jsp._jspService(index_jsp.java:144) org.apache.jasper.runtime.HttpJspBase.service(HttpJspBase.java:70) javax.servlet.http.HttpServlet.service(HttpServlet.java:742) org.apache.jasper.servlet.JspServletWrapper.service(JspServletWrapper.java:443) org.apache.jasper.servlet.JspServlet.serviceJspFile(JspServlet.java:386) org.apache.jasper.servlet.JspServlet.service(JspServlet.java:330) javax.servlet.http.HttpServlet.service(HttpServlet.java:742) org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52) Root Causejavax.el.PropertyNotFoundException: Property [username] not found on type [com.itheima.domain.User] javax.el.BeanELResolver$BeanProperties.get(BeanELResolver.java:260) javax.el.BeanELResolver$BeanProperties.access$300(BeanELResolver.java:212) javax.el.BeanELResolver.property(BeanELResolver.java:347) javax.el.BeanELResolver.getValue(BeanELResolver.java:92) org.apache.jasper.el.JasperELResolver.getValue(JasperELResolver.java:110) org.apache.el.parser.AstValue.getValue(AstValue.java:169) org.apache.el.ValueExpressionImpl.getValue(ValueExpressionImpl.java:184) org.apache.jasper.runtime.PageContextImpl.proprietaryEvaluate(PageContextImpl.java:944) org.apache.jsp.header_jsp._jspx_meth_c_005fif_005f1(header_jsp.java:301) org.apache.jsp.header_jsp._jspService(header_jsp.java:137) org.apache.jasper.runtime.HttpJspBase.service(HttpJspBase.java:70) javax.servlet.http.HttpServlet.service(HttpServlet.java:742) org.apache.jasper.servlet.JspServletWrapper.service(JspServletWrapper.java:443) org.apache.jasper.servlet.JspServlet.serviceJspFile(JspServlet.java:386) org.apache.jasper.servlet.JspServlet.service(JspServlet.java:330) javax.servlet.http.HttpServlet.service(HttpServlet.java:742) org.apache.jasper.runtime.JspRuntimeLibrary.include(JspRuntimeLibrary.java:894) org.apache.jsp.index_jsp._jspService(index_jsp.java:144) org.apache.jasper.runtime.HttpJspBase.service(HttpJspBase.java:70) javax.servlet.http.HttpServlet.service(HttpServlet.java:742) org.apache.jasper.servlet.JspServletWrapper.service(JspServletWrapper.java:443) org.apache.jasper.servlet.JspServlet.serviceJspFile(JspServlet.java:386) org.apache.jasper.servlet.JspServlet.service(JspServlet.java:330) javax.servlet.http.HttpServlet.service(HttpServlet.java:742) org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52) Note The full stack trace of the root cause is available in the server logs. 在 jstl 语句中使用了 javaBean 不存在的属性 过滤器解决 post get 乱码问题在传递 request 之前对 request 的 getParameter 方法进行增强 装饰者模式（包装） 增强类与被增强类实现统一接口 在增强类中传入被增强的类 需要增强的方法重写，不需要增强的方法调用被增强类的]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaweb core]]></title>
    <url>%2F2018%2F12%2F14%2Fweb20%2F</url>
    <content type="text"><![CDATA[xml&amp;反射DTD 文件 document type definition ：文档类型定义 用于约束（约定/规定）xml 文档的格式 Scheme 文件，后缀名 .xsd 是 DTD 文件的升级类型，功能比 DTD 文件更多 DOM:将文档一次加载到内存形成树形结构，进行解析，解析成一个 Document 对象 SAX：Simple API for XML ：事件驱动的方式，边读边解析 反射JAVA 反射机制指在运行过程中，对于任意一个类，都能知道这个类的所有属性和方法；对于任意一个对象，都能调用它的任意一个方法和属性 使用反射可以在运行时 (在内存中操作代码) 对 .class 类文件中的字节码（机器代码）进行修改。在运行时对类 Class 、构造方法 Constructor、普通方法 Method、字段 field 进行操作。 反射获得 xml 配置文件中的 Servlet 类，对其进行方法调用（点击详细） //1.创建解析器对象 SAXReader saxReader = new SAXReader(); //2.使用解析器加载web.xml文件得到document对象 Document document = saxReader.read(“src/cn/itheima/web/servlet1/web.xml”); //3.获取根元素节点 Element rootElement = document.getRootElement(); //4.根据元素名称获取子元素节点 Element servletElement = rootElement.element(“servlet”); //5.根据元素名称获取servlet-class的文本节点 String servletClass = servletElement.element(“servlet-class”).getText(); //System.out.println(servletClass); //6.通过类全名获取字节码文件 Class clazz = Class.forName(servletClass); //7.创建实例对象 MyServlet1 my = (MyServlet1) clazz.newInstance(); //8.调用实例对象里面的方法 my.init(); my.service(); my.destory(); 读取 src 下文件比较好的方式是用类加载器： bean.xml 在 src 下时 String path = BeanFactory.class.getLorder().getResource(“”).getPath(“xxx.xml”); 读取 web 应用下最好的方式是用 this.getServletContext.getPath(“xxx”); MySql &amp; JDBC注册驱动： 用类加载器加载字符串描述的驱动类，将其加载到内存，该静态代码会自动执行 Class.forName(“com.mysql.jdbc.Driver”); Driver 底层有着方法，静态代码块在类一加载就运行：static{java.sql.DriverManager.registerDriver(new Driver());} 会自动对自己进行注册 获取连接： DriverManeger.getConnection(url,username,password); limit 关键词查询 （limit 2，2） 第一个参数表示查询起始位置（要查第几页-1）*第二个参数 第二个参数表示每页显示的查询个数 例如一共 11条记录，每页3条记录，要查询第四页的内容 limit（（4-1）*3，3）–&gt;limit（9，3） 最后显示10与11两条记录 limit 是左不包含的 JDBC连接池&amp;DBUtils创建连接池时移除、增加操作多使用 LinkList，查询时使用 ArrayList 1private static DataSource dataSource = new ComboPooledDataSource(); 创建连接池时会自动去寻找 c3p0-config.xml DBUtil 是 JDBC 开发简化工具包，封装了 JDBC 操作，可以很多代码 DBUtils 三个核心功能 QueryRunner：提供对 SQL 语句可操作 API QueryRunner(DataSource ds) 提供数据源（连接池），DBUtils 底层自动维护连接 connection update（String sql，Object … param），执行更新程序,参数可以多个 query（String sql，ResultSetHandlerrsh,Object … param)，执行查询（sql语句，处理结果，obj）参数可以多个 ResultSetHandler 结果处理类： BeanHandler ：将结果集中第一条记录封装到指定 javaBean BeanListHandler : 将结果集中每一条记录封装到指定 javaBean，将这些 javaBean 封装到一个 List 集合 ScalarHandler : 用于单数据，例如 select count(*) from 表 的操作（返回表中某一条件的记录数） 会话技术 Cookie&amp;SessionHttp 协议是无状态的，每个客户端访问服务器资源时，服务器并不知道客户端是谁，所以需要会话技术识别客户端 把无状态客户数据存储到服务器就是 session ，存到客户端本地就是 cookie session 域是服务器端为每个客户端创建的私有的内存空间，而 servletContext 服务端只有一个，是公有的 从打开一个浏览器访问一个站点，到关闭这个浏览器的过程称为一次会话（需要把标签页全部关闭才算关闭浏览器）（面试） 域中可以存任何东西，包括对象。 cookie 中不能存对象，只能存字符串，而且不能为中文 设置 Cookie 持久化时间cookie.setMaxAge(int seconds) – 秒 如果不设置 cookie 的持久化时间，cookie 存储在浏览器内存中，浏览器关闭 cookie 信息销毁(会话级别 cookie) 如果设置持久化时间，cookie 会持久化到浏览器的磁盘文件中 设置 Cookie 路径cookie.setPath(“/“); 如果不设置携带路径，则该 cookie 信息会在访问 设置该 cookie 的同级目录文件时携带该 cookie 信息（产生该 cookie 的 web 资源所在的路径） 删除Cookie如果要 删除 Cookie ，则在同路径下设置一个同名 Cookie（只要 key 相同，value 无所谓） 并设置持久化时间为 0 获得Cookie1234567891011Cookie[] cookies = req.getCookies(); for(Cookie cookie : cookies)&#123; //获得 cookie 名称 String cookieName = cookie.getName(); if(cookie!=null)&#123; if(cookieName.equals("name")) &#123;// 如果名称(key)等于 name 则获取其 value 值（zhangsan） String cookieValue = cookie.getValue(); System.out.println(cookieValue); &#125; &#125; 获取上次登陆时间出现网页报错 错误信息 500 HTTP Status 500 – Internal Server ErrorType Exception Report Message An invalid character [32] was present in the Cookie valueDescription The server encountered an unexpected condition that prevented it from fulfilling the request.Exception java.lang.IllegalArgumentException: An invalid character [32] was present in the Cookie value org.apache.tomcat.util.http.Rfc6265CookieProcessor.validateCookieValue(Rfc6265CookieProcessor.java:182)org.apache.tomcat.util.http.Rfc6265CookieProcessor.generateHeader(Rfc6265CookieProcessor.java:115) org.apache.catalina.connector.Response.generateCookieString(Response.java:1019) org.apache.catalina.connector.Response.addCookie(Response.java:967) org.apache.catalina.connector.ResponseFacade.addCookie(ResponseFacade.java:386)com.itheima.cookie.ShowLastAccessTimeServlet.doGet(ShowLastAccessTimeServlet.java:60) javax.servlet.http.HttpServlet.service(HttpServlet.java:635) javax.servlet.http.HttpServlet.service(HttpServlet.java:742) org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52) Note The full stack trace of the root cause is available in the server logs. ​错误原因：传入 cookie 的日期设置中出现了空格，An invalid character [32] was present in the Cookie value32 就是空格的编码解决：格式化日期时别加入空格参考：https://blog.csdn.net/allan_liu_/article/details/74990162##### Session 技术session 技术是基于 cookie 技术的，session 有一个存储 session 编号的 JSESSIONID，servlet1 得到这个 JSESSIONID 把它返回给客户端，客户端根据这个编号去访问 servlet2 时传递这个编号，从而服务器可以知道这两个 servlet 访问来自一个客户端。coolkie 可以帮助 session 存储 JSESSIONID此方法根据客户端在服务器有无 session，如果没有则创建一个 session，如有则返回该 session 的引用HttpSession session = request.getSession();##### Session 对象生命周期（面试题）创建：第一次运行 request.getSession() 时销毁：1. 服务器（非正常）关闭（如果正常关闭服务器，session 会被监听器从内存钝化到磁盘上，但是这个 session值仍然存在）2. session 过期/失效（默认30分钟） 在 tomcat web.xml 中配置全局（一般在自己项目的 web.xml 配置，只有自己项目没配才会用 tomcat 的全局设置） 123&lt;session-config&gt; &lt;session-timeout&gt;30&lt;/session-timeout&gt;&lt;/session-config&gt; 问：从何时开始的 30 分钟 session 算过期？ 从不操作服务器端资源开始 30 分钟3. 手动销毁 session ，session.invalidate();面试题：浏览器关闭，session 就销毁了吗？不对，session 的销毁方式只有 服务器关闭 跟 客户端一段时间不操作过期 才会销毁，跟客户端关闭与否无关session 作用范围：默认一次会话中（访问服务器到关闭客户端），如果设置了 session 持久化，则在关闭浏览器后再次打开浏览器访问，还是能根据 JSESESSIONID 访问到原来的 sessionsession 一般不建议存放一些一次性信息，如错误提醒等，使用 request 这种销毁快的存放登陆后 el 表达式无法获得 session 中的 name 值，页面后台无报错解决：数据库查询名 跟 UserBean 的 name 不一致，导致查询后返回的 User username 属性值为空，无法再页面显示；并且 el 表达式获取某个值时，若为空，则显示为空，不会报错。—#### Servlet&amp;JSP##### ServletServlet: Service + let:运行在服务端的 java 小程序，sun 公司提供的一套接口规范（接口），用来处理客户端请求响应给浏览器动态资源，实质就是 java 代码，放在服务器端，别人可以通过 http 协议访问此代码，通过 java API 动态向客户端输出内容。servlet 规范三大组件：1. servlet 技术2. filter 技术 – 过滤器3. listener 技术 – 监听器实现步骤：1. 创建类实现 Servlet 接口2. 覆盖尚未实现的方法 – 主要是 service 方法3. 在 web.xml 配置 servletSerlvet 的 API(生命周期)1. Servlet 接口中的方法 init （ServletConfig config) 何时执行：servlet 对象创建时执行 ServletConfig ：代表该 Servlet 对象的配置信息 ServletConfig 可以获得 servlet 的 name 、servlet 的初始化参数、servletContext 对象2. service（ServletRequest request，ServletResponse response） 何时执行：每次请求都会执行 ServletRequest:代表请求，内部封装的是 http 请求信息 ServletResponse 代表响应，认为内部要封装的是响应的信息3. destory() 何时执行：servlet 销毁时执行Servlet 的生命周期（面试题）1. Servlet 何时创建 默认第一次访问 Servlet 时创建（Tomcat 等容器自动创建） 为什么说默认？ 可以在 中配置 1-5 数字表优先级，servlet 对象可以在服务器启动时创建2. Servlet 何时销毁 因为 Servlet 、request、response 等存在服务器内部（内存），服务器关闭 Servlet 就销毁了3. 每次访问必然执行的方法 service（ServletRequest req，ServletResponse resp） 方法问题：对 xxxServlet 进行了10次访问，init(),destory(),service(),doGet(),doPost() 一共执行几次？request 、response 对象创建几个url 配置错误会出现 404 异常，servlet-class 配置错误会出现 500 异常其中的为 servlet 类的配置 其中为 serlvet 虚拟路径配置 配置方式1. 完全匹配 访问资源与配置资源完全相同才能访问到 /xxx2. 目录匹配 /虚拟的目录../ 代表任意3. 扩展名匹配 *.xxxx 目录匹配与扩展名匹配不能混用缺省的 Servlet当服务器所有 servlet 与 访问的资源地址不匹配时，缺省的 servlet 负责处理web 应用中所有的资源响应都是 servlet 提供的，包括静态资源tomcat 下有一个默认的 缺省 Servlet，当访问静态资源时找不到动态资源，从而去你的 WEB-INF 目录下找静态资源 .html .jsp 等，然后用 wirte（）方法输出页面，如果在自己的 web.xml 配置了缺省 Servlet 则会覆盖 tomcat 的 缺省 Servlet 从而访问不到静态页面，404 异常欢迎页面：tomcat 配置默认 index.html index.htm index.jsp—##### ServletContext 对象ServletContext 对象代表一个 web 应用的环境（上下文）对象，ServletContext 对象内部封装的是 web 的应用信息一个 web 应用有几个 servlet / ServletContext 对象：多个 Servlet，一个 ServletContextServletContext 对象的生命周期？创建：该 web 应用被加载（服务器启动 或 服务器启动状态发布 web 引用）销毁：web 应用被卸载（服务器关闭，移除该 web 应用）怎么获得 Servlet 对象1. Servletconfig.getServletContext();2. this.getServletContext();ServletContext 的作用1. 获得 web 应用全局的 初始化参数 在 web.xml 中配置初始化参数后，用 context.getInitParameter(“name”) 获得 ​ name ​ com.xxx.xxx 2. 获得 web 应用中任何资源的绝对路径（重点） WEB-INF 下的文件不能通过网址直接访问，可以通过代码访问 String 绝对路径 = ServletContext.getRealPath(“相对路径”); //此相对路径相对 WEB-INF 获取 src（classes）下的资源绝对路径时应使用 tomcat 部署后的 相对路径 String path = ServletContext.getRealPath(“WEB-INF/classes/c.txt”); 此外在读取src（classes）下的资源时可以使用类加载器方法 String path = ContextServlet.class.getClassLoader().getResource(“c.txt”).getPath();//此相对路径相对于 部署在 tomcat 服务器后的 classes 路径idea 下 tomcat java 包 class 文件导出路径：${user.home}/.IntelliJIdea/system/tomcat 可以根据 idea 中配置 tomcat （Project Structure）Artifact 中路径一致，war 包专门用来传输服务器项目- war模式这种可以称之为是发布模式，看名字也知道，这是先打包war包，再发布；- war exploded模式是直接把文件夹，jsp页面，classes等等移到Tomcat部署文件夹里面，进行加载部署。因此这种方式支持热部署，一般在开发的时候也是用这种方式。参考：https://blog.csdn.net/qq_34328582/article/details/77932507参考：https://blog.csdn.net/weixin_36210698/article/details/725854293. ServletContext 是一个域对象（重点） 什么是域对象？什么是域？ 域就是区域 存储数据的区域就是域对象 ServletContext 域对象的作用范围：整个 web 应用（所有 web 资源都可以随意向 servletContext 域中存取数据，数据可共享） 域对象的通用方法： setAttribute(String name,Object obj); getAttribute(String name); removeAttribute(String name);—#### Linux 下的项目部署：##### idea 导出 war 包，将 war 包放到 linux 的 tomcat/web 目录下1. Shift+Ctrl+Alt+S —&gt; 选择 Artifacts —&gt;2. 选择中间栏的绿色 + 号，选择 WebApplication:Archive /empty（empty 生成的是 war 包，exploded 生成的是 文件夹类型的热部署模式）—&gt;3. 点击右边的绿色 + 号，选择 Directory Content —&gt;上方可 Name 栏修改 war 包名称，OutPut Directory 修改 war包输出路径 —&gt; 现已完成除 classes 文件夹的 war 包配置 —&gt;4. 选中 war 包，点击上方黄色带红星的文件夹图标 创建 WEB-INF 和其 子目录 classes —&gt;5. 选中 classes 目录，点击上方（右侧）绿色 + 号，选择 Module Output —&gt;6. 全部确定后 在 build 中点击 BuildArtifacts，会将 war 包导出到刚才配置的路径下&gt; 参考：&gt;&gt; war 和 war exploded（热部署模式）的区别&gt;&gt; 解决 war 包没有 classes 文件问题&gt;&gt; idea 导出 jar 包##### mysql 导出对应的 SQL 到 linux 的数据库中—#### httpServletResponse##### 通过 response 设置响应行：response.setStatus(int sc);##### 通过 response 设置响应头1. add(set)Header(String name,String value);2. add(set)IntHeader(String name,int value);3. add(set)DateHeader(String name,Date value);add 表示添加，set 表示设置（相同 name 的新 value 会覆盖旧的）##### Response 重定向重定向状态码：302重定向响应头：location重定向指客户端向 Servlet1 请求一个资源，Servlet1 没有这个资源，便告诉客户端去访问 Servlet2 ，然后 Servlet2 返回资源给客户端（客户端地址会发生变化，第一次访问 Servlet1 是客户端主动访问，重定向则是 tomcat 等服务器端自动跳转的）1. 设置状态码302：response.setStatus(302);2. 设置响应头 location：response.setHeader(“location”,”url”);以上 2 个方法可以封装成一个重定向方法 response.sendRedirect(“url”);##### 延时重定向方法：response.setHeader(“refleash”,”second;url”);response.setHeader(“名称”,”几秒后跳转;地址”)；##### 通过 response 设置响应体通过 response.getWriter().write(“xxx”); 将数据写入 response 的缓存区，然后 tomcat 的response 从缓存区获得数据，在引擎处将其拼接成 http 响应传给客户端##### response 解决乱码问题1. 在数据写入 response 缓存区前设置，让其通过 response 查询 utf-8 的码表（设置 response 查询码表） response.setCharacterEncoding(“utf-8”);2. 告知客户端用 utf-8 解码（通过一个头 Context-type 告知客户端使用何种码表） “text/html”告知客户端文本是 html 类型，charset=utf-8 编码是 uft-8 response.setHeader(“Content-Type”,”text/html;charset=utf-8”);以上方法可以封装为 response.setContentType(“text/html;charset=utf-8”);##### 文件下载文件下载就是服务器端到客户端的文件拷贝什么情况下文件会下载？浏览器不能解析的文件会下载什么情况下需要编写文件下载代码？理论上，浏览器可以解析的文件需要编写下载代码实际开发中，只要是下载的文件都编写文件下载代码response 获得的流不需要主动关，tomcat 容器会帮助我们关闭getWriter() 与 getOutPutStream() 不能同时调用,如果同时调用则会报 500 异常:getOutPutStream() / getWriter() has been called for this responsewindow.onload 的匿名函数内部的函数属于局部私有函数，外部无法访问，所以 onclick 点击事件的函数不能放在 window.onload 内部window.onload = function(){​ function(){}}—#### HttpServletRequest只有 form 表单提交，并且提交方式为 post 时才是 post 提交，请求体中有数据，其他方式都是 get 提交，请求体为空，数据在请求行##### 通过 request 获得请求行request.getMethod(); – 获得请求方法 – get、postrequest.getRequestURI(); – 一般指所有路径 – /项目名/应用名request.getRequestURL(); – 一般指 web 的路径 – http:localhost:8080/项目名/应用名 – 会带上网络协议,多个主机名和主机端口request.getContextPath(); – 指上下文路径（web 应用名称）request.getQueryString(); – 获得请求行后的数据字符串，如果为 post 提交则为 nullrequest 可以获得客户机（客户端） 的一些信息request.getRemoteAddr() – 获得访问客户端的 ip 地址##### 通过 request 获得请求头request.getHeader(“”);– 获得指定的头request.getHeader(“referer”);获得请求来源，如 http://localhost:8080/web/xxx.html再利用 startWith() 函数判断是否以自己的网站为开头，判断是否盗链##### 通过 request 获得请求体获得单个表单值String request.getParameter(“”);获得多个表单的值String [] request.getParameterValues();获得所有请求参数名称(没用)Enmueration getParameterNames();获得所有参数 封装到一个 Map&lt;String,String[]&gt;Map&lt;String,String[]&gt; getParameterMap();post、get 方式提交，以上方法通用##### request 其他功能request 是一个域对象请求重定向（response.sendRedirect(); 服务器外部行为，需要客户端二次请求访问不同 servlet，地址会变）请求转发服务器内部行为，只有一次请求，servlet1 没有资源自己找 servlet2 ,把请求（request）转发给servlet2要资源，servlet2 返回给 客户端，地址不会发生变化获得请求转发器， path 是转发地址RequestDispatcher getRequestDispatcher(String path)请求转发是在一次请求中，总计访问服务器一次，所以地址还会带有 web 根目录，不需要再添加 request.getContextPath()，来补全地址，重定向则需要通过转发器对象转发requestDispatcher.forward(ServletRequest,ServletResponse)–转发的数据在不同 servlet 就取不到域中的值了请求转发是服务器内部行为，整个请求在 web 工程内部，可以直接写 /servlet2 相对路径，不用加工程名（服务器端地址，服务器内部的叫服务器端地址，不用写 web 应用名称）请求转发等客户端去访问的叫客户端地址，服务器外部的地址，需要加上 web 应用名称：重定向、直接输入地址等request 的域范围在一次请求中，每次访问（请求）都会创建一个新的 request 跟 responsedispatcher.forward(request,response);转发 request 不论多少次都算一个请求（虽然都是不同对象，但是 request 内部的值是相同的）转发性能优于重定向，重定向可以访问外部网站，转发只能访问内部的资源request 在访问时创建，响应结束销毁，作用域一次请求存在域中的数据都是 Object 类型的，getAttribute 获得的数据也是 Object，但若知道原来存进去的数据类型，取出来后可以进行强转setAttribute(“string”,”object”);Object getAttribute(“string”);##### 解决 request 乱码问题获得页面数据乱码过程：张三 —&gt; 页面进行 utf-8 编码 —&gt; request 获取数据进行 ios8859-1 解码（默认解码方式）—&gt; 乱码解决乱码过程：乱码 —&gt; 使用 ios8859 编码 —&gt; 使用 utf-8 解码 —&gt; 张三编码方式：str.getByte(“ios8859-1”);解码方式：new String(bytes,”utf-8”);将编码和解码方式合并：new String(str.getByte(“iso8859-1”),”utf-8”);以上方式可以解决 get 和 post 方式提交表单，但是需要对一个对象中每个字段进行编解码，如果在 Map 中的数据还需要在 for 循环中编解码。但是 post 提交可以用更简便的 request.setCharacterEncoding(“utf-8”); 使用这种方式，只需要写一条，所有的字段都可以解决乱码request.getParameter();filter 配置 request 解决乱码问题参考：https://www.cnblogs.com/yyhl/p/9212301.htmltomcat 8.5 等服务器 使用了过滤器配置 parameter = new String(parameter.getBytes(“iso8859-1”),”UTF-8”);会乱码，因为 parmeter 获取到时已是中文，二次编解码会乱码重定向是客户端重新访问一个 servlet ，属于客户端地址，所以重定向地址不应该固定,用 request 获得上下文路径（web 项目的路径）response.sendRedirect(request.getContextPath”/web/xxx.jsp”);##### BeanUtils 的方法Map&lt;String,String[]&gt; properties = request.getParameterMap();User user = new User();BeanUtils.populate(user,properties);工作原理：将 map 中的数据根据 key 与实体的属性对应关系封装只要 key 中的属性与实体的属性名字相同，就自动封装到实体—##### JSP JAVA Server Page：是在 html 页面写入 java 代码，本质是一个 servlet ，作为简化的 servlet 而发明，擅长写页面，不擅长写 java 代码在 java 代码中写入 html 页面，擅长写 java 代码，但是写页面比较繁琐，从而诞生了 JSP##### JSP 运行原理jsp 在第一次访问时（或被修改后）会被 web 容器（tomcat）翻译成 servlet （helloServlet.jsp–&gt;helloServlet_jsp.java）然后编译运行被翻译后的文件在 tomcat 目录的 work 文件夹下—##### JSP 的 page 指令12&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt; language=&quot;java&quot;设置 JSP 插入语言，可以不写contentType=&quot;text/html; charset=UTF-8&quot;JSP 页面上的 contentType 在编译为 servlet 后会变成 response.setContentType(“text/html”;charset=”UTF-8”);跟 servlet 中解决网页乱码问题的方法一致，可以用来设置 response 中缓冲区的编码，并知道页面解析时的编码可以被包含在 pageEncoding 内pageEncoding=&quot;UTF-8&quot;JSP 文件本身的编码格式isErrorPage/errorPage:用来处理服务器端错误 （500错误），无法处理 400 找不到页面错误404 错误用使用 web.xml 下配置应用的全局错误页面1234&lt;error-page&gt; &lt;error-code&gt;404&lt;/error-code&gt; &lt;location&gt;/error.jsp&lt;/location&gt;&lt;/error-page&gt;JSP 的 include 指令&lt;%@ include file=&quot;header.jsp&quot;%&gt;可以引入其他的 JSP 页面开发时可以先写页面头跟尾，在重复引用即可JSP 的 taglib 指令&lt;%@ taglib uri=&quot;&quot; prefix=&quot;c&quot;%&gt;&lt;c:if&gt; &lt;c:if&gt;prefix:用来标记一个标签库，使用该标签库时就使用该标记一般用来引入 jstl 标签库/struts2 标签库—##### JSP 九大隐式对象4大域：page 域 ：pageContext：当前 JSP 页面范围可见（A页面转发到B页面也无法取到）request 域 ：一次请求（不包括返回）session 域 ：一次会话application 域 ：servletContext 的域 （整个 web 应用）out：输出类型 JspWriterout 作用：向客户端输出内容，out.write();直接在 html 页面写数据、使用 &lt;%out.write()%&gt;以及&lt;%=&quot;xxx&quot;&gt;都会在servlet 转换成 out.write(“”);并将数据放在 out 的缓冲区，out 缓冲区默认大小 8k 可以在&lt;%@ page buffer=&quot;0kb&quot;%&gt;设置关闭 out 缓冲区，从而使用 response使用&lt;%response.getWriter.write()%&gt;则把数据放在 response 缓冲区，tomcat 默认从 response 获取数据，所以加载 response 数据会快一些，之后会将 out 缓冲区数据放到 response 缓冲区pageContext：可以向不同域设置内容1234567&lt;%request.setAttribute("name","zhangsan");pageContext.setAttribute("name","sunba");pageContext.setAttribute("name","lisi",pageContext.REQUEST_SCOPE);pageContext.setAttribute("name","wangwu",pageContext.SESSION_SCOPE);pageContext.setAttribute("name","tianqi",pageContext.APPLICATION_SCOPE);%&gt;1234 &lt;%--findAttribute 从小到大搜索域范围中的 name 范围从小到大 page域(pageContext 对象)--&gt;request域--&gt;session域--&gt;application域(servletContext)--%&gt;&lt;%=pageContext.findAttribute("name")%&gt;—##### JSP 标签（动作）include1.jsp 与 include2.jsp静态包含&lt;%@include file=&quot;&quot;%&gt;将 include2 的页面拷贝到 include1.jsp，再翻译成 include1_jsp.java静态包含最终有一个文件动态包含&lt;jsp:include page=&quot;&quot;将 include1.jsp 翻译成 include1_jsp.java 编译运行后 发现其中的 include(request,response,”include2.jsp”,out,false); 再回去找 include2.jsp将 include2.jsp 翻译成 include2_jsp.java 再编译运行动态包含有两个文件&lt;jsp:forward page=&quot;/forward2.jsp&quot;&gt;&lt;jsp:forward&gt;请求转发，跟 request.getRequestDispatcher(“/forward2.jsp”).forward(request,response); 一致将请求从 forward1.jsp 转发到 forward2.jsp 网址还是 forward1.jsp内容显示 forward2.jsp—#### el 表达式防止 jsp 中嵌入过多 java 代码，从而使用 el 表达式从域中取数据，逻辑判断用 JSTL 从而代替 java 代码el 从域中取出数据（最重要的 el 功能）全域查找：各个域查找：${requestScope.key };${sessionScope.key };${applicationScope.key };全域查找：${key};底层是 application.findAttribute(); 方法，依次从 pageContext 域，request 域，session 域，application 域中获取属性，在某个域中获取到了则不再往后找el 表达式没有内置 八大对象，需要用 pageContext 获取pageContext 功能跟 jsp 类似，能获取八大对象${pageContext.request }${pageContext.request.contextPath }等于 request.getContextPath(); 常用于重定向 response.sendRedirect(request.getContextPath()+”/product/xxx.jsp”);用来获取 web 应用名称，通常用于拼接重定向目录 防止 web 应用名称修改后项目无法使用 如：&lt; form action=”${pageContext.request.contextPath }/xxx/xxx.jsp” method=”post”&gt;拼接的是访问地址 http://localhost:8080/admin/home.jsp 8080 后，/admin 前的这一段地址，在 ieda 修改这段地址的方法是在 tomcat 设置中 Deployment 栏 Application context 栏修改客户端地址（一般 src 中获取外部链接，插入外来页、导入 css 包、获取图片等都是客户端地址）需要加上 web 应用名称，这样就是绝对地址—#### JSTL 技术1&lt;%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c"%&gt;&lt;c:if test=&quot;${1=1} &quot;&gt;&lt;c:if&gt;当 test 中返回为 true 才会进入体内模拟普通 for 循环for(i=0;i&lt;5;i++){}&lt;c:forEach begin=&quot;0&quot; end=&quot;5&quot; var=&quot;i&quot;&gt;&lt;c:forEach&gt;从 0 开始到 5 ，把每次循环的值赋给 i模拟增强 for 循环for(Product product : productList){}往 items 中放集合需要借助 el 表达式&lt;c:forEach items=&quot;${productList }&quot; var=&quot;product&quot;&gt;${product.pname}&lt;c:forEach&gt;循环取出 productList 集合中每项的 product 的 pname 属性var 中的每一个数据都是临时存放在在 page 域中，循环过程中被下一个数据所覆盖el 表达式中可以有空格，但表达式与冒号间不能有空格 “${productList} “(错误)forEach 中的 varStatuscount 是从 1 开始循环计数的index 从 0 开始如果 items 中没有加 ${} 直接取值会报Caused by: javax.el.PropertyNotFoundException: Property [oid] not found on type [java.lang.String]异常123&lt;c:forEach items=&quot;$&#123;orderList &#125;&quot; var=&quot;order&quot; varStatus=&quot;vs&quot;&gt;$&#123;vs.count&#125;$&#123;vs.index&#125;—-#### javaee 开发模式1.模式是开发过程中总结出的“套路”，约定俗成的设计模式2.javaEE 的模式1. model1：jsp+javaBean：随着业务繁琐，导致 jsp 页面混乱2. model2：jsp+servlet+javaBean：开发中使用各个技术擅长的方面 mvc：– web开发模式 M：model-模型：javaBean：封装数据 V： view-视图：Jsp：单纯页面显示 C：Controller-控制器：Servlet：获取数据-对数据封装-传递数据数据-指派显示页面##### javaEE 的三层架构：–javaEE独有web层：与客户端交互：收集页面数据、封装数据、传递数据、指定响应 jsp 页面service层：复杂业务处理：逻辑业务代码编写dao层：与数据库交互：数据库访问代码开发时体现在包结构—##### web 层的作用1. 接受客户端表单数据2. 封装散装数据成实体 bean，发送数据到 service 层 vo：value object 用来专门传递值，可以专门把 实体 bean 中不存在的判断条件封装一个新的 vo 对象 例如condition 条件对象3. 接受 service 层返回的数据，并指定跳转页面##### service 层作用1. 接受 web 层传来的 bean 对象，并将其传给 dao 层2. 接受 dao 层返回的查询数据，将其返回给 web 层##### dao 层作用1. 接受 service bean 对象，查询数据库数据2. 将查询到的数据返回给 service 层—#### 事务一件事情有 n 个组成单元，要不这 n 个组成单元同时成功，要不就同时失败，就是将 n 个组成单元放到一个事务中##### Mysql 事务mysql 有默认的事务：一条 sql 语句就是一个事务，默认开启事务并提交事务手动 mysql 事务：1. 显示开启一个事务： start transaction ：开启事务后所有 sql 语句不修改数据库，但保存在一个日志中，可查询2. 事务提交：commit 表示开启事务到事务提交内所有 sql 语句有效，并更新数据库3. 事务的回滚：rollback 表示事务回滚，总事务开启到事务回滚，中间所有 sql 操作无效，不更新数据库##### JDBC 事务默认自动事务，执行 SQL 语句：executeUpdate（），每执行一次 executeUpdate 代表事务自动提交jdbc 开启手动事务：1. 开启事务：conn.setAutoCommit(false);2. 提交事务：conn.commit();3. 回滚事务：conn.rollback();控制事务的 connection 必须是同一个，执行 sql 的 connection 与控制事务的 connection 必须是同一个，才能控制事务##### DBUtil 事务操作DBUtil 事务控制也是通过 JDBC （进行了封装）QueryRunner runner = new QueryRunner(DataSource datasource); DateSource 会自动寻找 xml 中的数据库连接配置，从连接池中随机获取一个 Connection，随机的 conn 无法控制事务有参构造将数据源（连接池）作为参数传入 QueryRunner，QueryRunner 会从连接池中获得一个数据库连接资源操作数据库，直接使用无 Connection 参数的方法即可操作数据库如果要进行事务控制则使用无参 QueryRunner 构造,从而自己再方法体中获取一个 conn，利用确定的 conn 进行事务控制12345678910QueryRunner runner = new QueryRunner(）&#123; //用 JDBC 的方式获得一个 conn Connection conn = DataSource.getConnection(); //用 conn 开启事务 conn.setAutoCommit(false); runner.update(conn,sql); //提交事务或回滚 conn.commit();&#125;如果用 SQLException 无法 catch 到 1/0 异常，网页会产生如下异常，而且事务也无法控制住会丢失金额 错误信息： Type Exception Report（点击详细信息） Type Exception ReportMessage / by zero Description The server encountered an unexpected condition that prevented it from fulfilling the request.Exception java.lang.ArithmeticException: / by zero com.itheima.service.TransferService.transferMoney(TransferService.java:21) com.itheima.web.TransferServlet.doGet(TransferServlet.java:24) com.itheima.web.TransferServlet.doPost(TransferServlet.java:12) javax.servlet.http.HttpServlet.service(HttpServlet.java:661) javax.servlet.http.HttpServlet.service(HttpServlet.java:742) org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52) Note The full stack trace of the root cause is available in the server logs. 代码案例：DBUtilsDemo 公司接口：根据客户给出的参数从数据库查询出相关信息返回一个集合 ThreadLocal ：javaEE三层架构间都是一个线程执行方法，ThreadLocal 底层是一个 Map，key 都为 Thread-1，只存储 value，应用：通过线程绑定方式传递参数（Connection） 事务的特性 面试题 （概念问题）缩写（ACID） 原子性（Atomicity)原子性指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生 一致性（Consistency）一个事务中，事务前后的完整性必须保持一致 隔离性（Isolation）多个事务间的关系，隔离性指多用户并发访问数据库时，一个用户的事务不能被其他用户的事务所干扰，多个并发事务之间数据要相互隔离（多个用户访问时每个用户都会有一个独立的ThreadLocal，那么每个 ThreadLocal 中存放的 Connection 也是不同的，可以保证每个 conn 控制一个事务） 持久性（Durability）持久性指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即时数据库发生故障也不会对其有任何影响 事务并发访问问题（由事务的隔离性引起） 脏读：B 事务读取到了 A 事务尚未提交的数据 – 需要 B 事务读取 A 事务已提交的数据 例：A 向 B 转账，B 读到了 A 未提交的转账记录，然后 A 将事务回滚，钱仍在 A 处 不可重复读：一个事务中 两次读取的事务不一致 – 需求一个事务中多次读取时数据是一致的 –update 例：在你开启事务后，你读取了自己银行卡的金额，发现有 5000 余额，此时你老婆刷走了 5000 块，你在这个事务中读取金额仍然还是显示 5000 余额，只有你关闭了这个事务，再次开启一个事务查询时才知道你已经是个穷鬼了 幻读/虚读：一个事务中 两次读取数据的数量不一致 – 要求在一个事务多次读取数据的数量是一致的 – insert delete 例：与不可重复读类似，在一次事务中，你读取自己银行卡的交易记录，一共有 4 条，此时你老婆刷了 5000 那一笔钱，你在这个事务中再次查询也无法看到这次消费，需要再开一个事务才能查询到 事务的隔离级别 read uncommited：读取尚未提交的数据–无法解决任何问题 read commited：读取已提交的数据–可以解决脏读 – oracle 默认 repeatable read：重复读取–可以解决脏读和不可重复读–mysql 默认 serializable：串行化–可以解决 脏读 不可重复读 和 虚读–相当于锁表，性能过低不使用 注解@override 帮助开发人员检查覆盖父类方法是否正确–给编译器用 @SuppressWarning(“rawtype”) List list = new ArrayList(); 压制警告（忽略类型安全），压制警告括号内可以为数组，表示压制多个警告，也可以为 “all” 压制所有警告 @Deprecated 标注过时方法 元注解修饰注解的注解，在注解类上使用，用来限制定义的注解的特性 @Target({TYPE,METHOD…,PARAMETER}) 表示该注解可以用于哪些东西上 TYPE:可以用于类/接口上 METHOD：可以用于方法上 FIELD：字段上能用 java 代码运行过程： demo.java(源码级别) —&gt; 经过编译器 —&gt; demo.class(字节码级别) —&gt; 经过类加载器 —&gt;Class(字节码对象，运行时级别) @Retention(RetentionPolity.RUNTIME) 运行可见级别 SOURCE：源码级别可见 CLASS：字节码文件级别 RUNTIME：运行时级别 Junit4 idea 测试设置 动态代理1234567//反射获得方法Method method = clazz.getMethod(method,req,resp)xxx方法method.invoke()xxx方法 在方法执行前后进行一些操作，就是面向切面编程 获得动态代理对象(点击详细) //获得动态的代理对象—-在运行时 在内存中动态的为Target创建一个虚拟的代理对象 //objProxy是代理对象 根据参数确定到底是谁的代理对象TargetInterface objProxy = (TargetInterface) Proxy.newProxyInstance( Target.class.getClassLoader(), //与目标对象相同的类加载器 new Class[]{TargetInterface.class}, newInvocationHandler() { //invoke 代表的是执行代理对象的方法 @Override //method：代表目标对象的方法字节码对象 //args:代表目标对象的响应的方法的参数 public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { System.out.println(“目标方法前的逻辑”); //执行目标对象的方法 Object invoke = method.invoke(new Target(), args); System.out.println(“目标方法后的逻辑”); return invoke; } }); Q&amp;AQ: servlet 的转发页面空白无显示1request.getRequestDispatcher("admin/product/list.jsp").forward(request,response); A: 如把代码写在 doGet 中需要在 doPost 中进行 doGet 覆盖，或把代码写在 doPost 中，在 doGet 进行 doPost 覆盖 Q:在 servlet 设置断点无法进断点，后台、网页无报错A:如果无法进入断点说明问题在于 页面， 参数无法传递到后台 可能的错误有：json 参数传递语句错误、JQuery 的 ajax 语句 $.post(); 写成 $post.{}; 等 Q:java.lang.NoSuchMethodExceptionA: 如果在整合 servlet 时没有将内部方法的 protect 变成 public 则会出现此问题 Q:java.io.FileNotFoundException: .\xx\xx (拒绝访问。)A: 一般这种情况是访问的是一个文件目录而不是文件 参考：https://blog.csdn.net/w405722907/article/details/78610485 Q:Data truncation: Incorrect datetime value: ‘’A: 存入的 Date 与数据库 Date 格式不符，setDate() 前先进行 Date 格式化： 12345678910SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;); //SimpleDateFormat中的format方法可以 //把Date型的字符串转换成特定格式的String类型 String format = simpleDateFormat.format(new Date()); //SimpleDateFormat中的parse方法可以 //把String型的字符串转换成特定格式的date类型 Date parse = simpleDateFormat.parse(format); //将转换格式的 Date 存入 product product.setPdate(parse); Q:表单中 循环显示,只显示最后一组 tr 的内容，且标题 tr 项不显示 A: 标题 tr 项写错内容，与数据的 项不一致 Tips:一般没有 request 域数据传递使用 重定向 response.sendRedirect(request.getContextPath());（后台地址获取直接 request.getContextPath()） 有 request 域传递数据的使用 请求转发request.getRequestDispatcher(“admin/product/list.jsp”).forward(request,response+“/admin/product/list.jsp”); 如果在注解中配置了 urlPatterns 地址跟 重定向 response.sendRedrest(path); 的地址相同，则会出现死循环，网页提示重定向次数过多，如果提交了表单， 数据库会出现多个空白数据，需要进行空表单验证 12345//获取表单数据Map&lt;String, String[]&gt; properties = request.getParameterMap();//封装数据Product product = new Product（）；BeanUtils.populate(product,properties); 此方法会将表单提交的属性根据 name 值 与 Bean 的属性名 对应起来，然后将表单提交的属性封装成一个 Bean a 标签有自己内置的点击事件，如果 a 标签有 href 属性，在点击后会自动跳转到页面头 阻止事件传播： # 代表本页面 &lt;a href=&quot;#&quot; onclick=&quot;delProduct()&quot;&gt;&lt;a/&gt; 将 href 中内容改为 javascript:void(0); &lt;a href=&quot;javascript:void(0);&quot; onclick=&quot;delProduct()&quot;&gt;&lt;a/&gt; 可以防止点击 a 标签后默认样式的 href 无任何行为 123456789&lt;select name="cid"&gt; &lt;c:forEach items="$&#123;categoryList &#125;" var="category"&gt; &lt;option value="$&#123;category.cid &#125;"&gt; $&#123;category.cname &#125; &lt;/option&gt; &lt;/c:forEach&gt;&lt;/select&gt; items 的值与 servlet 中 setAttribute 的值名相同，var 为循环 items 的值后单个的值 不让用户看到，但是后台需要某个属性时，使用隐藏域传递数据 &lt;input type=&quot;hidden&quot; name=&quot;pid&quot; value=&quot;${product.pid}&quot;/&gt; 传递 pid 的值到 servlet Map&lt;String,String[] properties = request.getParameterMap(); 将前台的属性全部获取，以便之后进行对象的封装 1enctype=&quot;multipart/form-data 如果在 form 中有如上代码，页面能跳转，但是修改不回生效 当 form 使用 enctype=”multipart/form-data” 多表单提交时，getParameter 将无法获取到值，根据 getMethod（） 取值的 BaseServlet 方式抽取 Servlet 会获取不到 method， 需要重新创建继承 HttpServlet 的文件上传 从数据库查询多表或单表的数据时，可以直接封装 map 而不是对象，以 json 字符串返回前台]]></content>
      <tags>
        <tag>java</tag>
        <tag>web</tag>
        <tag>servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SomeProblem]]></title>
    <url>%2F2018%2F12%2F11%2FSomeProblems%2F</url>
    <content type="text"><![CDATA[serlvet 提交 post 乱码解决方法： request.setCharacterEncoding(“UTF-8”); 或者使用先编后解码方式解决 Jquery post 提交已经自动进行过编解码，不需要再写，如果二次编解码反而会乱码 get 提交乱码： 先编码再解码 JQuery get 中文提交乱码： 先编码后解码]]></content>
      <tags>
        <tag>java</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springMVC32]]></title>
    <url>%2F2018%2F10%2F30%2FspringMVC32%2F</url>
    <content type="text"><![CDATA[大致流程流程参考：IDEA整合SSM框架：Spring+SpringMVC+Mybatis 入门 Springmvc 流程 Web 工程 导入 jar 包 web.xml 中配置前端控制器（指定上下文路径 classpath：springmvc.xml） 拦截规则 拦截所有（包括 Jsp）：/* 拦截除了 JSP 以外部分 : / .action 或 .do springmvc.xml 配置扫描 @controller 注解 Action Controller Handler 处理器 需要写的部分：类上@Controller 方法上 @RequestMapping（Value=请求的路径）.action 可以省略 Public ModelAndView itemList(){ ​ new ModelAndView ​ 设置数据 ​ 设置 JSP 页面路径（跳转路径 /WEB-INF/jsp/xxx.jsp） } 架构分析一个中心 三个基本点 前端控制器（在 web.xml 中配置） 处理器映射器 处理器适配器 视图解释器 由 Springmvc 提供 Handler 处理器 JSP 视图（页面，即 html 标签） 由程序员书写 默认三大组件默认三大组件已废弃 现组件：RequestMappingHandlerMapping (处理器映射器) RequestMappingHandlerAdapter (处理器适配器) 可用 &lt;mvc:anonation-driver/&gt; 代替 处理器映射器 和 处理器适配器的配置 视图解释器 用来优化 JSP 页面的路径书写 /WEB-INF/jsp/xxx.jsp 可以拼接 xxx 的前后缀 整合 mybatis SqlMapConfig.xml 核心配置文件（别名） applicationContent.xml 数据源 druid （替代 JDBC）读取 db.properties Mybatis 的工厂以及 Mybaits Mapper 动态代理开发的扫描方式 扫描基本包 创建 db.properties 文件 事务、扫描@Service Spring+Mybatis 创建 Springmvc.xml 三大组件 扫描基本包（com.itheima 包下 controller 与 Service 全扫描） web.xml 文件中配置监听器读取 applicationContext.xml 上下文 配置前端控制器读取 Spingmvc.xml 配置 POST 提交乱码 Fittler 过滤器 参数绑定 默认参数绑定 Request Response Session Model 实现关系 ModelMap 简单类型参数绑定 方法的形参上（Integer id String Double double Boolean） POJO 类型 Items items input name = name name 与 items 对象中属性名一致 包装类型 QueryVo （内含 Items） Query Vo items.name （传参方式） 自定义参数格式 转换日期：在 Springmvc.xml 配置转换器的工厂 Converters list set array 创建自定义转换器类 实现 Converter&lt;S,T&gt; Strus2 与 Springmvc 区别 入口 Servlet 与 Fittler 单例 多例 值 Request域 controller 返回值 ModelAndView 万能的 带数据 返回视图路径后结束 String 只能返回视图路径 需要通过方法传参数 Model model，通过 model 带数据 request.setAttribute(),model.addAttribute(“itemsList”,list); 官方推荐 符合解耦合 数据 视图 分离 MVC void ajax 请求 适合返回 json 格式数据（response 异步请求使用，不用刷页面） 重定向与内部转发区别重定向的页面在提交后会跳转到 重定向的路径（网址） 内部转发的页面在提交后不会跳转 会在修改页面的路径（网址） SpringMVC 三大组件 处理器映射器（HandlerMapping）、视图解析器(ViewResolver) 、处理器适配器(HandlerAdapter) 三大组件的默认配置文件 /springmvc32/web/WEB-INF/lib/spring-webmvc-4.1.3.RELEASE.jar!/org/springframework/web/servlet/DispatcherServlet.properties 在 springmvc 的配置文件中修改默认配置 springmvc.xml 123456789101112131415161718&lt;!--扫描 @Controller @Service --&gt; &lt;context:component-scan base-package="com.itheima"&gt;&lt;/context:component-scan&gt; &lt;!-- 处理器映射器 --&gt; &lt;!--&lt;bean class="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping"/&gt;--&gt; &lt;!-- 处理器适配器 --&gt; &lt;!--&lt;bean class="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter"/&gt;--&gt; &lt;!-- 注解驱动:可以替代以上两个配置 --&gt; &lt;mvc:annotation-driven/&gt; &lt;!-- 视图解析器 --&gt; &lt;!-- 跟 ItemController 的 setViewName 中的内容拼接成完整地址 --&gt; &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix" value="/WEB-INF/jsp/"/&gt; &lt;property name="suffix" value=".jsp"/&gt; &lt;/bean&gt; ItemServiceImpl 中实现接口，并覆写实现方法 将方法放到接口 ItemService controller 控制层中 @RequestMapping(value=”/网页中的 form 中 action 相对地址”) jsp 中 input 的 name 属性中的内容与接受的 Items（bean）的 name 属性一致 jsp 页面上的 name 属性名的参数绑定与 Controller 中传入的 POJO 形参名无关，而是属性名与 POJO 对象中的成员变量名一致 ​ 但是如果将 POJO 进行了包装，将 Items 类封装到 Vo 类中，Vo 类中有着获取、修改 Items 类的方法，则在 jsp 页面的 name 属性名的参数绑定将变为 Items.（Items 类中的成员变量名） 例如：Items.name Q&amp;AQ1: idea 编译出现 “文档中根元素后面的标记必须格式正确” 字样错误提示A: 这个错误一般是元素未正确结束，或者出现未知元素造成的 . 提示这行不代表就是这行，提示是告诉你这个元素有问题，这个元素下面的任何子元素都可能存在问题 错误点：未将 等代码放入 栏 Q2: 运行后网页提示错误：​ org.xml.sax.SAXParseException; lineNumber: 10; columnNumber: 9; cvc-complex-type.2.3: 元素 ‘beans’ 必须不含字符 [子级], 因为该类型的内容类型为“仅元素”。 A: 在 标签中多了一个 、 Q3: debug 报错：​ org.apache.jasper.servlet.TldScanner.scanJars At least one JAR was scanned for TLDs yet contained no TLDs. Enable debug logging for this logger for a complete list of JARs that were scanned but no TLDs were found in them. Skipping unneeded JARs during scanning can improve startup time and JSP compilation time. A: 在apache-tomcat-8.5.29\conf目录下找到logging.properties文件，对文件进行编辑，在最后一行加入： 1234567891011121314151617181920212223242526272829303132333435这样就不再显示错误信息了。http://blog.51cto.com/lavasoft/2087440##### Q4: Tomcat 8报错 SEVERE: One or more listener failed to start​ 06-Nov-2018 17:26:46.429 信息 [RMI TCP Connection(3)-127.0.0.1] org.apache.jasper.servlet.TldScanner.scanJars At least one JAR was scanned for TLDs yet contained no TLDs. Enable debug logging for this logger for a complete list of JARs that were scanned but no TLDs were found in them. Skipping unneeded JARs during scanning can improve startup time and JSP compilation time.​ 06-Nov-2018 17:26:46.465 严重 [RMI TCP Connection(3)-127.0.0.1] org.apache.catalina.core.StandardContext.startInternal One or more listeners failed to start. Full details will be found in the appropriate container log file​ 06-Nov-2018 17:26:46.468 严重 [RMI TCP Connection(3)-127.0.0.1] org.apache.catalina.core.StandardContext.startInternal Context [] startup failed due to previous errorsA: &gt; Full details will be found in the appropriate container log file 意思是让我们在日志文件中查看详细报错信息，那日志文件在哪里呢？这里如果我们是使用idea调试，则日志文件存放在C:\Users\Administrator\.IntelliJIdea2017.1\system\tomcat\Unnamed_SpringMVCDemo\logs 详细问题在 logs 文件夹的几个日志文件中参考：https://blog.csdn.net/dkbnull/article/details/81605157 &gt; If you are using IntelliJ IDEA, and deploy application on Tomcat Server, it says: Under File menu -&gt; select project Structure -&gt; click artifact -&gt; select your jars and right click -&gt; put in WEB\lib -&gt; restart server参考：https://stackoverflow.com/questions/6210757/java-lang-classnotfoundexception-org-springframework-web-context-contextloaderl##### Q5: 启动服务后网页报错```javaorg.springframework.beans.factory.BeanCreationException: Error creating bean with name &apos;itemController&apos;: Injection of autowired dependencies failed; nested exception is org.springframework.beans.factory.BeanCreationException: Could not autowire field: private com.itheima.springmvc.service.ItemService com.itheima.springmvc.controller.ItemController.itemService; nested exception is org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of type [com.itheima.springmvc.service.ItemService] found for dependency: expected at least 1 bean which qualifies as autowire candidate for this dependency. Dependency annotations: &#123;@org.springframework.beans.factory.annotation.Autowired(required=true)&#125; A: spring在管理创建bean的时候发生了错误，一是检查注解是否正确@Service;二是看看web.xml中配置的 spring容器的 xml 文件是否错误 未添加 ItemServiceImpl 的 @Service 注释 参考：https://blog.csdn.net/zxz9325/article/details/79179444 Q6: HTTP Status 500 – Internal Server Error Type Exception Report Message Request processing failed; nested exception is java.lang.NumberFormatException: null Description The server encountered an unexpected condition that prevented it from fulfilling the request. Exception 1org.springframework.web.util.NestedServletException: Request processing failed; nested exception is java.lang.NumberFormatException: null A: 应该打开查询网页 http://localhost:8080/itemEdit.action 而非直接打开 http://localhost:8080/item/itemEdit.action，无法直接访问，而且没有传 id 导致为空 Q7: 运行后显示 404Type Status Report Description The origin server did not find a current representation for the target resource or is not willing to disclose that one exists. A: http://blog.csdn.net/DBC_121/article/details/79204340 @requestMapping(value=””) 中 value 地址书写错误 Q8:HTTP Status 400 – Bad RequestType Status Report Description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). A: jsp 页面上的 name 属性名的参数绑定与 Controller 中传入的 POJO 形参名无关，而是属性名与 POJO 对象中的成员变量名一致,如果不一致则在后台获取不到参数 Q9:jsp 页面 name 属性名应与 POJO 内部成员变量一致HTTP Status 500 – Internal Server Error Type Exception Report Message Request processing failed; nested exception is java.lang.NullPointerException Description The server encountered an unexpected condition that prevented it from fulfilling the request. A: 将 POJO 进行包装后没有在 jsp 页面进行 name 属性修改 如果将 POJO 进行了包装，将 Items 类封装到 Vo 类中，Vo 类中有着获取、修改 Items 类的方法，则在 jsp 页面的 name 属性名的参数绑定将变为 Items.（Items 类中的成员变量名） 例如：Items.name Q10:自定义异常错误HTTP Status 500 – Internal Server Error Type Exception Report Message Request processing failed; nested exception is java.lang.ClassCastException: java.lang.ArithmeticException cannot be cast to com.itheima.springmvc.exception.MessageException Description The server encountered an unexpected condition that prevented it from fulfilling the request. Exception 12345678910org.springframework.web.util.NestedServletException: Request processing failed; nested exception is java.lang.ClassCastException: java.lang.ArithmeticException cannot be cast to com.itheima.springmvc.exception.MessageException org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:978) org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:857) javax.servlet.http.HttpServlet.service(HttpServlet.java:635) org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:842) javax.servlet.http.HttpServlet.service(HttpServlet.java:742) org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52) org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:88) org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) org.apache.logging.log4j.core.web.Log4jServletFilter.doFilter(Log4jServletFilter.java:66) Root Cause 123456789101112131415java.lang.ClassCastException: java.lang.ArithmeticException cannot be cast to com.itheima.springmvc.exception.MessageException com.itheima.springmvc.exception.CustomExceptionResolver.resolveException(CustomExceptionResolver.java:19) org.springframework.web.servlet.DispatcherServlet.processHandlerException(DispatcherServlet.java:1167) org.springframework.web.servlet.DispatcherServlet.processDispatchResult(DispatcherServlet.java:1004) org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:955) org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:877) org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:966) org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:857) javax.servlet.http.HttpServlet.service(HttpServlet.java:635) org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:842) javax.servlet.http.HttpServlet.service(HttpServlet.java:742) org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52) org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:88) org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) org.apache.logging.log4j.core.web.Log4jServletFilter.doFilter(Log4jServletFilter.java:66) Note The full stack trace of the root cause is available in the server logs. A： 12345678910ModelAndView mav = new ModelAndView();if(e instanceof MessageException)&#123; MessageException me = (MessageException)e; mav.addObject("error",me.getMsg());&#125;else &#123; mav.addObject("error", "未知异常");&#125;mav.setViewName("error");return mav; Tips：intelj idea 添加本地 xsd 文件​ intellij idea配置外部dtd文件 ​ 打开file——Settings..(快捷键ctrl+alt+s); ​ 找到Languages&amp;Frameworks——Schemas and DTDs ​ 找到右侧的External Schemas and DTDs窗口中点击添加按钮 ​ 在 Explorer 栏找到下载好的外部 dtd 文件 ​ 在 URI 栏可以填入从 xml 文件头上找到的相对应约束 URI ​ intelj idea jar 包 导入​ 导入 jar 包 3种方法 intelj idea 中的 mybatis 逆向工程​ Mybatis在IDEA中使用generator逆向工程生成pojo,mapper ​ 12345// servlet 开发// String id = request.getParameter("id");// Items items = itemService.selectItemsById(Integer.parseInt(id));// Spring 底层还是使用 request 的 getParameter 方法获取 id 的值的，但是我们不需要自己去写，并且会自动帮我们转换 Int 类型 Items items = itemService.selectItemsById(id); Springmvc 与 Strus2 的区别参数绑定区别​ Strus2 绑定参数在类的属性（ Action 的成员变量上） ​ Springmvc 从客户端请求 key/value 数据，通过参数绑定，将其绑定在 controller 方法的形参上 ​ SpringMVC中的参数绑定总结 存储数据区别​ Springmvc 使用 ModelAndView.addObject(“”,””); ​ 底层是 request.setAttribute(“”,””); 存在 request 的域中，没有值栈概念 ​ Strus2 有值栈概念 入口区别​ Springmvc 入口是 servlet 前端控制器 ​ Strus2 是过滤器 filter 模式区别​ Springmvc 是单例模式（以方法为单位，每次请求复制一个方法副本） ​ Strus2 是多例模式（以类为单位，每个请求创建一个类） 代码实现简易 springmvc 代码 Springmvc-mybatis]]></content>
      <categories>
        <category>SpringMvc</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>springmvc</tag>
        <tag>mybatis Maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linuxInstall]]></title>
    <url>%2F2018%2F09%2F12%2FlinuxInstall%2F</url>
    <content type="text"><![CDATA[linux 无法使用 ifconfig https://www.cnblogs.com/dunitian/p/4974761.html ：使用新指令 ip 没有 ifcfg-eth0 ，可能为 ifcfg-ens33 或其他 https://hk.saowen.com/a/227c3c22a44418b6927076afcd72c05d41291f7d0e9dc7fa60031b591d9bedbc Centos 下安装与设置VIM编辑器 查找已安装的myslq 版本：​ #rpm -qa | grep mysql （注意大小写，如果mysql 不行就换MySQL） Linux 下 mysql 安装：遇到该错误哪个被需要 yum 哪个 12用yum命令安装依赖,多个依赖用空格隔开,命令如下: yum -y install libaio.so.1 libc.so.6 libcrypt.so.1 libdl.so.2 libm.so.6 net-tools 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126错误：依赖检测失败： libaio.so.1 被 MySQL-server-5.6.22-1.el6.i686 需要 libaio.so.1(LIBAIO_0.1) 被 MySQL-server-5.6.22-1.el6.i686 需要 libaio.so.1(LIBAIO_0.4) 被 MySQL-server-5.6.22-1.el6.i686 需要 libc.so.6 被 MySQL-server-5.6.22-1.el6.i686 需要 libc.so.6(GLIBC_2.0) 被 MySQL-server-5.6.22-1.el6.i686 需要 libc.so.6(GLIBC_2.1) 被 MySQL-server-5.6.22-1.el6.i686 需要 libc.so.6(GLIBC_2.1.2) 被 MySQL-server-5.6.22-1.el6.i686 需要 libc.so.6(GLIBC_2.1.3) 被 MySQL-server-5.6.22-1.el6.i686 需要 libc.so.6(GLIBC_2.10) 被 MySQL-server-5.6.22-1.el6.i686 需要 libc.so.6(GLIBC_2.2) 被 MySQL-server-5.6.22-1.el6.i686 需要 libc.so.6(GLIBC_2.2.3) 被 MySQL-server-5.6.22-1.el6.i686 需要 libc.so.6(GLIBC_2.3) 被 MySQL-server-5.6.22-1.el6.i686 需要 libc.so.6(GLIBC_2.3.3) 被 MySQL-server-5.6.22-1.el6.i686 需要 libc.so.6(GLIBC_2.3.4) 被 MySQL-server-5.6.22-1.el6.i686 需要 libc.so.6(GLIBC_2.4) 被 MySQL-server-5.6.22-1.el6.i686 需要 libc.so.6(GLIBC_2.7) 被 MySQL-server-5.6.22-1.el6.i686 需要 libc.so.6(GLIBC_2.8) 被 MySQL-server-5.6.22-1.el6.i686 需要 libcrypt.so.1 被 MySQL-server-5.6.22-1.el6.i686 需要 libcrypt.so.1(GLIBC_2.0) 被 MySQL-server-5.6.22-1.el6.i686 需要 libdl.so.2 被 MySQL-server-5.6.22-1.el6.i686 需要 libdl.so.2(GLIBC_2.0) 被 MySQL-server-5.6.22-1.el6.i686 需要 libdl.so.2(GLIBC_2.1) 被 MySQL-server-5.6.22-1.el6.i686 需要 libgcc_s.so.1 被 MySQL-server-5.6.22-1.el6.i686 需要 libgcc_s.so.1(GCC_3.0) 被 MySQL-server-5.6.22-1.el6.i686 需要 libgcc_s.so.1(GLIBC_2.0) 被 MySQL-server-5.6.22-1.el6.i686 需要 libm.so.6 被 MySQL-server-5.6.22-1.el6.i686 需要 libm.so.6(GLIBC_2.0) 被 MySQL-server-5.6.22-1.el6.i686 需要 libm.so.6(GLIBC_2.1) 被 MySQL-server-5.6.22-1.el6.i686 需要 libpthread.so.0 被 MySQL-server-5.6.22-1.el6.i686 需要 libpthread.so.0(GLIBC_2.0) 被 MySQL-server-5.6.22-1.el6.i686 需要 libpthread.so.0(GLIBC_2.1) 被 MySQL-server-5.6.22-1.el6.i686 需要 libpthread.so.0(GLIBC_2.2) 被 MySQL-server-5.6.22-1.el6.i686 需要 libpthread.so.0(GLIBC_2.3.2) 被 MySQL-server-5.6.22-1.el6.i686 需要 librt.so.1 被 MySQL-server-5.6.22-1.el6.i686 需要 librt.so.1(GLIBC_2.2) 被 MySQL-server-5.6.22-1.el6.i686 需要 libstdc++.so.6 被 MySQL-server-5.6.22-1.el6.i686 需要 libstdc++.so.6(CXXABI_1.3) 被 MySQL-server-5.6.22-1.el6.i686 需要 libstdc++.so.6(GLIBCXX_3.4) 被 MySQL-server-5.6.22-1.el6.i686 需要 libstdc++.so.6(GLIBCXX_3.4.11) 被 MySQL-server-5.6.22-1.el6.i686 需要 libstdc++.so.6(GLIBCXX_3.4.9) 被 MySQL-server-5.6.22-1.el6.i686 需要 net-tools 被 MySQL-server-5.6.22-1.el6.i686 需要[root@localhost mysql]# yum install libaio.so.1已加载插件：fastestmirrorLoading mirror speeds from cached hostfile- base: mirrors.njupt.edu.cn- extras: mirrors.163.com- updates: mirrors.163.com正在解决依赖关系--&gt; 正在检查事务---&gt; 软件包 libaio.i686.0.0.3.109-13.el7 将被 安装--&gt; 解决依赖关系完成依赖关系解决=============================================================================== Package 架构 版本 源 大小正在安装: libaio i686 0.3.109-13.el7 base 24 k事务概要安装 1 软件包总下载量：24 k安装大小：37 kIs this ok [y/d/N]: yDownloading packages:libaio-0.3.109-13.el7.i686.rpm | 24 kB 00:00 Running transaction checkRunning transaction testTransaction test succeededRunning transaction警告：RPM 数据库已被非 yum 程序修改。** 发现 41 个已存在的 RPM 数据库问题， &apos;yum check&apos; 输出如下：MySQL-server-5.6.22-1.el6.i686 有缺少的需求 libaio.so.1MySQL-server-5.6.22-1.el6.i686 有缺少的需求 libaio.so.1(LIBAIO_0.1)MySQL-server-5.6.22-1.el6.i686 有缺少的需求 libaio.so.1(LIBAIO_0.4)MySQL-server-5.6.22-1.el6.i686 有缺少的需求 libc.so.6MySQL-server-5.6.22-1.el6.i686 有缺少的需求 libc.so.6(GLIBC_2.0)MySQL-server-5.6.22-1.el6.i686 有缺少的需求 libc.so.6(GLIBC_2.1)MySQL-server-5.6.22-1.el6.i686 有缺少的需求 libc.so.6(GLIBC_2.1.2)MySQL-server-5.6.22-1.el6.i686 有缺少的需求 libc.so.6(GLIBC_2.1.3)MySQL-server-5.6.22-1.el6.i686 有缺少的需求 libc.so.6(GLIBC_2.10)MySQL-server-5.6.22-1.el6.i686 有缺少的需求 libc.so.6(GLIBC_2.2)MySQL-server-5.6.22-1.el6.i686 有缺少的需求 libc.so.6(GLIBC_2.2.3)MySQL-server-5.6.22-1.el6.i686 有缺少的需求 libc.so.6(GLIBC_2.3)MySQL-server-5.6.22-1.el6.i686 有缺少的需求 libc.so.6(GLIBC_2.3.3)MySQL-server-5.6.22-1.el6.i686 有缺少的需求 libc.so.6(GLIBC_2.3.4)MySQL-server-5.6.22-1.el6.i686 有缺少的需求 libc.so.6(GLIBC_2.4)MySQL-server-5.6.22-1.el6.i686 有缺少的需求 libc.so.6(GLIBC_2.7)MySQL-server-5.6.22-1.el6.i686 有缺少的需求 libc.so.6(GLIBC_2.8)MySQL-server-5.6.22-1.el6.i686 有缺少的需求 libcrypt.so.1MySQL-server-5.6.22-1.el6.i686 有缺少的需求 libcrypt.so.1(GLIBC_2.0)MySQL-server-5.6.22-1.el6.i686 有缺少的需求 libdl.so.2MySQL-server-5.6.22-1.el6.i686 有缺少的需求 libdl.so.2(GLIBC_2.0)MySQL-server-5.6.22-1.el6.i686 有缺少的需求 libdl.so.2(GLIBC_2.1)MySQL-server-5.6.22-1.el6.i686 有缺少的需求 libgcc_s.so.1MySQL-server-5.6.22-1.el6.i686 有缺少的需求 libgcc_s.so.1(GCC_3.0)MySQL-server-5.6.22-1.el6.i686 有缺少的需求 libgcc_s.so.1(GLIBC_2.0)MySQL-server-5.6.22-1.el6.i686 有缺少的需求 libm.so.6MySQL-server-5.6.22-1.el6.i686 有缺少的需求 libm.so.6(GLIBC_2.0)MySQL-server-5.6.22-1.el6.i686 有缺少的需求 libm.so.6(GLIBC_2.1)MySQL-server-5.6.22-1.el6.i686 有缺少的需求 libpthread.so.0MySQL-server-5.6.22-1.el6.i686 有缺少的需求 libpthread.so.0(GLIBC_2.0)MySQL-server-5.6.22-1.el6.i686 有缺少的需求 libpthread.so.0(GLIBC_2.1)MySQL-server-5.6.22-1.el6.i686 有缺少的需求 libpthread.so.0(GLIBC_2.2)MySQL-server-5.6.22-1.el6.i686 有缺少的需求 libpthread.so.0(GLIBC_2.3.2)MySQL-server-5.6.22-1.el6.i686 有缺少的需求 librt.so.1MySQL-server-5.6.22-1.el6.i686 有缺少的需求 librt.so.1(GLIBC_2.2)MySQL-server-5.6.22-1.el6.i686 有缺少的需求 libstdc++.so.6MySQL-server-5.6.22-1.el6.i686 有缺少的需求 libstdc++.so.6(CXXABI_1.3)MySQL-server-5.6.22-1.el6.i686 有缺少的需求 libstdc++.so.6(GLIBCXX_3.4)MySQL-server-5.6.22-1.el6.i686 有缺少的需求 libstdc++.so.6(GLIBCXX_3.4.11)MySQL-server-5.6.22-1.el6.i686 有缺少的需求 libstdc++.so.6(GLIBCXX_3.4.9)MySQL-server-5.6.22-1.el6.i686 有缺少的需求 net-tools 正在安装 : libaio-0.3.109-13.el7.i686 1/1 验证中 : libaio-0.3.109-13.el7.i686 1/1 已安装: libaio.i686 0:0.3.109-13.el7 完毕！ 然后 继续安装 mysql 包出现问题 12345678910[root@localhost mysql]# rpm -ivh MySQL-server-5.6.22-1.el6.i686.rpm错误：依赖检测失败： libgcc_s.so.1 被 MySQL-server-5.6.22-1.el6.i686 需要 libgcc_s.so.1(GCC_3.0) 被 MySQL-server-5.6.22-1.el6.i686 需要 libgcc_s.so.1(GLIBC_2.0) 被 MySQL-server-5.6.22-1.el6.i686 需要 libstdc++.so.6 被 MySQL-server-5.6.22-1.el6.i686 需要 libstdc++.so.6(CXXABI_1.3) 被 MySQL-server-5.6.22-1.el6.i686 需要 libstdc++.so.6(GLIBCXX_3.4) 被 MySQL-server-5.6.22-1.el6.i686 需要 libstdc++.so.6(GLIBCXX_3.4.11) 被 MySQL-server-5.6.22-1.el6.i686 需要 libstdc++.so.6(GLIBCXX_3.4.9) 被 MySQL-server-5.6.22-1.el6.i686 需要 选择 yum -y install libgcc_s.so.1 libstdc++.so.6出现新问题 1234567891011121314151617181920212223242526272829303132333435已加载插件：fastestmirrorLoading mirror speeds from cached hostfile * base: mirrors.njupt.edu.cn * extras: mirrors.163.com * updates: mirrors.163.com正在解决依赖关系--&gt; 正在检查事务---&gt; 软件包 libgcc.i686.0.4.8.5-36.el7 将被 安装--&gt; 解决依赖关系完成错误： Multilib version problems found. This often means that the root cause is something else and multilib version checking is just pointing out that there is a problem. Eg.: 1. You have an upgrade for libgcc which is missing some dependency that another package requires. Yum is trying to solve this by installing an older version of libgcc of the different architecture. If you exclude the bad architecture yum will tell you what the root cause is (which package requires what). You can try redoing the upgrade with --exclude libgcc.otherarch ... this should give you an error message showing the root cause of the problem. 2. You have multiple architectures of libgcc installed, but yum can only see an upgrade for one of those architectures. If you don&apos;t want/need both architectures anymore then you can remove the one with the missing update and everything will work. 3. You have duplicate versions of libgcc installed already. You can use &quot;yum check&quot; to get yum show these errors. ...you can also use --setopt=protected_multilib=false to remove this checking, however this is almost never the correct thing to do as something else is very likely to go wrong (often causing much more problems). 保护多库版本：libgcc-4.8.5-36.el7.i686 != libgcc-4.8.5-28.el7.x86_64 此时哪个出现 保护多版本库 升级哪个 yum update libstdc++-4.8.5-28.el7.x86_64 全部解决后即可安装 mysql 参考：https://blog.csdn.net/Wuhaotian1996/article/details/80689009 https://blog.csdn.net/qq_40208605/article/details/80679020 安装 mysql 异常123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051[root@localhost mysql]# rpm -ivh MySQL-server-5.6.22-1.el6.i686.rpm准备中... ################################# [100%] file /usr/share/mysql/charsets/README from install of MySQL-server-5.6.22-1.el6.i686 conflicts with file from package mariadb-libs-1:5.5.56-2.el7.x86_64 file /usr/share/mysql/czech/errmsg.sys from install of MySQL-server-5.6.22-1.el6.i686 conflicts with file from package mariadb-libs-1:5.5.56-2.el7.x86_64 file /usr/share/mysql/danish/errmsg.sys from install of MySQL-server-5.6.22-1.el6.i686 conflicts with file from package mariadb-libs-1:5.5.56-2.el7.x86_64 file /usr/share/mysql/dutch/errmsg.sys from install of MySQL-server-5.6.22-1.el6.i686 conflicts with file from package mariadb-libs-1:5.5.56-2.el7.x86_64 file /usr/share/mysql/english/errmsg.sys from install of MySQL-server-5.6.22-1.el6.i686 conflicts with file from package mariadb-libs-1:5.5.56-2.el7.x86_64 file /usr/share/mysql/estonian/errmsg.sys from install of MySQL-server-5.6.22-1.el6.i686 conflicts with file from package mariadb-libs-1:5.5.56-2.el7.x86_64 file /usr/share/mysql/french/errmsg.sys from install of MySQL-server-5.6.22-1.el6.i686 conflicts with file from package mariadb-libs-1:5.5.56-2.el7.x86_64 file /usr/share/mysql/german/errmsg.sys from install of MySQL-server-5.6.22-1.el6.i686 conflicts with file from package mariadb-libs-1:5.5.56-2.el7.x86_64 file /usr/share/mysql/greek/errmsg.sys from install of MySQL-server-5.6.22-1.el6.i686 conflicts with file from package mariadb-libs-1:5.5.56-2.el7.x86_64 file /usr/share/mysql/hungarian/errmsg.sys from install of MySQL-server-5.6.22-1.el6.i686 conflicts with file from package mariadb-libs-1:5.5.56-2.el7.x86_64 file /usr/share/mysql/italian/errmsg.sys from install of MySQL-server-5.6.22-1.el6.i686 conflicts with file from package mariadb-libs-1:5.5.56-2.el7.x86_64 file /usr/share/mysql/japanese/errmsg.sys from install of MySQL-server-5.6.22-1.el6.i686 conflicts with file from package mariadb-libs-1:5.5.56-2.el7.x86_64 file /usr/share/mysql/korean/errmsg.sys from install of MySQL-server-5.6.22-1.el6.i686 conflicts with file from package mariadb-libs-1:5.5.56-2.el7.x86_64 file /usr/share/mysql/norwegian-ny/errmsg.sys from install of MySQL-server-5.6.22-1.el6.i686 conflicts with file from package mariadb-libs-1:5.5.56-2.el7.x86_64 file /usr/share/mysql/norwegian/errmsg.sys from install of MySQL-server-5.6.22-1.el6.i686 conflicts with file from package mariadb-libs-1:5.5.56-2.el7.x86_64 file /usr/share/mysql/polish/errmsg.sys from install of MySQL-server-5.6.22-1.el6.i686 conflicts with file from package mariadb-libs-1:5.5.56-2.el7.x86_64 file /usr/share/mysql/portuguese/errmsg.sys from install of MySQL-server-5.6.22-1.el6.i686 conflicts with file from package mariadb-libs-1:5.5.56-2.el7.x86_64 file /usr/share/mysql/romanian/errmsg.sys from install of MySQL-server-5.6.22-1.el6.i686 conflicts with file from package mariadb-libs-1:5.5.56-2.el7.x86_64 file /usr/share/mysql/russian/errmsg.sys from install of MySQL-server-5.6.22-1.el6.i686 conflicts with file from package mariadb-libs-1:5.5.56-2.el7.x86_64 file /usr/share/mysql/serbian/errmsg.sys from install of MySQL-server-5.6.22-1.el6.i686 conflicts with file from package mariadb-libs-1:5.5.56-2.el7.x86_64 file /usr/share/mysql/slovak/errmsg.sys from install of MySQL-server-5.6.22-1.el6.i686 conflicts with file from package mariadb-libs-1:5.5.56-2.el7.x86_64 file /usr/share/mysql/spanish/errmsg.sys from install of MySQL-server-5.6.22-1.el6.i686 conflicts with file from package mariadb-libs-1:5.5.56-2.el7.x86_64 file /usr/share/mysql/swedish/errmsg.sys from install of MySQL-server-5.6.22-1.el6.i686 conflicts with file from package mariadb-libs-1:5.5.56-2.el7.x86_64 file /usr/share/mysql/ukrainian/errmsg.sys from install of MySQL-server-5.6.22-1.el6.i686 conflicts with file from package mariadb-libs-1:5.5.56-2.el7.x86_64 file /usr/share/mysql/charsets/Index.xml from install of MySQL-server-5.6.22-1.el6.i686 conflicts with file from package mariadb-libs-1:5.5.56-2.el7.x86_64 file /usr/share/mysql/charsets/armscii8.xml from install of MySQL-server-5.6.22-1.el6.i686 conflicts with file from package mariadb-libs-1:5.5.56-2.el7.x86_64 file /usr/share/mysql/charsets/ascii.xml from install of MySQL-server-5.6.22-1.el6.i686 conflicts with file from package mariadb-libs-1:5.5.56-2.el7.x86_64 file /usr/share/mysql/charsets/cp1250.xml from install of MySQL-server-5.6.22-1.el6.i686 conflicts with file from package mariadb-libs-1:5.5.56-2.el7.x86_64 file /usr/share/mysql/charsets/cp1251.xml from install of MySQL-server-5.6.22-1.el6.i686 conflicts with file from package mariadb-libs-1:5.5.56-2.el7.x86_64 file /usr/share/mysql/charsets/cp1256.xml from install of MySQL-server-5.6.22-1.el6.i686 conflicts with file from package mariadb-libs-1:5.5.56-2.el7.x86_64 file /usr/share/mysql/charsets/cp1257.xml from install of MySQL-server-5.6.22-1.el6.i686 conflicts with file from package mariadb-libs-1:5.5.56-2.el7.x86_64 file /usr/share/mysql/charsets/cp850.xml from install of MySQL-server-5.6.22-1.el6.i686 conflicts with file from package mariadb-libs-1:5.5.56-2.el7.x86_64 file /usr/share/mysql/charsets/cp852.xml from install of MySQL-server-5.6.22-1.el6.i686 conflicts with file from package mariadb-libs-1:5.5.56-2.el7.x86_64 file /usr/share/mysql/charsets/cp866.xml from install of MySQL-server-5.6.22-1.el6.i686 conflicts with file from package mariadb-libs-1:5.5.56-2.el7.x86_64 file /usr/share/mysql/charsets/dec8.xml from install of MySQL-server-5.6.22-1.el6.i686 conflicts with file from package mariadb-libs-1:5.5.56-2.el7.x86_64 file /usr/share/mysql/charsets/geostd8.xml from install of MySQL-server-5.6.22-1.el6.i686 conflicts with file from package mariadb-libs-1:5.5.56-2.el7.x86_64 file /usr/share/mysql/charsets/greek.xml from install of MySQL-server-5.6.22-1.el6.i686 conflicts with file from package mariadb-libs-1:5.5.56-2.el7.x86_64 file /usr/share/mysql/charsets/hebrew.xml from install of MySQL-server-5.6.22-1.el6.i686 conflicts with file from package mariadb-libs-1:5.5.56-2.el7.x86_64 file /usr/share/mysql/charsets/hp8.xml from install of MySQL-server-5.6.22-1.el6.i686 conflicts with file from package mariadb-libs-1:5.5.56-2.el7.x86_64 file /usr/share/mysql/charsets/keybcs2.xml from install of MySQL-server-5.6.22-1.el6.i686 conflicts with file from package mariadb-libs-1:5.5.56-2.el7.x86_64 file /usr/share/mysql/charsets/koi8r.xml from install of MySQL-server-5.6.22-1.el6.i686 conflicts with file from package mariadb-libs-1:5.5.56-2.el7.x86_64 file /usr/share/mysql/charsets/koi8u.xml from install of MySQL-server-5.6.22-1.el6.i686 conflicts with file from package mariadb-libs-1:5.5.56-2.el7.x86_64 file /usr/share/mysql/charsets/latin1.xml from install of MySQL-server-5.6.22-1.el6.i686 conflicts with file from package mariadb-libs-1:5.5.56-2.el7.x86_64 file /usr/share/mysql/charsets/latin2.xml from install of MySQL-server-5.6.22-1.el6.i686 conflicts with file from package mariadb-libs-1:5.5.56-2.el7.x86_64 file /usr/share/mysql/charsets/latin5.xml from install of MySQL-server-5.6.22-1.el6.i686 conflicts with file from package mariadb-libs-1:5.5.56-2.el7.x86_64 file /usr/share/mysql/charsets/latin7.xml from install of MySQL-server-5.6.22-1.el6.i686 conflicts with file from package mariadb-libs-1:5.5.56-2.el7.x86_64 file /usr/share/mysql/charsets/macce.xml from install of MySQL-server-5.6.22-1.el6.i686 conflicts with file from package mariadb-libs-1:5.5.56-2.el7.x86_64 file /usr/share/mysql/charsets/macroman.xml from install of MySQL-server-5.6.22-1.el6.i686 conflicts with file from package mariadb-libs-1:5.5.56-2.el7.x86_64 file /usr/share/mysql/charsets/swe7.xml from install of MySQL-server-5.6.22-1.el6.i686 conflicts with file from package mariadb-libs-1:5.5.56-2.el7.x86_64 经网上查找是起了冲突 ‘conflicts’ 看到“conflicts”，是产生冲突了，文件“/usr/share/mysql/charsets/*”需要MySQL-server-5.6.22-1.el6.i686 版本的，而系统已经存在mariadb-libs-1:5.5.56-2.el7.x86_64版本的 删除冲突文件 mariadb-libs-1:5.5.56-2* yum -y remove mariadb-libs-1:5.5.56-2* 然后就可以安装自己的 mysql 了 参考：https://blog.csdn.net/testcs_dn/article/details/39026213 tomcat 安装后，启动找不到安装的 jdk解决方法：将jdk 目录手动配置到 catalina.sh 文件下 配置jdk环境变量，打开/etc/profile配置文件，将下面配置拷贝进去 123456789#set java environment JAVA_HOME=/usr/local/jdk1.8.0_191 CLASSPATH=.:$JAVA_HOME/lib.tools.jar PATH=$JAVA_HOME/bin:$PATH export JAVA_HOME CLASSPATH PATH 重新加载 /etc/profile 配置文件 source /etc/profile 永久写入防火墙配置因为是 CentOS Linux 7 的内核，不能直接用 6 内核的方法 先删除 7.0 系统自带防火墙，，安装旧版 开放 xxx 端口 /sbin/iptables -I INPUT -p tcp –dport 80 -j ACCEPT 永久保存 service iptables save 或 /usr/libexec/iptables/iptables.init save 参考：https://www.cnblogs.com/zhangzhibin/p/6231870.html https://blog.csdn.net/guoyf123321/article/details/52416328 mysql 安装后没有密码文件重设 mysql 密码 解决方案如下： #service mysqld stop#mysqld_safe –user=mysql –skip-grant-tables –skip-networking &amp; #mysql -u root mysql mysql&gt; UPDATE user SET Password=PASSWORD(‘newpassword’) where USER=’root’;mysql&gt; FLUSH PRIVILEGES;mysql&gt; quit service mysqld restart # mysql -uroot -pEnter password: &lt;输入新设的密码newpassword&gt; mysql&gt; UPDATE user SET Password=PASSWORD(‘newpassword’) where USER=’root’; 这句中的 newpassword 指需要新设置的密码 参考：https://onekeyes.iteye.com/blog/2316794 Linux tomcat 部署 war 文件后无法访问 tomcat 只显示 tomcat 主页可能是 idea 的 tomcat 和 jdk 版本跟 Linux 下的不同，将 linux 的 tomcat 和 jdk 升级成 idea 一样。 idea 使用 Junit 自动生成测试类https://www.cnblogs.com/libingbin/p/6007203.html]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[黑马 Spring]]></title>
    <url>%2F2018%2F09%2F03%2FHMSpring%2F</url>
    <content type="text"><![CDATA[maven dependency 机制 idea 无法导入 jdbcjdbcDaosupport 解决 Project Structure－&gt;Facets 配置。添加spring配置文件的模块 参考： https://blog.csdn.net/tiantiandjava/article/details/41204607 Caused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name ‘accountService’ defined in class path resource [applicationContext.xml]: Initialization of bean failed; nested exception is org.springframework.beans.ConversionNotSupportedException: Failed to convert property value of type ‘com.mchange.v2.c3p0.ComboPooledDataSource’ to required type ‘cn.itcast.dao.AccountDao’ for property ‘ad’; nested exception is java.lang.IllegalStateException: Cannot convert value of type ‘com.mchange.v2.c3p0.ComboPooledDataSource’ to required type ‘cn.itcast.dao.AccountDao’ for property ‘ad’: no matching editors or conversion strategy found xml 配置中需要将 accountDao 注入到 accountService ， 将 dataSource（连接池） 注入到 accountDao Caused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name ‘transactionManager’ defined in class path resource [applicationContext.xml]: BeanPostProcessor before instantiation of bean failed; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name ‘org.springframework.aop.support.DefaultBeanFactoryPointcutAdvisor#0’: Cannot resolve reference to bean ‘txPc’ while setting bean property ‘pointcut’; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name ‘txPc’: Lookup method resolution failed; nested exception is java.lang.IllegalStateException: Failed to introspect Class [org.springframework.aop.aspectj.AspectJExpressionPointcut] from ClassLoader [sun.misc.Launcher$AppClassLoader@b4aac2] Caused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name ‘org.springframework.aop.support.DefaultBeanFactoryPointcutAdvisor#0’: Cannot resolve reference to bean ‘txPc’ while setting bean property ‘pointcut’; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name ‘txPc’: Lookup method resolution failed; nested exception is java.lang.IllegalStateException: Failed to introspect Class [org.springframework.aop.aspectj.AspectJExpressionPointcut] from ClassLoader [sun.misc.Launcher$AppClassLoader@b4aac2] Caused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name ‘txPc’: Lookup method resolution failed; nested exception is java.lang.IllegalStateException: Failed to introspect Class [org.springframework.aop.aspectj.AspectJExpressionPointcut] from ClassLoader [sun.misc.Launcher$AppClassLoader@b4aac2] 加粗语句表示缺少 jar 包 aspectjweaver.jar 下载导入此 jar 包即可]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
        <tag>idea</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[idea_create_web]]></title>
    <url>%2F2018%2F08%2F31%2Fidea-create-web%2F</url>
    <content type="text"><![CDATA[流程参考：https://www.cnblogs.com/xuange306/p/7012341.html 遇见的小问题：没有 javax.servlet.* 的 jar 包 在 Project Structure 中选择 libraries 点击左侧加号选择 java 添加 tomcat 文件夹下 lib 文件夹中的 servlet-api.jar 同时也可添加常用 jar 包 tomcat-api 与 jsp-api 可以使用 ctrl+shift+alt+s 打开 Project Structure 选择 Modules 点击右侧 + 号，选择 libraries ，选择 Project Libraries 下的 tomcat 添加即可 普通 jar 包添加可选方法：在 WEB-INF 下创建 lib 目录，把 jar 包复制到 lib 目录下，ctrl+shift+alt+s 打开 Project Structure 选择左侧 libraries ，点击左侧加号 选择 java，选择 创建的 lib 目录添加，选择左侧 Modules 栏，勾选 lib https://my.oschina.net/fdblog/blog/161305 创建Web项目后没有WEB-INF文件夹及web.xml 最简单的方法：idea 创建 web 项目时用 xml 2.5 或： shift+ctrl+alt+s进入Project Structure打开Project Structure，在facets中选中次级的web或者在Modules中选中web，在deployment Descriptors面板里，点击 +号选择web.xml以及版本号。然后在弹出的对话框中修改xml默认的目录，加上web就可以了 Q: IntelliJ IDEA Tomcal启动报错： org.apache.catalina.core.AprLifecycleListener.init The APR based Apache Tomcat Native library failed to load. The error reported was [C:\tomcat\bin\tcnative-1.dll: Can’t load AMD 64-bit .dll on a IA 32-bit platform] java.lang.UnsatisfiedLinkError: C:\tomcat\bin\tcnative-1.dll: Can’t load AMD 64-bit .dll on a IA 32-bit platform A: 主要是在64位的系统下安装的虚拟机是64位的，而WTK的sublime.dll不能在64位的平台下加载64位的虚拟机，只能加载32位的。由于WTK在安装的时候加载的64虚拟机的地址，它找到的是64位的虚拟机，所以它提示不能加载32位的虚拟机（在目录下没有32的虚拟机） 解决办法下载 the 32bit from http://www.apache.org/dist/tomcat/tomcat-connectors/native/找到最近的版本，我的是 tomcat-native-1.2.16-win32-bin.zip下载后解压，找到tomcat-native-1.2.16-win32-bin.zip\bin\tcnative-1.dll (不是64X文件夹中的)替换到tomcat根目录下tomcat\bin idea tomcat警告参考：http://blog.51cto.com/13765598/2120489 Q: intellj idea启动tomcat服务器后无法访问localhost:8080（白屏）A: 原因：没有将tomcat主页的工程部署到intellj idea的虚拟tomcat路径，可在Run/Debug Configurations中Deployment选项中点击右边的绿色加号，选择External Source，然后添加Tomcat安装目录tomcat/webapps/Root目录即可；参考资料：https://blog.csdn.net/qq_22708467/article/details/79070973 tips：在部署 tomcat 服务器时，点击右上角 edit configurations 选择Deployment 添加了 Artifact 后，右边的Application context中的 / 代表项目部署的虚拟路径（网址访问主页面路径）: 若 index.jsp 在 aaa/web 目录下，虚拟路径为 /则访问 index.jsp 地址为 localhost/8080 或 localhost/8080/index.jsp . 若虚拟路径设为 /aaa 则访问 index.jsp 的地址为 localhost/8080/aaa/index.jsp 或 localhost/8080/aaa-request.getContextPath(); 得到的值为虚拟路径]]></content>
      <categories>
        <category>idea</category>
      </categories>
      <tags>
        <tag>idea</tag>
        <tag>intelj</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单例设计模式]]></title>
    <url>%2F2018%2F08%2F20%2FSingleDemo%2F</url>
    <content type="text"><![CDATA[单例设计模式：解决一个类中只存在一个对象单例设计模式特性：保证对象在内存中的唯一性： 为了避免其他程序创建过多对象，先禁止其他程序创建该类对象 为了让其他类访问到该对象，在本类中自定义一个对象 方便其他对象对自定义对象的访问，可以对外提供一些访问方式 用代码的方式实现对象在内存中唯一性： 将构造函数私有化 在类中创建一个本类对象 提供一个方法可以获取到该对象 单例模式使用方式：按平时的描述方式描述事物，加上 单例模式 的 3 步方式即可 单例设计模式饿汉式 java 代码实现：1234567891011121314151617181920class Single&#123; private Single()&#123;&#125;; //内置成员变化需要私有化 private static Single s = new Single(); /** 方法被调用的方法只有两种：对象、类名 因为该对象被私有化了，无法外部创建该方法，所以用类名调用 类名调用需要设置静态方法 静态方法只能访问静态成员，所以成员也需要静态 */ private Single getInstance()&#123; return s; &#125;&#125;class SingleDemo&#123; public static void main(String [] args)&#123; Single ss = Single.getInstance(); &#125;&#125; 栈中加载 main 函数 和 ss 方法区中有了 Single 的空间、静态的 s 变量、getInstance() 方法 堆中有了一个 new Single() 地址假设为 0x0015 方法区的 s 变量指向了 堆中 new Single() 的地址 0x0015 return s Single ss = Single.getInstance(); 使得 ss 也指向 0x0015 普通方式创建多个对象：1234567891011121314151617181920212223242526272829303132333435363738394041424344class Single&#123; private int num; public void setNum(int num)&#123; this.num = num; &#125; public int getNum()&#123; return num; &#125; //不设置私有化，可外部创建该对象 Single()&#123;&#125;; //单例模式下设置私有化，不可外部创建该对象 //private Single()&#123;&#125;; private static Single s = new Single(); private Single getInstance()&#123; return s; &#125;&#125;class SingleDemo&#123; public static void main(String [] args)&#123; //创建 2 个 Single 对象 Single s1 = new Single(); Single s2 = new Single(); //设置值为 30 s1.setNum(30); /**输出值为默认值 0 创建了两个对象，修改其中一个值跟另一个无关 */ System.out.println(s2.getNum()); /* ss2 的值为 23，表明 ss1 与 ss2 是同一个对象 单例模式内存中一个一个对象在执行，该对象有 3 个引用： SingleDemo 的 ss1、ss2 和 Single 中的 s */ //Single ss1 = Single.getInstance(); //Single ss2 = Single.getInstance(); //ss1.setNum(15); //System.out.println(ss2); &#125;&#125; 单例设计模式 懒汉式 java 代码123456789101112131415161718192021222324252627282930/*先初始化对象：称为 饿汉式Single 类一进内存，就已经创建好了对象class Single&#123; private Single()&#123;&#125;; private static Single s = new Single(); private Single getInstance()&#123; return s; &#125; &#125;*///对象在方法被调用时才初始化，也叫作对象的延时加载 称为 懒汉式//Single 类进内存，对象还没有存在，只有调用 getInstance() 方法时，才建立对象class Single&#123; private Single()&#123;&#125;; private static Single s = null; private Single getInstance()&#123; if(s==null)&#123; s = new Single(); &#125; return s; &#125; &#125;class SingleDemo&#123; public static void main(String [] args)&#123; Single ss = Single.getInstance(); &#125;&#125; 饿汉式：Single 类 加载进内存时，方法区就有 s，堆中就有对象，对象的地址值赋给 s 懒汉式：Single 类 加载进内存时，方法区 s 为空，当调用 getInstance() 方法时，才在内存中建立建立对象，将堆内存中的地址赋给 s，替换空值 懒汉式防止多个用户创建多个对象1234567891011121314151617class Single&#123; private Single()&#123;&#125;; private static Single s = null; //锁加载判断内部，提升效率 private Single getInstance()&#123; if(s==null)&#123; //加锁，防止创建多个对象 synchronized(Single.class)&#123; if(s==null)&#123; s = new Single(); &#125; &#125; &#125; return s; &#125; &#125;]]></content>
      <categories>
        <category>Design Patterns</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>Singleton Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring4x_2]]></title>
    <url>%2F2018%2F08%2F14%2FSpring4x-2%2F</url>
    <content type="text"><![CDATA[Spring 名词参考POJO：POJO（Plain Ordinary Java Object）简单的Java对象，实际就是普通JavaBeans，是为了避免和EJB混淆所创造的简称 使用POJO名称是为了避免和EJB混淆起来, 而且简称比较直接. 其中有一些属性及其getter setter方法的类,没有业务逻辑，有时可以作为VO(value -object)或dto(Data Transform Object)来使用.当然,如果你有一个简单的运算属性也是可以的,但不允许有业务方法,也不能携带有connection之类的方法。 教程参考 idea 创建 log4j 文件 Q&amp;AQ1:application context not configured for this file A: application context not configured for this file于spring框架使用中的原因 Q2: cvc-complex-type.2.4.c: 通配符的匹配很全面, 但无法找到元素 ‘tx:Advisor’ 的声明。 A: 在 smart-context.xml 中加入 Spring 引用 Q3:1Caused by: java.sql.SQLException: Access denied for user &apos;root&apos;@&apos;localhost&apos; (using password: YES) A: smart-context.xml 配置 数据库的用户密码错误 Q4:c:if 与 c:url 标签无效 A: accepted First add this to the top of your “.jsp” file: 1&lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot; prefix=&quot;c&quot; %&gt; It will still give syntax error but you can fix that by adding “javax.servlet:jstl:1.2” (without quotes) as a module dependency. To do that, follow these steps: Click your project name and press “F4” to bring up the module settings dialog. Then go to the “dependencies” tab in the “modules” section. Click the green “+” icon –&gt; library –&gt; new library –&gt; From Maven. Search for javax.servlet:jstl:1.2 in the search bar and press OK and it will download and add the above mentioned library as a module. Now you should not have any kind of syntax error. c:if标签 Cannot resolve symbol]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springAutoAssembly]]></title>
    <url>%2F2018%2F08%2F10%2FspringAutoAssembly%2F</url>
    <content type="text"><![CDATA[通过 Java 代码装配 bean通常组件扫描和自动化装配实现 Spring 的自动化配置，但是有时候例如要将第三方库中的组件装配到你的应用中，这种情况下没办法在它的类上添加 @Component 和 @Autowired 注解，就不能使用自动化配置了。 需要进行显示装配方式：java/XML java(javaConfig) 是比较好的方案，它更强大、类型安全、对重构友好，它是 java 代码，但是 JavaConfig 是配置代码，不应该包含任何业务逻辑，会将其放在单独的包中与其他应用程序逻辑分离开。 创建配置类如果去掉 CDPlayerConfig 的 @ComponentScan 注解，再次运行 CDPlayerTest 的话，测试会失败，出现异常。测试期望被注入CDPlayer 和 CompactDisc，但是这些 bean 没有被创建，组件扫描不会发现它们。 123456789package com.soundsystem;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;@Configuration//@ComponentScanpublic class CDPlayerConfig &#123;&#125; 声明简单的 bean在 JavaConfig 中声明 bean ，编写一个创建所需类型的实例的方法，给这个方法添加 @Bean 注解。 声明 CompactDisc bean : 1234@Beanpublic CompactDisc sgtPeppers()&#123; return new SgtPeppers();&#125; @Bean 注解告诉 Spring 这个方法返回一个对象，该对象要注册为 Spring 应用上下文中的 bean ，方法体中包含了最终产生 bean 实例的逻辑。 默认情况下，bean 的 id 跟带有@bean注解的方法名一样，本例中为 sgtPeppers，如果要重新设置可以通过name属性指定： 1234@Bean(name="lonelyHeartsClubBand")public CompactDisc sgtPeppers()&#123; return new SgtPeppers();&#125; 方法体返回了一个新的 SgtPeppers 实例，因为是java代码所以可以使用java提供的全部功能，只要最终能生成CompactDisc实例就行。 可以用 java的功能在一组 CD 中随机选择一个 CompactDisc 播放： 12345678910111213@Beanpublic CompactDisc randomBeatlesCD()&#123; int choice = (int)Math.floor(Math.random()*4); if(choice==0)&#123; return new WhiteAlbum(); &#125;else if(choice==1)&#123; return new SgtPeppers(); &#125;else if(choice==2)&#123; return new HardDaysNight(); &#125;else if(choice==3)&#123; return enw Revolver(); &#125;&#125; Spring中Bean及@Bean的理解 java 是面相对象，对象有方法和属性，需要对象实例来调用方法和属性（实例化），有方法或属性的类都需要实例化才能具象化地去使用这些方法和属性。bean 是类的代理，这样它就能代表类拥有该拥有的东西了。 注解： 使用 bean: 即是把已经在xml文件中配置好的Bean拿来用，完成属性、方法的组装；比如@Autowired , @Resource，可以通过byTYPE（@Autowired）、byNAME（@Resource）的方式获取Bean； 注册Bean: @Component , @Repository , @ Controller , @Service , @Configration这些注解都是把你要实例化的对象转化成一个Bean，放在IoC容器中，等你要用的时候，它会和上面的@Autowired , @Resource配合到一起，把对象、属性、方法完美组装。 @bean: 意思是@Bean明确地指示了一种方法，什么方法呢——产生一个bean的方法，并且交给Spring容器管理；从这我们就明白了为啥@Bean是放在方法的注释上了，因为它很明确地告诉被注释的方法，你给我产生一个Bean，然后交给Spring容器，剩下的你就别管了 Spring 注入： IOC 容器加载时会扫描 xml 文件中 bean 的配置，对这些 bean 进行实例化（初始化）。注入指在初始化一个实例的时候对这个实例的成员变量进行赋值。 借助 JavaConfig 实现注入当需要声明一个依赖于 CompactDisc 的 CDPlayer bean 时，可用如下方法在 JavaConfig 中进行装配： 引用创建 bean 的方法： 1234@Beanpublic CDPlayer cdPlayer()&#123; return new CDPlayer(sgtPeppers());&#125; 创建的 bean ID 为 cdPlayer，与方法名相同。cdPlayer() 方法没有使用默认的构造器构建实例，而是调用了需要传入 CompactDisc 对象的构造器来创建 CDPlayer 实例，但是它并不是通过调用 sgtPeppers() 方法得到的，sgtPeppers() 方法上添加了 @Bean 注解，所以 Spring 将会拦截所有对它的条用，会直接返回该方法所创建的 bean cdPlayer() 方法请求一个 CompactDisc 作为参数 1234@Beanpublic CDPlayer cdPlayer(CompactDisc compactDisc)&#123; return new CDPlayer(compactdisc);&#125; 不管 CompactDisc 使用什么方式创建出来的，Spring 都会将其传入到配置方法中，并用来创建 CDPlayer bean。以上构造器和下面的 Setter 方法只是 @Bean 的其中一些方法： 123456@Beanpublic CDPlayer cdPlayer(CompactDisc compactDisc)&#123; CDPlayer cdPlayer = new CDPlayer(compactDisc); cdPlayer.setCompactDisc(compactDisc) return cdPlayer;&#125; 声明一个简单的 属性注入（设值注入） 元素类似于 JavaConfig 的 @Bean 注解。 1234&lt;bean id="cdPlayer" class="soundsystem.CDPlayer"&gt; &lt;constructor-arg name="compactDisc" ref="compactDisc" /&gt;&lt;/bean&gt; 1234&lt;bean id="cdPlayer" class="soundsystem.CDPlayer"&gt; &lt;property name="compactDisc" ref="compactDisc" /&gt;&lt;/bean&gt; id 为 cdPlayer 的 CDPlayer 类，其中有一个名称为 compactDisc 的成员变量。 元素为属性的 Setter 方法所提供的功能与 元素为构造器所提供的功能相同。 通过 ref 属性，引用了 ID 为 compactDisc 的 bean，用 setCompactDisc() 方法将其注入到 compactDisc 属性中。所以 CDPlayer 中必须有 setCompactDisc() 的方法，由 IOC 容器自动调用方法进行赋值。]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>autoAssembly</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring 框架基础]]></title>
    <url>%2F2018%2F08%2F02%2Fspring%2F</url>
    <content type="text"><![CDATA[Spring 框架基础控制反转（Inversion of Control，缩写为IoC），是面向对象编程中的一种设计原则，可以用来减低计算机代码之间的耦合度。其中最常见的方式叫做依赖注入（Dependency Injection，简称DI），还有一种方式叫“依赖查找”（Dependency Lookup）。通过控制反转，对象在被创建的时候，由一个调控系统内所有对象的外界实体，将其所依赖的对象的引用传递给它。也可以说，依赖被注入到对象中。 IOC 是一种设计模式，原来创建对象的主动权和时间是由自己控制的，现在把需要使用的对象的创建，销毁的控制权交给别人（IOC容器），使用时直接获取，这种对象可以单例或多例。IOC 有利于降低耦合度。 依赖注入和控制反转的理解 AOP为Aspect Oriented Programming的缩写，意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。 idea 的简单 Spring 文件创建及测试 创建一个 project 勾选 Spring 及 web Application 创建 interface、实现接口类、配置类以及测试类 idea 创建测试类方法： 在 bean 同目录下创建一个 test 测试文件夹，同时按住 ctrl+shift+alt+s 调出 project structure 窗口，选择modules 栏中的 Sources 栏，选中创建 test 文件夹，在 Mark as 栏选择 Tests，将 Tests 文件夹作为 Test 文件创建的目录。 在 实现接口类的类名上 alt+enter 选择 create test，在 TestLibrary 选择 JUnit4， 如果出现 JUnit4 Library notfound in the module ，点击 fix 选择 Use ‘JUnit4’ from idea distribution 点 ok，在下方 Member 栏将方法选中，可创建该类方法的测试方法 在测试类文件中类的上方添加注释 @RunWith(SpringJUnit4ClassRunner.class) 以便在测试开始的时候自动创建 Spring 的应用上下文 添加注解 @ContextConfiguration(classes=CDPlayerConfig.class) 表示需要在 CDPlayerConfig 中加载配置，因为 CDPlayerConfig 类中包含了 @ComponentScan ，则最终引用上下文也会包含 CompactiDisc 的bean 在类中添加 注释 表示将 bean 注入到测试代码之中 12@Autowiredprivate CompactDisc cd; 一个简单的测试方法，断言测试 cd 属性不为 null ，表示 spring 能够发现 CompactDisc 类，能自动在 Spring 上下文中创建 bean 并将其注入到测试代码中 1234@Testpublic void cdShouldNotBeNull()&#123; assertNotNull(cd);&#125; 如果运行测试类报错 org.junit 不存在 ctrl + shift + alt + s 进入 project structure 窗口 ，在 Library 窗口 点击左边绿色的加号 -&gt; Java -&gt; 找到 IDEA 安装路径下的 Lib 中的junit-4.12 -&gt; 确定 ctrl + shift + t 在 测试 文件与 被测试 文件间切换 idea 使用 Junit4 测试教程（需科学上网） idea 打开显示 Spring Configure check 解决方法 ​ 打开 Project Structure－&gt;Facets 配置。左侧 + 号，选择 Spring (添加 spring 配置文件的模块) ​ 右侧 + 号，勾选项目，会选中项目及其下的 xml 文件 (设置添加没有被映射的Spring配置文件)，点击应用即可 为组件扫描的 bean 命名Spring 应用上下文所有的 bean 一般都会根据类名指定一个 ID，将类名的第一个字母变为小写（SgtPeppers 设置为 sgtPeppers），如果要自己设置不同的 ID，则在 SgtPeppers 类注解 @Component 中配置 ID 名，如 1234@Component("lonelyHeartsClub")public class SgtPeppers implements CompactDisc&#123; ...&#125; 或者使用 @Named 注解也可以，但是通常使用 @Component 1234@Named("lonelyHeartsClub")public class SgtPeppers implements CompactDisc&#123; ...&#125; 设置组件扫描基础包如果没有为 @ComponentScan 设置任何属性，它会以配置类所在的包作为基础包（base package）来扫描组件（扫描）。如果想将装配类放在单独的包中跟其他的应用代码进行区分，那么默认基础包将不能满足要求。 为了指定不同的基础包，可以在 @ComponentScan 的 value 属性中指明包的名称： 1234@Configuration@ComponentScan("soundsystem)public class CDPlayerConfig &#123;&#125; 如果为了更清楚地表明设置的是基础包，可以通过 basePackages 属性进行配置： 1234@Configuration@ComponentScan(basePackages="soundsystem")public class CDPlayerConfig &#123;&#125; 若要设置多个基础包，可以将 basePackages 属性设置为需要扫描包的数组即可： 1234@Configuration@ComponentScan(basePackages="soundsystem","video")public class CDPlayerConfig &#123;&#125; 以上用 String 类型表示的基础包设置是类型不安全的(not type-safe)，如果重构代码的话，所指定的基础包可能会出错。 此时应用 @ComponentScan 指定包中所包含的类或接口,为 basePackageClasses 属性所设置的数组中包含了类，这些类所在的的包会作为组件扫描的基础包。 1234@Configuration@ComponentScan(basePackageClasses=(CDPlayer.class,DVDPlayer.class))public class CDPlayerConfig &#123;&#125; 为 bean 添加注解实现自动装配 CDPlayer 类中，给构造器添加 @Autowired 注解，表明当 Spring 创建 CDPlayer bean 时，会通过这个构造器来进行实例化，并且传入一个可设置给 CompactDisc 类型的 bean。 12345package com.soundsystem;public interface MediaPlayer &#123; void play();&#125; 1234567891011121314151617package com.soundsystem;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Component;@Componentpublic class CDPlayer implements MediaPlayer &#123; private CompactDisc cd; @Autowired public CDPlayer(CompactDisc cd)&#123; this.cd = cd; &#125; public void play()&#123; cd.play(); &#125;&#125; 该注解可用在构造器，也可用在属性的 Setter 方法上，CDPlayer 有一个 setCompactDisc() 方法，可以采用如下的注解装配： 1234@Autowired public void setCompactDisc(CompactDisc cd)&#123; this.cd = cd; &#125; 在 Spring 初始化 bean 后，它会尽可能满足 bean 的依赖，本例中的依赖是通过带有 @Autowired 注解声明的，@Autowired 能在构造器、Setter 方法，或者其他方法上发挥同样的作用，Spring 都会去满足方法参数上所声明的依赖。 如果有且只有一个 bean 匹配依赖需求的话，那么这个 bean 会被装配进来。但没有匹配 bean 的情况下，在应用上下文创建的时候，Spring 会抛出一个异常，为了避免异常出现可以将 @Autowired 的 required 属性设置为 false，同时代码中需进行 null 检查。 如果有多个 bean 满足依赖关系 Spring 会抛出一个异常。 Autowired 是 Spring 特有注解，可以选择 @Inject 注解（源自 Java 依赖注入规范）代替。 验证自动装配 System Rules 库 Java 单元测试如何断言(检查)控制台输出 注入 CompactDisc ，注入 CDPlayer bean 到测试代码的 player 成员变量之中（为更通用的 MediaPlayer 类型），在 play 测试方法中，可以调用 CDPlayer 的 player() 方法，断言其行为与你的预期一致 123456789101112131415161718192021222324252627282930313233343536package com.soundsystem;import static org.junit.Assert.*;import org.junit.Rule;import org.junit.Test;import org.junit.contrib.java.lang.system.StandardOutputStreamLog;import org.junit.contrib.java.lang.system.SystemOutRule;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import static org.junit.Assert.*;@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(classes=CDPlayerConfig.class)public class CDPlayerTest &#123; @Rule public final SystemOutRule log = new SystemOutRule(); @Autowired private MediaPlayer player; @Autowired private CompactDisc cd; @Test void cdShouldNotBeNull()&#123; assertNotNull(cd); &#125; @Test public void play() &#123; player.play(); assertEquals( "playing Sgt. Pepper's Lonely Hearts Club Band" + "by The Beatles\n", log.getLog(); ); &#125;&#125;]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
        <tag>IOC</tag>
        <tag>依赖</tag>
        <tag>注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis_Reply 微信自动回复]]></title>
    <url>%2F2018%2F07%2F30%2FMyBatis-Reply%2F</url>
    <content type="text"><![CDATA[实现输入关键字微信自动回复的功能添加一对多关系配置创建 command 与关联数据库 12create table command(id int primary key , name varchar(16) , description varchar(16));create table command_content (id int primary key , content varchar(2048) , command_id int, foreign key(command_id) references command(id) on delete cascade on update cascade); 查询主表的实体，将查询 sql 语句放在主表对应的 xml 文件中，将查询出的数据填充到主表对应的属性中，同时填充子表的列表 left join COMMAND_CONTENT 关联附表 COMMAND a COMMAND_CONTENT b 给表取别名，主表为 a ；附表为 b a.ID C_ID 给 a 表 ID 取别名为 C_ID 1select a.ID C_ID,a.NAME,a.DESCRIPTION,b.Id,b.CONTENT,b.COMMAND_ID from COMMAND a left join COMMAND_CONTENT b on a.ID=b.COMMAND_ID mybatis 取属性名时，用的是 ResultSet 的 getMetaData().getColumnName(column); 方法 不会取到 a.ID 的 a 前缀 如果创建了不存在的 主表 id 对应 command_id 则无法再创建新的 column 空语句可以产生提示，有了内容就无法发送 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253HTTP Status 500 – Internal Server ErrorType Exception ReportDescription The server encountered an unexpected condition that prevented it from fulfilling the request.Exceptionorg.apache.ibatis.exceptions.PersistenceException: ### Error querying database. Cause: java.lang.IllegalArgumentException: Result Maps collection does not contain value for CommandContent.Content### The error may exist in com/imooc/config/sqlxml/Command.xml### The error may involve Command.queryCommandList### The error occurred while handling results### SQL: select a.ID C_ID,a.NAME,a.DESCRIPTION,b.Id,b.CONTENT,b.COMMAND_ID from COMMAND a left join COMMAND_CONTENT b on a.ID=b.COMMAND_ID### Cause: java.lang.IllegalArgumentException: Result Maps collection does not contain value for CommandContent.Content org.apache.ibatis.exceptions.ExceptionFactory.wrapException(ExceptionFactory.java:30) org.apache.ibatis.session.defaults.DefaultSqlSession.selectList(DefaultSqlSession.java:150) org.apache.ibatis.session.defaults.DefaultSqlSession.selectList(DefaultSqlSession.java:141) com.imooc.dao.CommandDao.queryCommandList(CommandDao.java:34) com.imooc.service.QueryService.queryByCommand(QueryService.java:53) com.imooc.servlet.AutoReplyServlet.doGet(AutoReplyServlet.java:18) javax.servlet.http.HttpServlet.service(HttpServlet.java:635) javax.servlet.http.HttpServlet.service(HttpServlet.java:742) org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52)Root Causejava.lang.IllegalArgumentException: Result Maps collection does not contain value for CommandContent.Content org.apache.ibatis.session.Configuration$StrictMap.get(Configuration.java:888) org.apache.ibatis.session.Configuration.getResultMap(Configuration.java:640) org.apache.ibatis.executor.resultset.DefaultResultSetHandler.getNestedResultMap(DefaultResultSetHandler.java:1011) org.apache.ibatis.executor.resultset.DefaultResultSetHandler.applyNestedResultMappings(DefaultResultSetHandler.java:945) org.apache.ibatis.executor.resultset.DefaultResultSetHandler.getRowValue(DefaultResultSetHandler.java:918) org.apache.ibatis.executor.resultset.DefaultResultSetHandler.handleRowValuesForNestedResultMap(DefaultResultSetHandler.java:881) org.apache.ibatis.executor.resultset.DefaultResultSetHandler.handleRowValues(DefaultResultSetHandler.java:328) org.apache.ibatis.executor.resultset.DefaultResultSetHandler.handleResultSet(DefaultResultSetHandler.java:303) org.apache.ibatis.executor.resultset.DefaultResultSetHandler.handleResultSets(DefaultResultSetHandler.java:196) org.apache.ibatis.executor.statement.PreparedStatementHandler.query(PreparedStatementHandler.java:64) org.apache.ibatis.executor.statement.RoutingStatementHandler.query(RoutingStatementHandler.java:79) org.apache.ibatis.executor.SimpleExecutor.doQuery(SimpleExecutor.java:63) org.apache.ibatis.executor.BaseExecutor.queryFromDatabase(BaseExecutor.java:326) org.apache.ibatis.executor.BaseExecutor.query(BaseExecutor.java:156) org.apache.ibatis.executor.CachingExecutor.query(CachingExecutor.java:109) org.apache.ibatis.executor.CachingExecutor.query(CachingExecutor.java:83) org.apache.ibatis.session.defaults.DefaultSqlSession.selectList(DefaultSqlSession.java:148) org.apache.ibatis.session.defaults.DefaultSqlSession.selectList(DefaultSqlSession.java:141) com.imooc.dao.CommandDao.queryCommandList(CommandDao.java:34) com.imooc.service.QueryService.queryByCommand(QueryService.java:53) com.imooc.servlet.AutoReplyServlet.doGet(AutoReplyServlet.java:18) javax.servlet.http.HttpServlet.service(HttpServlet.java:635) javax.servlet.http.HttpServlet.service(HttpServlet.java:742) org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52)Note The full stack trace of the root cause is available in the server logs.Apache Tomcat/8.5.29 原因：在 Command.xml 中的 collention 属性的 ResultMap 引用 CommandContent.xml 下的 id ,引用名错误 方法：(CommandContent.ResultMap).id=”Content” (Command.Collection)ResultMap=”CommandContent.Content” 如果没有在 Configuration.xml 文件中引入 CommandContent.xml 与 Command.xml 也会产生该错误 mybatis 一对多关系的配置数据库子表内含“段子”关键词的多个内容，对应主表的“段子”的 id 。每次用户发送”段子“时，取出其中的所有内容，拼接进查询服务 QueryService 中创建的 (List)contentList 集合中，再创建随机数返回其中一条内容 12345678910111213&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;!--类似于 java package 的用法，用来区分不同项目,namespace 必须添加--&gt;&lt;!--作为子表包含具体多个内容对应主表的一个 id 然后被主表所引用--&gt;&lt;mapper namespace="CommandContent"&gt; &lt;resultMap type="com.imooc.bean.CommandContent" id="Content"&gt; &lt;id column="ID" jdbcType="INTEGER" property="id"/&gt; &lt;result column="CONTENT" jdbcType="VARCHAR" property="content"/&gt; &lt;result column="COMMAND_ID" jdbcType="VARCHAR" property="commandId"/&gt; &lt;/resultMap&gt;&lt;/mapper&gt; 1234567891011121314151617181920212223242526272829303132&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;!--类似于 java package 的用法，用来区分不同项目,namespace 必须添加--&gt;&lt;mapper namespace="Command"&gt;&lt;!--要反应一个一对多关系，需要用到在主表中引用子表列表的集合,引用CommandContent.xml 中的 Content 属性--&gt; &lt;resultMap type="com.imooc.bean.Command" id="Command"&gt; &lt;id column="C_ID" jdbcType="INTEGER" property="id"/&gt; &lt;result column="NAME" jdbcType="VARCHAR" property="name"/&gt; &lt;result column="DESCRIPTION" jdbcType="VARCHAR" property="description"/&gt; &lt;collection property="contentList" resultMap="CommandContent.Content"/&gt; &lt;/resultMap&gt; &lt;!--查询主表同时关联子表--&gt; &lt;select id="queryCommandList" parameterType="com.imooc.bean.Command" resultMap="Command"&gt; select a.ID C_ID,a.NAME,a.DESCRIPTION,b.Id,b.CONTENT,b.COMMAND_ID from COMMAND a left join COMMAND_CONTENT b on a.ID=b.COMMAND_ID &lt;!--where 关键字指，在其中的 if 语句都不满足条件则不输出 where 关键字，反之，有一个 if 满足则输出 where + if 中语句--&gt; &lt;!--where 还能将 if 拼接的 sql 语句最前端的 and 去掉，防止语句不准确--&gt; &lt;where&gt; &lt;if test="name != null &amp;amp;&amp;amp; !&amp;quot;&amp;quot;.equals(name.trim()) "&gt; and a.NAME=#&#123;name&#125; &lt;/if&gt; &lt;if test="description != null and !&amp;quot;&amp;quot;.equals(description.trim()) "&gt; and a.DESCRIPTION like '%' #&#123;description&#125; '%' &lt;/if&gt; &lt;/where&gt; &lt;/select&gt;&lt;/mapper&gt; 以上两个 xml 要引入到 Configuration.xml 中 将原来的单条信息查询改为一对多的数据查询1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package com.imooc.service;import com.imooc.bean.Command;import com.imooc.bean.CommandContent;import com.imooc.bean.Message;import com.imooc.dao.CommandDao;import com.imooc.dao.MessageDao;import com.imooc.util.Iconst;import java.util.List;import java.util.Random;public class QueryService &#123; //调用 MessageDao 进行数据操作，再由 ListServlet 调用。将值返回给 ListServlet public List&lt;Message&gt; queryMessageList(String command, String description)&#123; MessageDao messageDao = new MessageDao(); return messageDao.queryMessageList(command,description); &#125; /** * 通过指令查询自动回复内容 */ public String queryByCommand(String command)&#123;// MessageDao messageDao = new MessageDao(); CommandDao commandDao = new CommandDao();// List&lt;Message&gt; messageList; List&lt;Command&gt; commandList; if(Iconst.HELP_COMMAND.equals(command))&#123;// 如果指令是帮助，则将所有指令查出来并拼接；// messageList = messageDao.queryMessageList(null, null); commandList = commandDao.queryCommandList(null, null); StringBuilder result = new StringBuilder();// for(int i= 0;i &lt; messageList.size();i++)&#123; for(int i= 0;i &lt; commandList.size();i++)&#123; //如果不是第一行则添加换行 if(i !=0)&#123; result.append("&lt;br/&gt;"); &#125;// 拼接所有查询出来的指令及描述// result.append("回复[" + messageList.get(i).getCommand() + "]可以查看"// + messageList.get(i).getDescription()); result.append("回复[" + commandList.get(i).getName() + "]可以查看" + commandList.get(i).getDescription()); &#125; return result.toString(); &#125; //只需要通过指令，不需要描述来查询自动回复,如果为 null 则不进入 if 判断语句，不会添加 and sql 语句// messageList = messageDao.queryMessageList(command, null);// if(messageList.size() &gt; 0)&#123;// return messageList.get(0).getContent();// &#125; commandList = commandDao.queryCommandList(command, null); if(commandList.size() &gt; 0)&#123; //取得第一条查询语句的 子表集合内容/列表信息 List&lt;CommandContent&gt; contentList = commandList.get(0).getContentList(); //取得列表信息其中一条返回 //取 [0,size()) 的随机数 int i = new Random().nextInt(contentList.size());// 取得随机的 commandContent 的对象，然后从对象中取得内容 return contentList.get(i).getContent(); &#125; //当指令没有匹配的回复内容时，用此内容替代 return Iconst.NO_MATCHING_CONTENT; &#125;&#125; 自动回复 servlet 将跳转功能转换为 写查询返回语句的功能 123456789101112131415161718192021222324252627package com.imooc.servlet;import com.imooc.service.QueryService;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;public class AutoReplyServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; resp.setContentType("text/html;charset=utf-8"); PrintWriter out = resp.getWriter(); QueryService queryService = new QueryService(); out.write(queryService.queryByCommand(req.getParameter("content"))); out.flush(); out.close(); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; this.doGet(req,resp); &#125;&#125; 常用标签 where 标签 where标签 在其中的 if 语句都不满足条件则不输出 where 关键字，反之，有一个 if 满足则输出 where + if 中语句where 还能将 if 拼接的 sql 语句最前端的 and 去掉，防止语句不准确 123456select ID,COMMAND,DESCRIPTION,CONTENT from MESSAGE where 1=1 &lt;if test="command != null &amp;amp;&amp;amp; !&amp;quot;&amp;quot;.equals(command.trim()) "&gt; and COMMAND=#&#123;command&#125; &lt;/if&gt; &lt;if test="description != null and !&amp;quot;&amp;quot;.equals(description.trim()) "&gt; and DESCRIPTION like '%' #&#123;description&#125; '%' &lt;/if&gt; 去掉 where 1=1 ，但是加上 where 标签即可 1234567select ID,COMMAND,DESCRIPTION,CONTENT from MESSAGE&lt;where&gt; &lt;if test="command != null &amp;amp;&amp;amp; !&amp;quot;&amp;quot;.equals(command.trim()) "&gt; and COMMAND=#&#123;command&#125; &lt;/if&gt; &lt;if test="description != null and !&amp;quot;&amp;quot;.equals(description.trim()) "&gt; and DESCRIPTION like '%' #&#123;description&#125; '%' &lt;/if&gt;&lt;/where&gt; include 引用标签 1select ID,COMMAND,DESCRIPTION,CONTENT from MESSAGE 语句能用以下语法代替 12select &lt;include refid="columns"/&gt; from MESSAGE&lt;sql id="columns"&gt;ID,COMMAND,DESCRIPTION,CONTENT&lt;/sql&gt; set 标签 修改升级数据库的功能 1update MESSAGE set COMMAND=#&#123;command&#125;,DESCRIPTION=#&#123;description&#125; update 标签 为了使 sql 语句结尾的 ‘,’ 不多余加入了 set 标签，效果跟 where 去 and 类似，能去掉语句最后多余的 ‘,’ 123456789101112&lt;update id=""&gt; &lt;set&gt; update MESSAGE set &lt;if test="command != null &amp;amp;&amp;amp; !&amp;quot;&amp;quot;.equals(command.trim()) "&gt; COMMAND=#&#123;command&#125;, &lt;/if&gt; &lt;if test="description != null and !&amp;quot;&amp;quot;.equals(description.trim()) "&gt; and DESCRIPTION=#&#123;description&#125;, &lt;/if&gt; COMMAND=#&#123;command&#125;,DESCRIPTION=#&#123;description&#125; &lt;/set&gt;&lt;/update&gt; trim标签 trim 标签中的 prefix 属性，表示前缀，可以等于 where/set…（可自定义）如果各种判断结束有字符串输出就加入 where/set… trim 标签中的 suffix 属性，表示后面，可以加 test 或自定义 ，如果 if 中有内容输出就在最后加一个 test trim 标签的 prefixOverride 属性，表示删除前面内容，例如 prefixOverride=”and/or” 如果在前面出现了and 与 or 则切掉，同理 suffixOverride=”,” 可以去除结尾的 ‘,’ 12345当 prefix 值为 where 且能去掉首部的 and/or，该 trim 能替换 where 标签&lt;trim prefix="where" prefixOverride="and/or"&gt;&lt;/trim&gt;同理当 prefix 值为 set 且去掉尾部的 ','，该 trim 能替换 set 标签&lt;trim prefix="set" suffixOverride=","&gt;&lt;/trim&gt; choose 标签 chosse when 相当于 java 中的 else if，又或者是 switch case choose otherwise 相当于 else，或者是 default 123456789101112131415161718select ID,COMMAND,DESCRIPTION,CONTENT from MESSAGE&lt;where&gt; &lt;if test="command != null &amp;amp;&amp;amp; !&amp;quot;&amp;quot;.equals(command.trim()) "&gt; and COMMAND=#&#123;command&#125; &lt;/if&gt; &lt;if test="description != null and !&amp;quot;&amp;quot;.equals(description.trim()) "&gt; and DESCRIPTION like '%' #&#123;description&#125; '%' &lt;/if&gt; &lt;choose&gt; &lt;when test=""&gt; &lt;/when&gt; &lt;when test=""&gt; &lt;/when&gt; &lt;when test=""&gt; &lt;/when&gt; &lt;when test=""&gt; &lt;/when&gt; &lt;otherwise&gt;&lt;/otherwise&gt; &lt;/choose&gt;&lt;/where&gt; association 标签 需要根据子表内容查询相关联的主表内容，association 与 collection 标签相似 。 property 为 bean 中主表实体的引用，resultMap 指向主表的 nameSpace.(resultMap 的 id) 1&lt;association property="command" resultMap="Command.Command"/&gt; 标签总结 定义 sql 语句 insert，delete，update，select 配置 java 对象属性与查询结果集中列名的对应关系（列名不是数据库表中的列名，而是查询结果集的列名） resultMap 动态拼接 sql 语句 foreach，if，choose 格式化输出（动态拼接 sql 语句不符合 sql 语法，对该语法进行格式化） where，set，trim 配置关联关系（一对多，多对一） collention，association 常量标签（可在需要地方引用他） sql 引用标签（引用常量标签） include resultMap 使用标签配置对应关系，结果集列名与 java 类属性名可以不相同，有 typeHandler 可以配置字符集 resultType 不需要进行配置，但是结果集中的列名与 java 类中的属性名相同 parameterType 与 ognl 表达式相关联 #{} parameterMap 与 resultMap 相似，需要指向 ParameterMap 标签配置的映射关系的 id 。表示参数中的属性与数据库列的对应关系。 以 Map 结尾表示映射，需要配置映射关系 Type 结尾表示类型，resultType 与 parameterType 原名 resultClass 与 parameterClass，与 java 类类似 #{} 被 mybatis 解析为 ？，然后被 preparedStatement 赋值为 ‘段子’，有预编译效果，一半采用该方法 ${} 直接被 mybatis 拼接 字符串 （String）段子，没有引号，需要自己添加单引号 ‘${command}’ ${} 一般用于取直接从页面上传过来的列名进行操作 常见错误 sql 语法错误：使用 log4j 查看拼接后的 sql 语句，将其复制到 nativeMysql 中，将值赋给 ？的占位符，进行 sql 语句的判断 注解型 sql 比 配置型 sql 方便，但是有局限性 编码问题 ：文件本身编码、jsp 设置编码、servlet 接受页面传值，用来转换的编码、用 get 方式提交中文时，tomcat 也要配置编码 网页乱码 : 在talk.jsp上方加上 12&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt;&lt;%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c" %&gt; 若以上全部配置好，而与数据库交互出现乱码，则在 Configuration.xml 写连接数据库的 url 时，就需要加上编码方式、建立数据库与建表时的编码也需要注意获取自增主键值： useGeneratedKeys : 表示插入到这张表时采用生成的主键,而不是自己指定一个主键，Command 这个类的其他属性值来自于页面，而 id 是自增的，所以页面中没有 id 值 keyProperty : mybatis 会取到新增数据的主键，keyProperty 用来告诉 mybatis 将主键存到 Command 对象的哪一个属性中，这里的主键应该是 id. 在 Command 对象传入 xml 时，id 是没有值的，在 sqlSession 调用配置中 sql 语句执行完后，id 就有值了 在talk.jsp上方加上 12&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt;&lt;%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c" %&gt; 123&lt;insert id="insert" userGeneratedKeys="ture" property="id" parameterType="com.imooc.bran.Command"&gt; insert into COMMAND(NAME,DESCRIPTION) value(#&#123;name&#125;,#&#123;description&#125;)&lt;/insert&gt; 向 js 文件中传地址： 添加一个隐藏块，通过 id 与 value 向 js 中传入 basePath 的值 idea rename 一个类： 在一个类上右键 refactor → rename → 修改类名 → 取消 Search in Comments and strings (在评论和字符串中搜索) 跟 Search for textoccurrences (搜索文本事件) → 选择 variable name 点击 ok 即可 如果不取消 2 个勾选，rename 会无效。 选择 variable name 会使得子类重命名在调用该类对象的对象名]]></content>
      <categories>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>MyBatis</tag>
        <tag>autoReply</tag>
        <tag>weChat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jdbcToMyBatis]]></title>
    <url>%2F2018%2F07%2F25%2FjdbcToMyBatis%2F</url>
    <content type="text"><![CDATA[css 设置不显示问题： 将 resources 放入了 WEB-INF 文件夹中（这文件夹中的内容只能根据内部跳转或重定向等网页操作才能访问，不能直接访问） request.getContextPath() 获取的是上下文路径。是你的web项目的根路径，就是 webContent (MyEclipse中是webRoot) 或者 idea 中的 web 路径 拼装当前网页相对路径 url-pattern 配置 此文为 jdbc 版，如已了解直接转至 mybatis版 第一版大体框架 123456789101112131415161718192021222324package com.imooc.servlet;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;/** * 列表页面初始化控制 */@WebServlet(name="ListServlet" ,urlPatterns = "/List.action")public class ListServlet extends HttpServlet&#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; req.getRequestDispatcher("/WEB-INF/jsp/back/list.jsp").forward(req,resp); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; this.doGet(req, resp); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;&lt;%--拼接当前网页相对路径--%&gt;&lt;% String path = request.getContextPath(); String basePath = request.getScheme()+"://"+request.getServerName()+":"+request.getServerPort()+path;%&gt;&lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /&gt;&lt;meta http-equiv="X-UA-Compatible"content="IE=9; IE=8; IE=7; IE=EDGE" /&gt;&lt;title&gt;内容列表页面&lt;/title&gt;&lt;%--css 文件的相对路径--%&gt;&lt;link href="resources/css/all.css" rel="stylesheet" type="text/css" /&gt;&lt;/head&gt;&lt;body style="background: #e1e9eb;"&gt; &lt;form action="" id="mainForm" method="post"&gt; &lt;div class="right"&gt; &lt;div class="current"&gt;当前位置：&lt;br/&gt; &lt;a href="javascript:void(0)" style="color:#6E6E6E;"&gt; 内容管理 &lt;/a&gt; &amp;gt; 内容列表 &lt;/div&gt; &lt;div class="rightCont"&gt; &lt;p class="g_title fix"&gt;内容列表 &lt;a class="btn03" href="#"&gt;新 增&lt;/a&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;a class="btn03" href="#"&gt;删 除&lt;/a&gt; &lt;/p&gt; &lt;table class="tab1"&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td width="90" align="right"&gt;演示字段1：&lt;/td&gt; &lt;td&gt; &lt;input type="text" class="allInput" value=""/&gt; &lt;/td&gt; &lt;td width="90" align="right"&gt;演示字段2：&lt;/td&gt; &lt;td&gt; &lt;input type="text" class="allInput" value=""/&gt; &lt;/td&gt; &lt;td width="85" align="right"&gt; &lt;input type="submit" class="tabSub" value="查 询" /&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;div class="zixun fix"&gt; &lt;table class="tab2" width="100%"&gt; &lt;tbody&gt; &lt;tr&gt; &lt;th&gt;&lt;input type="checkbox" id="all" onclick="#"/&gt;&lt;/th&gt; &lt;th&gt;序号&lt;/th&gt; &lt;th&gt;演示字段1&lt;/th&gt; &lt;th&gt;演示字段2&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;input type="checkbox" /&gt;&lt;/td&gt; &lt;td&gt;1&lt;/td&gt; &lt;td&gt;演示值1&lt;/td&gt; &lt;td&gt;演示值2&lt;/td&gt; &lt;td&gt; &lt;a href="#"&gt;修改&lt;/a&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;a href="#"&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr style="background-color:#ECF6EE;"&gt; &lt;td&gt;&lt;input type="checkbox" /&gt;&lt;/td&gt; &lt;td&gt;2&lt;/td&gt; &lt;td&gt;演示值1&lt;/td&gt; &lt;td&gt;演示值2&lt;/td&gt; &lt;td&gt; &lt;a href="#"&gt;修改&lt;/a&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;a href="#"&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;input type="checkbox" /&gt;&lt;/td&gt; &lt;td&gt;3&lt;/td&gt; &lt;td&gt;演示值1&lt;/td&gt; &lt;td&gt;演示值2&lt;/td&gt; &lt;td&gt; &lt;a href="#"&gt;修改&lt;/a&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;a href="#"&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr style="background-color:#ECF6EE;"&gt; &lt;td&gt;&lt;input type="checkbox" /&gt;&lt;/td&gt; &lt;td&gt;4&lt;/td&gt; &lt;td&gt;演示值1&lt;/td&gt; &lt;td&gt;演示值2&lt;/td&gt; &lt;td&gt; &lt;a href="#"&gt;修改&lt;/a&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;a href="#"&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;div class='page fix'&gt; 共 &lt;b&gt;4&lt;/b&gt; 条 &lt;a href='###' class='first'&gt;首页&lt;/a&gt; &lt;a href='###' class='pre'&gt;上一页&lt;/a&gt; 当前第&lt;span&gt;1/1&lt;/span&gt;页 &lt;a href='###' class='next'&gt;下一页&lt;/a&gt; &lt;a href='###' class='last'&gt;末页&lt;/a&gt; 跳至&amp;nbsp;&lt;input type='text' value='1' class='allInput w28' /&gt;&amp;nbsp;页&amp;nbsp; &lt;a href='###' class='go'&gt;GO&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011121314151617181920212223&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd" version="3.1"&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt;/*此处可用 servlet 中的注释代替*/ &lt;!--&lt;servlet&gt;--&gt; &lt;!--&lt;servlet-name&gt;ListServlet&lt;/servlet-name&gt;--&gt; &lt;!--&lt;servlet-class&gt;com.imooc.servlet.ListServlet&lt;/servlet-class&gt;--&gt; &lt;!--&lt;/servlet&gt;--&gt; &lt;!--&lt;servlet-mapping&gt;--&gt; &lt;!--&lt;servlet-name&gt;ListServlet&lt;/servlet-name&gt;--&gt; &lt;!--访问 http://localhost:8080/List.action 后跳转到 list.jsp 页面--&gt; &lt;!--&lt;url-pattern&gt;/List.action&lt;/url-pattern&gt;--&gt; &lt;!--&lt;/servlet-mapping&gt;--&gt;&lt;/web-app&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package com.imooc.bean;public class Message &#123; /** * 主键 */ private String id; /** * 指令名称 */ private String command; /** * 描述 */ private String description; /** * 内容 */ private String content; public String getId() &#123; return id; &#125; public void setId(String id) &#123; this.id = id; &#125; public String getCommand() &#123; return command; &#125; public void setCommand(String command) &#123; this.command = command; &#125; public String getDescription() &#123; return description; &#125; public void setDescription(String description) &#123; this.description = description; &#125; public String getContent() &#123; return content; &#125; public void setContent(String content) &#123; this.content = content; &#125;&#125; 第一版完善 完善 list.jsp 及 ListSerlvet.java 的相关部分 sql 语句 1234567891011//sql preparedstatement 语句// ? 占位符// 用缺省值的方式，使用 List 在后面遍历填充字段信息比较方便stringsql = "select * from people p where p.id = ? and p.name = ?";preparedstatement ps = connection.preparestatement(sql);//设置缺省值的值//index 的值从 1 开始ps.setint(1,id);ps.setstring(2,name);//执行 sql 语句resultset rs = ps.executequery(); list.jsp 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;&lt;%--使用 jstl--%&gt;&lt;%@taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %&gt;&lt;%--拼接当前网页相对路径--%&gt;&lt;% String path = request.getContextPath(); String basePath = request.getScheme()+"://"+request.getServerName()+":"+request.getServerPort()+path;%&gt;&lt;html xmlns="http://www.w3.org/1999/xhtml"&gt; &lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /&gt; &lt;meta http-equiv="X-UA-Compatible"content="IE=9; IE=8; IE=7; IE=EDGE" /&gt; &lt;title&gt;内容列表页面&lt;/title&gt; &lt;%--css 文件的相对路径--%&gt; &lt;link href="&lt;%=basePath%&gt;/resources/css/all.css" rel="stylesheet" type="text/css" /&gt; &lt;/head&gt; &lt;body style="background: #e1e9eb;"&gt; &lt;%--提交到 ListServlet 上进行初始化与查询--%&gt; &lt;form action="&lt;%=basePath%&gt;/List.action" id="mainForm" method="post"&gt; &lt;div class="right"&gt; &lt;div class="current"&gt;当前位置：&lt;a href="javascript:void(0)" style="color:#6E6E6E;"&gt;内容管理&lt;/a&gt; &amp;gt; 内容列表&lt;/div&gt; &lt;div class="rightCont"&gt; &lt;p class="g_title fix"&gt;内容列表 &lt;a class="btn03" href="#"&gt;新 增&lt;/a&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;a class="btn03" href="#"&gt;删 除&lt;/a&gt;&lt;/p&gt; &lt;table class="tab1"&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td width="90" align="right"&gt;指令名称：&lt;/td&gt; &lt;td&gt; &lt;input name="command" type="text" class="allInput" value="$&#123;command&#125;"/&gt; &lt;/td&gt; &lt;td width="90" align="right"&gt;描述：&lt;/td&gt; &lt;td&gt; &lt;input name="description" type="text" class="allInput" value="$&#123;description&#125;"/&gt; &lt;/td&gt; &lt;td width="85" align="right"&gt;&lt;input type="submit" class="tabSub" value="查 询" /&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;div class="zixun fix"&gt; &lt;table class="tab2" width="100%"&gt; &lt;tbody&gt; &lt;tr&gt; &lt;th&gt;&lt;input type="checkbox" id="all" onclick="#"/&gt;&lt;/th&gt; &lt;th&gt;序号&lt;/th&gt; &lt;th&gt;演示字段1&lt;/th&gt; &lt;th&gt;演示字段2&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;c:forEach items="$&#123;messageList&#125;" var="message" varStatus="status"&gt; &lt;tr &lt;c:if test="$&#123;status.index % 2 != 0&#125;"&gt;style='background-color:#ECF6EE;'&lt;/c:if&gt;&gt; &lt;td&gt;&lt;input type="checkbox" /&gt;&lt;/td&gt; &lt;td&gt;$&#123;status.index + 1&#125;&lt;/td&gt; &lt;td&gt;$&#123;message.command&#125;&lt;/td&gt; &lt;td&gt;$&#123;message.description&#125;&lt;/td&gt; &lt;td&gt; &lt;a href="#"&gt;修改&lt;/a&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;a href="#"&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;div class='page fix'&gt; 共 &lt;b&gt;4&lt;/b&gt; 条 &lt;a href='###' class='first'&gt;首页&lt;/a&gt; &lt;a href='###' class='pre'&gt;上一页&lt;/a&gt; 当前第&lt;span&gt;1/1&lt;/span&gt;页 &lt;a href='###' class='next'&gt;下一页&lt;/a&gt; &lt;a href='###' class='last'&gt;末页&lt;/a&gt; 跳至&amp;nbsp;&lt;input type='text' value='1' class='allInput w28' /&gt;&amp;nbsp;页&amp;nbsp; &lt;a href='###' class='go'&gt;GO&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; ListServlet 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081package com.imooc.servlet;import com.imooc.bean.Message;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.sql.*;import java.util.ArrayList;import java.util.List;/** * 列表页面初始化控制 */@WebServlet(name="ListServlet" ,urlPatterns = "/List.action")public class ListServlet extends HttpServlet&#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; try &#123; //得到表单文本框提交的数据 req.setCharacterEncoding("utf-8"); String command = req.getParameter("command"); String description = req.getParameter("description"); //将查询完的值保留在查询栏中 req.setAttribute("command",command); req.setAttribute("description",description); Class.forName("com.mysql.jdbc.Driver"); Connection conn = DriverManager.getConnection("jdbc:mysql://127.0.0.1:3306/micro_message", "root","dfwhj43815"); StringBuilder sql = new StringBuilder("select ID,COMMAND,DESCRIPTION,CONTENT from MESSAGE where 1=1"); //创建一个 List 将需要拼接的 sql 语句查询内容装进去，最后用 for 循环取出，set 到 PreparedStatement 后执行 List&lt;String&gt; paramList = new ArrayList&lt;String&gt;(); //.trim() 方法返回一个 String 的副本，用来去除首尾的空格 if(command != null &amp;&amp; !"".equals(command.trim()))&#123; //查询sql语句拼接不用sql.append(" and command = '"+command+"'") 因为容易被SQL注入攻击 sql.append(" and COMMAND=?"); paramList.add(command); &#125; if(description != null &amp;&amp; !"".equals(description.trim()))&#123; sql.append(" and DESCRIPTION like '%' ? '%'"); paramList.add(description); &#125; PreparedStatement ps = conn.prepareStatement(sql.toString()); //在 sql 语句执行前，将参数加进去 for (int i = 0; i &lt; paramList.size(); i++) &#123; ps.setString(i + 1,paramList.get(i)); &#125; ResultSet rs = ps.executeQuery(); List&lt;Message&gt;messageList = new ArrayList&lt;Message&gt;(); while(rs.next())&#123; Message message = new Message(); //添加到容器中的不是对象本身，此时操作对象仍可以改变在容器中的内容。 //也可以将对象在最后添加到容器 message.setId(rs.getString("ID")); message.setCommand(rs.getString("COMMAND")); message.setDescription(rs.getString("DESCRIPTION")); message.setContent(rs.getString("CONTENT")); messageList.add(message); &#125; //将容器添加到 request 的 attribute 可以在页面上显示出来 req.setAttribute("messageList",messageList); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; req.getRequestDispatcher("/WEB-INF/jsp/back/list.jsp").forward(req,resp); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; this.doGet(req, resp); &#125;&#125; idea 引入 c 标签 网页有框架没有数据，提示找不到 jdbc，没有正确导入 Driver 包； You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ‘message’ at line 1 ​ at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method) at sun.reflect.NativeConstructorAccessorImpl.newInstance(Unknown Source) at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(Unknown Source) at java.lang.reflect.Constructor.newInstance(Unknown Source) Sql 语句有语法错误：from 写成了 form 第一版代码重构 将原来 servlet 的功能分出去 servlet 的功能 设置编码 接受页面的值 向页面传值 dao 层的功能 根据查询条件查询消息列表，跟表 Message 相关的所有操作都在这层 service 层的功能 调用 MessageDao 进行数据操作，再由 ListServlet 调用。将值返回给 ListServlet ListSerlvet 123456789101112131415161718192021222324252627282930313233343536373839404142package com.imooc.servlet;import com.imooc.bean.Message;import com.imooc.service.ListService;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.sql.*;import java.util.ArrayList;import java.util.List;/** * 列表页面初始化控制 */@WebServlet(name="ListServlet" ,urlPatterns = "/List.action")public class ListServlet extends HttpServlet&#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //设置编码 req.setCharacterEncoding("utf-8"); //接受页面的值 String command = req.getParameter("command"); String description = req.getParameter("description"); //向页面传值 req.setAttribute("command",command); req.setAttribute("description",description); //查询消息列表并传给页面。调用 ListService 的函数，将查询的结果放到 req 中 ListService listService = new ListService(); req.setAttribute("messageList",listService.queryMessageList(command,description)); //向页面跳转 req.getRequestDispatcher("/WEB-INF/jsp/back/list.jsp").forward(req,resp); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; this.doGet(req, resp); &#125;&#125; MessageDao 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package com.imooc.dao;import com.imooc.bean.Message;import java.sql.*;import java.util.ArrayList;import java.util.List;//Dao 层跟表相关，此 dao 包含跟 message 表相关的操作public class MessageDao &#123; /** * 根据查询条件查询消息列表 */ public List&lt;Message&gt; queryMessageList(String command,String description)&#123; List&lt;Message&gt;messageList = new ArrayList&lt;Message&gt;(); try &#123; Class.forName("com.mysql.jdbc.Driver"); Connection conn = DriverManager.getConnection("jdbc:mysql://127.0.0.1:3306/micro_message", "root","dfwhj43815"); StringBuilder sql = new StringBuilder("select ID,COMMAND,DESCRIPTION,CONTENT from MESSAGE where 1=1"); //创建一个 List 将需要拼接的 sql 语句查询内容装进去，最后用 for 循环取出，set 到 PreparedStatement 后执行 List&lt;String&gt; paramList = new ArrayList&lt;String&gt;(); //.trim() 方法返回一个 String 的副本，用来去除首尾的空格 if(command != null &amp;&amp; !"".equals(command.trim()))&#123; //查询sql语句拼接不用sql.append(" and command = '"+command+"'") 因为容易被SQL注入攻击 sql.append(" and COMMAND=?"); paramList.add(command); &#125; if(description != null &amp;&amp; !"".equals(description.trim()))&#123; sql.append(" and DESCRIPTION like '%' ? '%'"); paramList.add(description); &#125; PreparedStatement ps = conn.prepareStatement(sql.toString()); //在 sql 语句执行前，将参数加进去 for (int i = 0; i &lt; paramList.size(); i++) &#123; ps.setString(i + 1,paramList.get(i)); &#125; ResultSet rs = ps.executeQuery(); while(rs.next())&#123; Message message = new Message(); //添加到容器中的不是对象本身，此时操作对象仍可以改变在容器中的内容。 //也可以将对象在最后添加到容器 message.setId(rs.getString("ID")); message.setCommand(rs.getString("COMMAND")); message.setDescription(rs.getString("DESCRIPTION")); message.setContent(rs.getString("CONTENT")); messageList.add(message); &#125; &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return messageList; &#125;&#125; ListService 1234567891011121314package com.imooc.service;import com.imooc.bean.Message;import com.imooc.dao.MessageDao;import java.util.List;public class ListService &#123; //调用 MessageDao 进行数据操作，再由 ListServlet 调用。将值返回给 ListServlet public List&lt;Message&gt; queryMessageList(String command, String description)&#123; MessageDao messageDao = new MessageDao(); return messageDao.queryMessageList(command,description); &#125;&#125;]]></content>
      <categories>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>jdbc</tag>
        <tag>myBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis]]></title>
    <url>%2F2018%2F07%2F23%2FMyBatis%2F</url>
    <content type="text"><![CDATA[用 mybatis 替代 jdbcmybatis 下载地址 jdbc 版跳转此处 dao 层、mybatis 及 SqlSession 作用dao (data access objection 数据访问对象)层需求 ： 能与数据库交互 能执行 sql 语句 mybatis ：向 dao 层提供对象 SqlSession SqlSession 作用： 向 sql 语句传入参数 执行 sql 语句 获取执行 sql 语句的结果 事务的控制 如何得到 SqlSession： 通过配置文件获取数据库连接的相关信息 通过配置信息构建 SqlSessionFactory 通过 SqlSessionFactory 打开 数据库会话（SqlSession） 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package com.imooc.bean;public class Message &#123; /** * 主键 */ private String id; /** * 指令名称 */ private String command; /** * 描述 */ private String description; /** * 内容 */ private String content; public String getId() &#123; return id; &#125; public void setId(String id) &#123; this.id = id; &#125; public String getCommand() &#123; return command; &#125; public void setCommand(String command) &#123; this.command = command; &#125; public String getDescription() &#123; return description; &#125; public void setDescription(String description) &#123; this.description = description; &#125; public String getContent() &#123; return content; &#125; public void setContent(String content) &#123; this.content = content; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!-- Copyright 2009-2016 the original author or authors. Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.--&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;!--类似于 java package 的用法，用来区分不同项目,namespace 必须添加--&gt;&lt;mapper namespace="Message"&gt; &lt;!--对应 jdbc 的 message.setId(rs.getString("ID")); 等方法--&gt; &lt;!--type 表示的是数据库字段对应 java 中哪个类的对象；id 随意取名；--&gt; &lt;!--如果在数据库中为主键，则配 id colum,否则配 result colum 标签；--&gt; &lt;!--colum 对应数据库列的属性名；property 是数据库对应 java bean对象中的属性名--&gt; &lt;!--jdbcType 对应数据库中属性的类型 Int、varchar 等--&gt; &lt;resultMap type="com.imooc.bean.Message" id="MessageResult"&gt; &lt;id column="ID" jdbcType="INTEGER" property="id"/&gt; &lt;result column="COMMAND" jdbcType="VARCHAR" property="command"/&gt; &lt;result column="DESCRIPTION" jdbcType="VARCHAR" property="description"/&gt; &lt;result column="CONTENT" jdbcType="VARCHAR" property="content"/&gt; &lt;/resultMap&gt; &lt;!--select id 必须是唯一的，但与 resultMap 中的 id 可以重名--&gt; &lt;!--parameterType 是传入 sqlSession 的参数的属性--&gt; &lt;!--resultMap 指向 resultMap 标签的 id--&gt; &lt;!--OGNL 表达式 如果是自定义类型就直接写自定义属性的属性名（command）--&gt; &lt;!--可以从 java 对象中调用属性值 而且可以直接调用 java 对象的方法--&gt; &lt;!--但是 与符号 &amp;&amp; 需要转义成 &amp;amp;&amp;amp 或者用 OGNl 的 and 操作符--&gt; &lt;!--双引号 "" 需要转义成 &amp;quot;&amp;quot;--&gt; &lt;!--占位符 ? 需要用 #&#123;command&#125; 来替换，表示用 command 值来填充 ? 这是 mybatis 的解析规则--&gt; &lt;!--mybatis 配置中 sql 语句前后不需要留空格，会自动拼接--&gt; &lt;!--模糊查询 like 跟 '%' 保留，问号 ? 替换，问号两边依旧保留空格 --&gt; &lt;select id="queryMessageList" parameterType="com.imooc.bean.Message" resultMap="MessageResult"&gt; select ID,COMMAND,DESCRIPTION,CONTENT from MESSAGE where 1=1 &lt;if test="command != null &amp;amp;&amp;amp; !&amp;quot;&amp;quot;.equals(command.trim()) "&gt; and COMMAND=#&#123;command&#125; &lt;/if&gt; &lt;if test="description != null and !&amp;quot;&amp;quot;.equals(description.trim()) "&gt; and DESCRIPTION like '%' #&#123;description&#125; '%' &lt;/if&gt; &lt;/select&gt; &lt;!--单个删除--&gt; &lt;!--#&#123;&#125; 中的取值写法可以视为与 OGNL 相同：当参数为 String 与基本数据类型时，标签属性为 _parameter, 若为自定义类型则写自定义类型属性名--&gt; &lt;delete id="deleteOne" parameterType="int"&gt; delete from MESSAGE where ID = #&#123;_parameter&#125; &lt;/delete&gt; &lt;!--批量删除--&gt; &lt;delete id="deleteBatch" parameterType="java.util.List"&gt; delete from MESSAGE where ID in ( &lt;foreach collection="list" item="item" separator=","&gt; #&#123;item&#125; &lt;/foreach&gt; ) &lt;/delete&gt;&lt;/mapper&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!-- Copyright 2009-2016 the original author or authors. Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.--&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;!-- &lt;settings&gt; &lt;setting name="useGeneratedKeys" value="false"/&gt; &lt;setting name="useColumnLabel" value="true"/&gt; &lt;/settings&gt; &lt;typeAliases&gt; &lt;typeAlias alias="UserAlias" type="org.apache.ibatis.submitted.complex_property.User"/&gt; &lt;/typeAliases&gt; --&gt; &lt;environments default="development"&gt; &lt;environment id="development"&gt; &lt;transactionManager type="JDBC"&gt; &lt;property name="" value=""/&gt; &lt;/transactionManager&gt; &lt;dataSource type="UNPOOLED"&gt; &lt;property name="driver" value="com.mysql.jdbc.Driver"/&gt; &lt;property name="url" value="jdbc:mysql://127.0.0.1:3306/micro_message"/&gt; &lt;property name="username" value="root"/&gt; &lt;property name="password" value="dfwhj43815"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!--用来引入 sqlxml 配置文件的内容--&gt; &lt;mappers&gt; &lt;!--mapper 可以多个--&gt; &lt;mapper resource="com/imooc/config/sqlxml/Message.xml"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110package com.imooc.dao;import com.imooc.bean.Message;import com.imooc.db.DBAccess;import org.apache.ibatis.session.SqlSession;import java.io.IOException;import java.sql.*;import java.util.ArrayList;import java.util.List;//Dao 层跟表相关，此 dao 包含跟 message 表相关的操作public class MessageDao &#123; /** * mybytis 根据查询条件查询消息列表 */ public List&lt;Message&gt; queryMessageList(String command,String description)&#123; DBAccess dbAccess = new DBAccess(); //要在 final 中关闭此会话，所以放在外面 SqlSession sqlSession = null; //创建 List 将查询语句内容放进 List 中 List&lt;Message&gt;messageList = new ArrayList&lt;Message&gt;(); //捕获 DBAccess 抛出的异常 try &#123; sqlSession = dbAccess.getSqlSession(); //新建一个对象，将 command description 对象封装到对象中 Message message = new Message(); message.setCommand(command); message.setDescription(description); //通过 sqlSession 执行 查找sql 语句；值为 namespace.resultMap messageList = sqlSession.selectList("Message.queryMessageList",message); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally&#123; if(sqlSession!=null)&#123; sqlSession.close(); &#125; &#125; return messageList; &#125; /** * * 单条删除 */ public void deleteOne(int id)&#123; DBAccess dbAccess = new DBAccess(); //要在 final 中关闭此会话，所以放在外面 SqlSession sqlSession = null; //捕获 DBAccess 抛出的异常 try &#123; sqlSession = dbAccess.getSqlSession(); //通过 sqlSession 执行 删除sql 语句；值为 Message.mapper 的 namespace.resultMap sqlSession.delete("Message.deleteOne",id); //使用 mybatis 时对 commit 进行了封装，需要手动进行提交 /** * Connection conn; * 下面两条sql语句是自动提交互不影响的 * 但是将 conn.setAutoCommit(false) 设定后，下面的 sql 语句将处于一个事物中 * 需要进行 conn.commit(); 或 conn.roolback(); 才能一次性手动提交 * conn.prepareStatement("sql").execute(); * conn.prepareStetement("sql").execute(); * conn.commit(); * * * 如下的 sqlSession.commit()；实际上就是 conn.commmit(); */ sqlSession.commit(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally&#123; if(sqlSession!=null)&#123; sqlSession.close(); &#125; &#125; &#125; /** * 批量删除 */ public void deleteBatch(List&lt;Integer&gt; ids)&#123; DBAccess dbaccess = new DBAccess(); SqlSession sqlsession = null; try &#123; sqlsession = dbaccess.getSqlSession(); //执行删除语句 sqlsession.delete("Message.deleteBatch",ids); sqlsession.commit(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; // public static void main(String[] args) &#123;// MessageDao messageDao = new MessageDao();// messageDao.queryMessageList("","");//// &#125;&#125; 123456789101112131415161718192021222324package com.imooc.db;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import java.io.IOException;import java.io.Reader;/** * 访问数据库类 */public class DBAccess &#123; public SqlSession getSqlSession() throws IOException &#123; //通过配置文件获取数据库连接信息 Reader reader = Resources.getResourceAsReader("com/imooc/config/Configuration.xml"); //通过配置信息构建一个 SqlSessionFactory SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(reader); //通过 sqlSessionFactory 打开一个数据库会话 SqlSession sqlSession = sqlSessionFactory.openSession(); return sqlSession; &#125;&#125; 1234567891011121314package com.imooc.service;import com.imooc.bean.Message;import com.imooc.dao.MessageDao;import java.util.List;public class ListService &#123; //调用 MessageDao 进行数据操作，再由 ListServlet 调用。将值返回给 ListServlet public List&lt;Message&gt; queryMessageList(String command, String description)&#123; MessageDao messageDao = new MessageDao(); return messageDao.queryMessageList(command,description); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.imooc.service;import com.imooc.dao.MessageDao;import java.util.ArrayList;import java.util.List;/** * 维护 Service * 维护相关业务的功能 * 页面的一个动作对应了一个 Servlet ；而 Service 不应该同时增加 * 把相似的功能（修改，新增，删除，批量删除等）放在一个维护 Service 中 * 以后可以一直添加新功能 * * 将取值的转型及判断是否为空 都放在 Service 中进行 */public class MaintainService &#123; /** * 单条删除 */ public void deleteOne(String id)&#123; //判断 id 是否为空，或 空字符串 if(id != null &amp;&amp; !"".equals(id.trim())) &#123; MessageDao messageDao = new MessageDao(); //将 id 从 String 转型为 int 并作为参数传入 deleteOne 函数 messageDao.deleteOne(Integer.valueOf(id)); &#125; &#125; /** * 批量删除 */ public void deleteBatch(String [] ids)&#123; MessageDao messageDao = new MessageDao(); //创建 id 的 List List&lt;Integer&gt; idList = new ArrayList&lt;Integer&gt;(); for (String id : ids) &#123; //转型为 Integer 再传入 List if(id!=null &amp;&amp; !"".equals(id.trim())) &#123; idList.add(Integer.valueOf(id)); &#125; &#125; //调用 messageDao 的 deleteBatch 方法 messageDao.deleteBatch(idList); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142package com.imooc.servlet;import com.imooc.bean.Message;import com.imooc.service.ListService;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.sql.*;import java.util.ArrayList;import java.util.List;/** * 列表页面初始化控制 */@WebServlet(name="ListServlet" ,urlPatterns = "/List.action")public class ListServlet extends HttpServlet&#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //设置编码 req.setCharacterEncoding("utf-8"); //接受页面的值 String command = req.getParameter("command"); String description = req.getParameter("description"); //向页面传值 req.setAttribute("command",command); req.setAttribute("description",description); //查询消息列表并传给页面。调用 ListService 的函数，将查询的结果放到 req 中 ListService listService = new ListService(); req.setAttribute("messageList",listService.queryMessageList(command,description)); //向页面跳转 req.getRequestDispatcher("/WEB-INF/jsp/back/list.jsp").forward(req,resp); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; this.doGet(req, resp); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435package com.imooc.servlet;import com.imooc.service.ListService;import com.imooc.service.MaintainService;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;/** * 单条删除控制层 */public class DeleteOneServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //设置编码 req.setCharacterEncoding("utf-8"); //接受页面的值 String id = req.getParameter("id"); MaintainService maintainService = new MaintainService(); //需要接受的参数为 int 但是判断接受的值是否为空以及转型应该在 Service 中进行 maintainService.deleteOne(id); //向页面跳转 直接跳转到 list.jsp 会使得列表全部消失；列表初始化需要 listServlet 进行一些操作 //所以应该先跳到 listServlet// req.getRequestDispatcher("/WEB-INF/jsp/back/list.jsp").forward(req,resp); req.getRequestDispatcher("/List.action").forward(req,resp); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; this.doGet(req, resp); &#125;&#125; 1234567891011121314151617181920212223242526272829package com.imooc.servlet;import com.imooc.service.MaintainService;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;/** * 批量删除控制层 */public class DeleteBatchServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; req.setCharacterEncoding("utf-8"); MaintainService maintainService = new MaintainService(); String[] ids = req.getParameterValues("id"); maintainService.deleteBatch(ids); //页面跳转 req.getRequestDispatcher("/List.action").forward(req,resp); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; this.doGet(req,resp); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;&lt;%--使用 jstl--%&gt;&lt;%@taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %&gt;&lt;%--拼接当前网页相对路径--%&gt;&lt;% String path = request.getContextPath(); String basePath = request.getScheme()+"://"+request.getServerName()+":"+request.getServerPort()+path;%&gt;&lt;html xmlns="http://www.w3.org/1999/xhtml"&gt; &lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /&gt; &lt;meta http-equiv="X-UA-Compatible"content="IE=9; IE=8; IE=7; IE=EDGE" /&gt; &lt;title&gt;内容列表页面&lt;/title&gt; &lt;link href="&lt;%=basePath%&gt;/resources/css/all.css" rel="stylesheet" type="text/css" /&gt; &lt;script src="&lt;%=basePath %&gt;/resources/js/common/jquery-1.8.0.min.js"&gt;&lt;/script&gt; &lt;script src="&lt;%=basePath %&gt;/resources/js/back/list.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; function deleteOne(path,id)&#123; if(confirm("确定要删除吗？"))&#123; document.getElementById("id").value=id; document.getElementById("mainForm").action = path+"/DeleteOneServlet.action"; document.getElementById("mainForm").submit(); &#125; &#125; &lt;/script&gt; &lt;/head&gt; &lt;body style="background: #e1e9eb;"&gt; &lt;%--提交到 ListServlet 上进行初始化与查询--%&gt; &lt;form action="&lt;%=basePath%&gt;/List.action" id="mainForm" method="post" &gt; &lt;div class="right"&gt; &lt;div class="current"&gt;当前位置：&lt;a href="javascript:void(0)" style="color:#6E6E6E;"&gt;内容管理&lt;/a&gt; &amp;gt; 内容列表&lt;/div&gt; &lt;div class="rightCont"&gt; &lt;p class="g_title fix"&gt; 内容列表 &lt;a class="btn03" href="#"&gt; 新 增 &lt;/a&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;a class="btn03" href="javascript:deleteBatch('&lt;%=basePath%&gt;');"&gt; 删 除 &lt;/a&gt; &lt;/p&gt; &lt;table class="tab1"&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td width="90" align="right"&gt;指令名称：&lt;/td&gt; &lt;td&gt; &lt;input name="command" type="text" class="allInput" value="$&#123;command&#125;"/&gt; &lt;/td&gt; &lt;td width="90" align="right"&gt;描述：&lt;/td&gt; &lt;td&gt; &lt;input name="description" type="text" class="allInput" value="$&#123;description&#125;"/&gt; &lt;/td&gt; &lt;td width="85" align="right"&gt;&lt;input type="submit" class="tabSub" value="查 询" /&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;div class="zixun fix"&gt; &lt;table class="tab2" width="100%"&gt; &lt;tbody&gt; &lt;tr&gt; &lt;th&gt;&lt;input type="checkbox" id="all" onclick="#"/&gt;&lt;/th&gt; &lt;th&gt;序号&lt;/th&gt; &lt;th&gt;演示字段1&lt;/th&gt; &lt;th&gt;演示字段2&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;input type="hidden" id="id" name="id" /&gt; &lt;c:forEach items="$&#123;messageList&#125;" var="message" varStatus="status"&gt; &lt;tr &lt;c:if test="$&#123;status.index % 2 != 0&#125;"&gt;style='background-color:#ECF6EE;'&lt;/c:if&gt;&gt; &lt;%--value 值与下面的 id 表达式相同--%&gt; &lt;td&gt;&lt;input type="checkbox" name="id" value="$&#123;message.id&#125;"/&gt;&lt;/td&gt; &lt;td&gt;$&#123;status.index + 1&#125;&lt;/td&gt; &lt;td&gt;$&#123;message.command&#125;&lt;/td&gt; &lt;td&gt;$&#123;message.description&#125;&lt;/td&gt; &lt;td&gt; &lt;a href="#"&gt;修改&lt;/a&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;%--使用 get 方法提交，不适合隐私信息及中文信息提交--%&gt; &lt;%--&lt;a href="$&#123;basePath&#125;/DeleteOneServlet.action?id=$&#123;message.id&#125;"&gt;删除&lt;/a&gt;--%&gt; &lt;%--&lt;a href="$&#123;basePath&#125;/DeleteOneServlet.action?id=$&#123;message.id&#125;"--%&gt; &lt;%--onclick="return confirm('确定要删除这条信息吗？');"&gt;删除&lt;/a&gt;--%&gt; &lt;a href="#" onclick="deleteOne('$&#123;pageContext.request.contextPath&#125;',$&#123;message.id&#125;)"&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;div class='page fix'&gt; 共 &lt;b&gt;4&lt;/b&gt; 条 &lt;a href='###' class='first'&gt;首页&lt;/a&gt; &lt;a href='###' class='pre'&gt;上一页&lt;/a&gt; 当前第&lt;span&gt;1/1&lt;/span&gt;页 &lt;a href='###' class='next'&gt;下一页&lt;/a&gt; &lt;a href='###' class='last'&gt;末页&lt;/a&gt; 跳至&amp;nbsp;&lt;input type='text' value='1' class='allInput w28' /&gt;&amp;nbsp;页&amp;nbsp; &lt;a href='###' class='go'&gt;GO&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 123456789程序未报错，但 tomcat 连接后直接停止：Connected to the target VM, address: &apos;127.0.0.1:10605&apos;, transport: &apos;socket&apos;Disconnected from the target VM, address: &apos;127.0.0.1:10605&apos;, transport: &apos;socket&apos;解决方法：把 main 测试函数注释掉，通过 tomcat 发布文件 12345678910&lt;script type="text/javascript"&gt; function deleteOne(path,id)&#123; if(confirm("确定要删除吗？"))&#123; document.getElementById("id").value=id; //将路径首字母小写会使函数失效，这里对应的是web.xml 配置的 url //"/deleteOneServlet.action" document.getElementById("mainForm").action = path+"/DeleteOneServlet.action"; document.getElementById("mainForm").submit(); &#125; &#125; &lt;/script&gt; 123456789idea 未报错，点击删除，批量删除无效，网页前台控制台报错：Uncaught ReferenceError: deleteBatch is not defined at &lt;anonymous&gt;:1:1 解决：DeleteBatchServlet 后忘记加 .action 应将其提交到 web.xml 配置的 url 上$(&quot;#mainForm&quot;).attr(&quot;action&quot;,basePath+&quot;/DeleteBatchServlet.action&quot;);//此处 name = &quot;id&quot; 而不是 id = &quot;id&quot;,而且不加 value 时，checkbox 选中时返回的值是 on&lt;td&gt;&lt;input type=&quot;checkbox&quot; name=&quot;id&quot; value=&quot;$&#123;message.id&#125;&quot;/&gt;&lt;/td&gt; 12345678910111213141516171819202122232425262728网页报错：Type Exception ReportMessage For input string: &quot;&quot;Description The server encountered an unexpected condition that prevented it from fulfilling the request.Exceptionjava.lang.NumberFormatException: For input string: &quot;&quot; java.lang.NumberFormatException.forInputString(Unknown Source) java.lang.Integer.parseInt(Unknown Source) java.lang.Integer.valueOf(Unknown Source) com.imooc.service.MaintainService.deleteBatch(MaintainService.java:41) com.imooc.servlet.DeleteBatchServlet.doGet(DeleteBatchServlet.java:17) com.imooc.servlet.DeleteBatchServlet.doPost(DeleteBatchServlet.java:25) javax.servlet.http.HttpServlet.service(HttpServlet.java:661) javax.servlet.http.HttpServlet.service(HttpServlet.java:742) org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52)Note The full stack trace of the root cause is available in the server logs.问题：ids 在接受值时 String[] ids = req.getParameterValues(&quot;id&quot;);会多出一个 index[0] = &quot;&quot;;解决： 在 service 中判断是否为空 if(id!=null &amp;&amp; !&quot;&quot;.equals(id.trim())) &#123; idList.add(Integer.valueOf(id)); &#125; 123456789101112131415点击删除后，页面跳转到 http://localhost:8080/DeleteBatchServlet.action但是没有删除所选中的几条值日志：2018-07-27 12:54:52,186 [http-nio-8080-exec-3] DEBUG [Message.deleteBatch] - ==&gt; Preparing: delete from MESSAGE where ID in( ? , ? ) 2018-07-27 12:54:52,187 [http-nio-8080-exec-3] DEBUG [Message.deleteBatch] - ==&gt; Parameters: 5(Integer), 6(Integer)2018-07-27 12:54:52,188 [http-nio-8080-exec-3] DEBUG [Message.deleteBatch] - &lt;== Updates: 22018-07-27 12:54:52,226 [http-nio-8080-exec-3] DEBUG [Message.queryMessageList] - ==&gt; Preparing: select ID,COMMAND,DESCRIPTION,CONTENT from MESSAGE where 1=1 2018-07-27 12:54:52,227 [http-nio-8080-exec-3] DEBUG [Message.queryMessageList] - ==&gt; Parameters: 2018-07-27 12:54:52,229 [http-nio-8080-exec-3] DEBUG [Message.queryMessageList] - &lt;== Total: 3解决：messageDao 中传入的参数类型错误，应该为 List&lt;Integer&gt;idspublic void deleteBatch(List&lt;Integer&gt; ids) idea 导入本地 jar 包源码的方法idea 导入本地 jar 包源码 log4j 中的代码意义log4j.appender.Console.layout.ConversionPattern=%d [%t] %-5p [%c] - %m%n %d 日志生成的时间 %t 是产生日志所处的线程名称 %p 输出日志的级别，%-5p 将占5位字符，不足5位用空格填补，- 指的是在右边补空 %c 你输出日志的包以及类的全名 %m 是你附加的信息 %n 换行 代码实现demo 源码]]></content>
      <categories>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AnnTest java 注解]]></title>
    <url>%2F2018%2F07%2F18%2FAnnTest%2F</url>
    <content type="text"><![CDATA[运行机制划分注解 源码注解：只在源码中存在，编译成 .class 文件就不存在了。 编译时注解：注解在源码和 .class 文件中都存在 @Override @Deprecated @Suppvisewarning @Override ：表示覆写了某一个方法 @Deprecated ：表示一个方法已经过期，可用 @Suppvisewarning 忽略警告 运行时注解：在运行阶段还起作用，甚至会影响运行逻辑的注解。 @Autowired 1234567891011package com.ann.test;public class Test &#123; //忽略方法中的方法过期警告，也可以放在类外，忽略整个类的过期警告 @SuppressWarnings("deprecation") public void sing()&#123; Person p = new Child(); p.sing(); &#125;&#125; 123456789package com.ann.test;public interface Person &#123; public String name(); public int age(); //提示方法已过期 @Deprecated public void sing();&#125; 解析注解1234元注解RetentionPolicy，表明注解的生命周期：1、SOURCE：在原文件中有效，被编译器丢弃。 2、CLASS：在class文件有效，可能会被虚拟机忽略。 3、RUNTIME：在运行时有效。 @Inherited 元注解是一个标记注解，@Inherited阐述了某个被标注的类型是被继承的。 如果一个使用了@Inherited修饰的annotation类型被用于一个class，则这个annotation将被用于该class的子类。 注意：@Inherited annotation类型是被标注过的class的子类所继承。类并不从它所实现的接口继承annotation， 方法并不从它所重载的方法继承annotation。 @Inherited 对接口没作用，只会继承类 123456789101112package com.ann.test;import java.lang.annotation.*;import java.util.Map;//自定义注解，在 Child 中使用@Target(&#123;ElementType.METHOD,ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Inherited@Documentedpublic @interface Description &#123; String value();&#125; 12345678910111213141516171819package com.ann.test;@Description("i am class annotation")public class Child implements Person &#123; @Override @Description("i am method annotation") public String name() &#123; return null; &#125; @Override public int age() &#123; return 0; &#125; @Override public void sing() &#123; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.ann.test;import java.lang.annotation.Annotation;import java.lang.reflect.Method;//只能取到运行时加载public class PraseAnn &#123; public static void main(String[] args) &#123; try &#123; //使用类加载器加载类 Class c = Class.forName("com.ann.test.Child"); //找到类上的注解 boolean isExist = c.isAnnotationPresent(Description.class); if(isExist)&#123; //拿到注解实例 Description d = (Description) c.getAnnotation(Description.class); System.out.println(d.value()); &#125; //找到方法上的注解 Method[] ms = c.getMethods(); for (Method m : ms) &#123; boolean isMExist = m.isAnnotationPresent(Description.class); if(isMExist)&#123; Description d = m.getAnnotation(Description.class); System.out.println(d.value()); &#125; &#125; //另一种解析方法 for (Method m : ms) &#123; Annotation[]as = m.getAnnotations(); for (Annotation a : as) &#123; if(a instanceof Description)&#123; Description d = (Description) a; System.out.println(d.value()); &#125; &#125; &#125; &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 运行 PraseAnn 输出结果 i am class annotationi am method annotationi am method annotation java 注解 Element 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192package com.imooc.test;@Table("user")public class Filter &#123; /** Column column = field.getAnnotation(Column.class);得到的是字段上注解内容，然后通过 String columnName = column.value();得到就是此注解下的字段名， @Column("id") （好比上面的 column，不过只是比如column是一个注解对象） private int id; （columnName 就得到的是 id ） @Table("数据库中的表名") @Column("数据库中的列名/字段名:id/user_name...") */ @Column("id") private int id; @Column("user_name") private String userName; @Column("nick_name") private String nickName; @Column("age") private int age; @Column("city") private String city; @Column("email") private String email; @Column("mobile") private String mobile; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getUserName() &#123; return userName; &#125; public void setUserName(String userName) &#123; this.userName = userName; &#125; public String getNickName() &#123; return nickName; &#125; public void setNickName(String nickName) &#123; this.nickName = nickName; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getCity() &#123; return city; &#125; public void setCity(String city) &#123; this.city = city; &#125; public String getEmail() &#123; return email; &#125; public void setEmail(String email) &#123; this.email = email; &#125; public String getMobile() &#123; return mobile; &#125; public void setMobile(String mobile) &#123; this.mobile = mobile; &#125;&#125; 123456789101112131415package com.imooc.test;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;//作用域：类或接口@Target(&#123;ElementType.TYPE&#125;)//生命周期：运行时@Retention(RetentionPolicy.RUNTIME)public @interface Table &#123; //使用值只有一个：表名 user String value();&#125; 1234567891011121314package com.imooc.test;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;//作用域：字段、枚举的常量@Target(&#123;ElementType.FIELD&#125;)//生命周期：运行时有效@Retention(RetentionPolicy.RUNTIME)public @interface Column &#123; String value();&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485package com.imooc.test;import java.io.ObjectInputStream;import java.lang.reflect.Field;import java.lang.reflect.Method;public class Test &#123; public static void main(String[] args) &#123; Filter f1 = new Filter(); f1.setId(10);//查询 id 为 10 的用户 Filter f2 = new Filter(); f2.setUserName("lucy");//查询用户名为 lucy 的用户 Filter f3 = new Filter(); f3.setEmail("liu@sina.com,zh@163.com,77777@qq.com");//查询邮箱为其中任意一个用户 String sql1 = query(f1); String sql2 = query(f2); String sql3 = query(f3); System.out.println(sql1); System.out.println(sql2); System.out.println(sql3); &#125; private static String query(Filter f)&#123; StringBuilder sb = new StringBuilder(); //获取 class Class c = f.getClass(); //获取 table 的名字 boolean exists = c.isAnnotationPresent(Table.class); if(!exists)&#123; return null; &#125; Table t = (Table) c.getAnnotation(Table.class); String tableName = t.value(); /** * 例如为不定数量的查询条件，我们在后台写查询的时候， 类似于这样的语句 string sql ="select * from table where" 为了使语句通顺不报错，加上 where 1=1 */ sb.append("select * form").append(tableName).append("where 1=1"); //遍历所有的字段 Field[] fArray = c.getDeclaredFields(); for (Field field : fArray) &#123; //处理每个字段对应的 sql //拿到字段名 boolean fExists = field.isAnnotationPresent(Column.class); if(!fExists)&#123; continue; &#125; Column column = field.getAnnotation(Column.class); String columnName = column.value(); //拿到字段值 String filedName = field.getName(); String getMethodName = "get" + filedName.substring(0,1).toUpperCase()+filedName.substring(1); //通过反射取得 method System.out.println(getMethodName); Object fieldValue = null; try &#123; Method getMethod = c.getMethod(getMethodName); fieldValue = getMethod.invoke(f); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; //拼装 sql if(fieldValue==null ||(fieldValue instanceof Integer &amp;&amp; (Integer)fieldValue==0))&#123; continue; &#125; sb.append(" and ").append(filedName); if(fieldValue instanceof String)&#123; sb.append("=").append("'").append(columnName).append("'"); &#125;else if(fieldValue instanceof Integer) &#123; sb.append("=").append(columnName); &#125; &#125; return sb.toString(); &#125;&#125;]]></content>
      <categories>
        <category>Annotation</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>注解</tag>
        <tag>imooc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Reflection 反射]]></title>
    <url>%2F2018%2F07%2F17%2Factive-class%2F</url>
    <content type="text"><![CDATA[反射指的是可以于运行时加载,探知和使用编译期间完全未知的类. 程序在运行状态中, 可以动态加载一个只有名称的类, 对于任意一个已经加载的类,都能够知道这个类的所有属性和方法; 对于任意一个对象,都能调用他的任意一个方法和属性; 加载完类之后, 在堆内存中会产生一个Class类型的对象(一个类只有一个Class对象), 这个对象包含了完整的类的结构信息,而且这个Class对象就像一面镜子,透过这个镜子看到类的结构,所以被称之为:反射。 不是所有的实例化都是 new ，new 时必须知道这个类是什么，而很多时候做不到预先知道类名，很多框架如 Spring 应用了反射的原理。 new 创建的对象是 静态加载类，在编译时就需要加载所有可能用到的类，若在编译时找不到类直接报错。一个功能有问题，其他功能都无法使用。 class 为类类型/字节码（编译后的类） OfficeBetter.java 1234567891011121314151617181920212223class OfficeBetter&#123; public static void main(String args [])&#123; try&#123; //动态加载类，在运行时加载 Class c = Class.forName(args[0]); OfficeAble oa = (OfficeAble)c.newInstance(); oa.start(); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; &#125;&#125; OfficeAble.java 1234567interface OfficeAble&#123; //创建接口，由使用者来实现该接口,重写 start 方法 public void start();&#125; Word.java 123456789class Word implements OfficeAble&#123; public void start()&#123; System.out.println("word--starts"); &#125;&#125; 编译 javac *.java 运行 java OfficeBetter Word (main 类 + 实现接口类) 输出结果 word–starts 获取类的信息首先要获取类的类类型 Class c1 = int.class; //int 的类类型 String c2 = String.class //String 的类类型 void c3 = void.class System.out.println(c1.getName()); //打印包含包名的类的名称 System.out.println(c2.getSimpleName()); //打印不包含包名的类的名称 System.out.println(c3.getName()); //打印结果：void 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package com.imooc.reflect;public class ClassUtil &#123; public static void PrintClassMessage(Object obj) &#123; //传递的是哪个子类的对象，c 就是该子类的类类型 Class c = obj.getClass(); //getMethods() 获取所有 public 的函数，包括父类继承而来的 //getDeclaredMethods() 获取的是该类自己声明的方法，不问访问权限； Method [] ms = c.getMethods(); for(int i = 0; i &lt; ms.length; i++)&#123; //得到方法返回值类型的类类型 Class returnType = ms[i].getReturnType(); System.out.print(returnType.getName()+""); //得到方法的名称 System.out.print(ms[i].getName()+"("); //获取参数类型，得到的是参数列表的类型的类类型 Class [] paramTypes = ms[i].getParameterTypes(); for(Class class1:paramTypes)&#123; System.out.print(class1.getName()+","); &#125; System.out.println(")"); &#125; public static void printFieldMessage(Object obj) &#123; Class c = obj.getClass(); //成员变量也是对象； Field[] fs = c.getDeclaredFields(); for (Field field : fs) &#123; Class fieldType = field.getType(); String typeName = fieldType.getName(); //得到成员变量名称 String fieldName = field.getName(); System.out.println(typeName + " " + fieldName); &#125; &#125; //打印对象的构造函数信息 public static void printConMessage(Object obj)&#123; Class c = obj.getClass(); /*构造函数也是对象 java.lang.Constructor 封装了构造函数的信息 getConstructors 获取所有的 public 的构造函数 Constructor []cs = c.getConstructors(); */ Constructor [] cs = c.getDeclaredConstructors(); for (Constructor constructor : cs) &#123; System.out.print(constructor.getName()+"("); //获取构造函数的参数列表--&gt;得到的是参数列表的类类型 Class[] parameterTypes = constructor.getParameterTypes(); for (Class class1 : parameterTypes) &#123; System.out.print(class1.getName()+","); &#125; System.out.println(")"); &#125; &#125;&#125; 1234567891011package com.imooc.reflect;//PrintClassMessage 方法测试类public class ClassDemo3 &#123; public static void main(String[] args) &#123; String s = &quot;hello&quot;; ClassUtil.PrintClassMessage(s); Integer n1 = 1; ClassUtil.PrintClassMessage(n1); &#125;&#125; 123456789package com.imooc.reflect;//printieldMessage() 方法测试类public class ClassDemo4 &#123; public static void main(String[] args) &#123; ClassUtil.printFieldMessage(&quot;hello&quot;); System.out.println(&quot;==========&quot;); ClassUtil.printFieldMessage(new Integer(1)); &#125;&#125; 12345678package com.imooc.reflect;//printConMessage() 方法测试类public class ClassDemo5 &#123; public static void main(String[] args) &#123; ClassUtil.printConMessage(&quot;hello&quot;); ClassUtil.printConMessage(new Integer(1)); &#125;&#125; 方法的反射操作method.invoke(对象，参数列表) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package com.imooc.reflect;import java.lang.reflect.Method;public class MethodDemo1 &#123; public static void main(String[] args) &#123; //获取print(int a,int b)方法，获取一个方法就是获取类的信息，获取类的信息就要获得类的类类型 A a1 = new A(); Class c = a1.getClass(); /** * 获取方法 名称和参数决定 * getMethod 获取的是 public 的方法 * getDelcaredMethod 自己声明的方法 */ try &#123; Method m = c.getMethod("print", int.class, int.class);// 或 Method m = c.getMethod("pirnt", new Class[]&#123;int.class, int.class&#125;); /** * 方法的反射操作 * a1.print(10,20); 方法的反射操作是用 m 对象来进行方法的调用 和 a1.print 调用效果完全相同 * 方法没有返回值，则返回 null ，有返回值则返回具体的返回值 */ Object o = m.invoke(a1, new Object[]&#123;10, 20&#125;); System.out.println("==========="); //获取方法对象 Method m1 = c.getMethod("print", String.class, String.class); //用方法进行反射操作 o = m1.invoke(a1, "Hello", "Word"); System.out.println("==========="); Method m2 = c.getMethod("print"); //或 Method m1 = c.getMethod("print", new Class[]&#123;&#125;); m2.invoke(a1); // 或m2.invoke(a1,new Object[]&#123;&#125;); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125;class A&#123; public void print(int a,int b)&#123; System.out.println(a+b); &#125; public void print(String a,String b)&#123; System.out.println(a.toUpperCase() + "," + b.toLowerCase()); &#125; public void print()&#123; System.out.println("hello Word"); &#125;&#125; 通过反射了解泛型本质class 为类类型/字节码（编译后的类） class/method 等反射操作都是绕过编译的操作 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.imooc.reflect;import java.lang.reflect.Method;import java.util.ArrayList;public class MethodDemo4 &#123; public static void main(String[] args) &#123; ArrayList list = new ArrayList(); //泛型，只能放 String 类型； //防止加入 list1.add(10); 这种操作 ArrayList&lt;String&gt;list1 = new ArrayList&lt;&gt;(); list1.add("hello"); Class c1 = list.getClass(); Class c2 = list1.getClass(); System.out.println(c1 == c2); /** * 反射的操作都是编译之后的操作（跳过编译阶段） * c1 == c2 返回 true 说明编译之后的集合泛型是去泛型化的 * java 中集合的泛型是防止错误输入，只在编译阶段有效，绕过编译就无效 * 验证：通过方法反射操作，绕过编译 */ Method m = null; try &#123; m = c2.getMethod("add", Object.class); m.invoke(list1,10);//绕过编译操作就绕过了泛型 System.out.println(list1.size()); /** * for (String string : list1) &#123; System.out.println(string); &#125; 此时遍历会发生错误异常，提示不能将 int 转换成 String * java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String */ &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>imooc</tag>
        <tag>reflection</tag>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo next 搭建博客]]></title>
    <url>%2F2018%2F07%2F11%2Fblog-create%2F</url>
    <content type="text"><![CDATA[hexo 安装插入图片： node_modules：是依赖包public：存放的是生成的页面scaffolds：命令生成文章等的模板source：用命令创建的各种文章themes：主题_config.yml：整个博客的配置db.json：source解析所得到的package.json：项目所需模块项目的配置信息 接下来依次在命令行输入hexo ghexo s 在浏览器中打开http://localhost:4000/，看到网页则配置结束 将Hexo与github page 联系起来 设置Git的user name和email：(如果是第一次的话) git config --global user.name &quot;crow-song&quot;git config --global user.email &quot;crowsong.end@gmail.com&quot; 设置 ssh 密钥参考：https://blog.csdn.net/love_fdu_llp/article/details/38752365 https://jingyan.baidu.com/article/a65957f4e91ccf24e77f9b11.html 检查本机是否有ssh key设置 $ cd ~/.ssh 或cd .ssh 如果没有则提示： No such file or directory 如果有则进入~/.ssh路径下（ls查看当前路径文件，rm * 删除所有文件) ssh-keygen -t rsa -C &quot;crowsong.end@gmail.com&quot; 生成密钥对 之后全部 enter 就行 秘钥存放路径为：c:/Users/xxxx_000/.ssh/下 查看你生成的公钥：$ cat ~/.ssh/id_rsa.pub 复制公钥到 github 账户的 AccountSettings → SSHKeys → 点击 new SSH Key title 随意填写，公钥复制进文本域内 点击确定 确认设置 验证下这个key是不是正常工作。 $ ssh -T git@github.com # Attempts to ssh to github 键入 yes 看到： Hi username! You’ve successfully authenticated, but GitHub does not # provide shell access. 就表示设置成功。 接下来使用 hexo d 不再需要输入用户和密码了 配置Deployment同样在_config.yml文件中，找到Deployment，然后按照如下修改：repo 中是仓库地址（自己的 git 发布网址） deploy: type:git repo:https://crow-song.github.io/ branch:master 写博客新建一篇博客，执行下面的命令： hexo new post “article title” 这时候在我的 电脑的目录下 ..\hexo\source\ _posts 将会看到 article title.md 文件 用MarDown编辑器打开就可以编辑文章了。文章编辑好之后，运行生成、部署命令： hexo g hexo d 参考：https://blog.csdn.net/gdutxiaoxu/article/details/53576018 hexo的next主题个性化教程 Typora md文档多标签样式： tags: 博客创建 hexo 修改 css 样式，找到目标对应 css 文件，修改 background:#transparent （面板透明色） rgba(255,255,255,.9) 添加网易云音乐插件 在 mian.xxxx.css 中设置位置 .header-music {margin-top: 55px;margin-left: 0px; } nofollw 作用 添加图片 可用样式为 图片放在对应 md 文件的文件夹中 添加链接： ctrl+k 添加背景图： 将括号里面的这里填写背景图片地址替换为你所要显示的背景图片地址，#ffffff表示背景颜色为#ffffff(白色)修改为你想要的背景颜色代码，repeat表示图片平铺，不平铺改为no-repeat，scroll表示图片随对象滚动，图片固定不滚动改为fixed。 头像旋转放大： hover 选择器使用 选择鼠标移到链接上的样式 xxx:hover(xxx 可以是 img 也可以是类选择器等。如果直接使用 img:hover 会将插入图片一起放大) .site-author-image:hover 设置网站图标 Favicon 设置网站图标时使用 ico 图片会无法正常显示，使用 32*32 png 图片即可 Typora markdown 语法 设置标签随机大小与颜色 设置过程中出现 jQuery 报错：Uncaught ReferenceError: $ is not defined 可以添加 jQuery 引用 网站 debug 通过但部署后报错：(index):1 Mixed Content: The page at ‘https://crow-song.github.io/tags/&#39; was loaded over HTTPS, but requested an insecure script ‘http://libs.baidu.com/jquery/1.9.0/jquery.js&#39;. This request has been blocked; the content must be served over HTTPS. 将其 http 改为 https github fork 别人的博客后 404 错误https://github.com/qiubaiying/qiubaiying.github.io/issues/98在code下找到CNAME文件，将里面的内容改为：https://你的Github账号名.github.io，然后点底部的commit changes，应该就可以了 hexo d 或 hexo deploy 无反应解决: 配置文档中 _config.yml 冒号后需要加空格deploy:type: gitrepo: https://github.com/crow-song/crow-song.github.io.gitbranch: master hexo g 错误ERROR Process failed: _posts/article-title.mdYAMLException: can not read a block mapping entry; a multiline key may not be an implicit key at line 4, column 1:md 文档中开头 3 个标题冒号后也需要加空格title: article titledate: 2018-07-11 23:09:21tags: 博客创建]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>博客创建</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
