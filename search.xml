<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[SomeProblem]]></title>
    <url>%2F2018%2F12%2F11%2FSomeProblems%2F</url>
    <content type="text"><![CDATA[serlvet 提交 post 乱码解决方法： request.setCharacterEncoding(“UTF-8”); 或者使用先编后解码方式解决 Jquery post 提交已经自动进行过编解码，不需要再写，如果二次编解码反而会乱码 get 提交乱码： 先编码再解码 JQuery get 中文提交乱码： 先编码后解码]]></content>
      <tags>
        <tag>java</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springMVC32]]></title>
    <url>%2F2018%2F10%2F30%2FspringMVC32%2F</url>
    <content type="text"><![CDATA[大致流程流程参考：IDEA整合SSM框架：Spring+SpringMVC+Mybatis 入门 Springmvc 流程 Web 工程 导入 jar 包 web.xml 中配置前端控制器（指定上下文路径 classpath：springmvc.xml） 拦截规则 拦截所有（包括 Jsp）：/* 拦截除了 JSP 以外部分 : / .action 或 .do springmvc.xml 配置扫描 @controller 注解 Action Controller Handler 处理器 需要写的部分：类上@Controller 方法上 @RequestMapping（Value=请求的路径）.action 可以省略 Public ModelAndView itemList(){ ​ new ModelAndView ​ 设置数据 ​ 设置 JSP 页面路径（跳转路径 /WEB-INF/jsp/xxx.jsp） } 架构分析一个中心 三个基本点 前端控制器（在 web.xml 中配置） 处理器映射器 处理器适配器 视图解释器 由 Springmvc 提供 Handler 处理器 JSP 视图（页面，即 html 标签） 由程序员书写 默认三大组件默认三大组件已废弃 现组件：RequestMappingHandlerMapping (处理器映射器) RequestMappingHandlerAdapter (处理器适配器) 可用 &lt;mvc:anonation-driver/&gt; 代替 处理器映射器 和 处理器适配器的配置 视图解释器 用来优化 JSP 页面的路径书写 /WEB-INF/jsp/xxx.jsp 可以拼接 xxx 的前后缀 整合 mybatis SqlMapConfig.xml 核心配置文件（别名） applicationContent.xml 数据源 druid （替代 JDBC）读取 db.properties Mybatis 的工厂以及 Mybaits Mapper 动态代理开发的扫描方式 扫描基本包 创建 db.properties 文件 事务、扫描@Service Spring+Mybatis 创建 Springmvc.xml 三大组件 扫描基本包（com.itheima 包下 controller 与 Service 全扫描） web.xml 文件中配置监听器读取 applicationContext.xml 上下文 配置前端控制器读取 Spingmvc.xml 配置 POST 提交乱码 Fittler 过滤器 参数绑定 默认参数绑定 Request Response Session Model 实现关系 ModelMap 简单类型参数绑定 方法的形参上（Integer id String Double double Boolean） POJO 类型 Items items input name = name name 与 items 对象中属性名一致 包装类型 QueryVo （内含 Items） Query Vo items.name （传参方式） 自定义参数格式 转换日期：在 Springmvc.xml 配置转换器的工厂 Converters list set array 创建自定义转换器类 实现 Converter&lt;S,T&gt; Strus2 与 Springmvc 区别 入口 Servlet 与 Fittler 单例 多例 值 Request域 controller 返回值 ModelAndView 万能的 带数据 返回视图路径后结束 String 只能返回视图路径 需要通过方法传参数 Model model，通过 model 带数据 request.setAttribute(),model.addAttribute(“itemsList”,list); 官方推荐 符合解耦合 数据 视图 分离 MVC void ajax 请求 适合返回 json 格式数据（response 异步请求使用，不用刷页面） 重定向与内部转发区别重定向的页面在提交后会跳转到 重定向的路径（网址） 内部转发的页面在提交后不会跳转 会在修改页面的路径（网址） SpringMVC 三大组件 处理器映射器（HandlerMapping）、视图解析器(ViewResolver) 、处理器适配器(HandlerAdapter) 三大组件的默认配置文件 /springmvc32/web/WEB-INF/lib/spring-webmvc-4.1.3.RELEASE.jar!/org/springframework/web/servlet/DispatcherServlet.properties 在 springmvc 的配置文件中修改默认配置 springmvc.xml 123456789101112131415161718&lt;!--扫描 @Controller @Service --&gt; &lt;context:component-scan base-package="com.itheima"&gt;&lt;/context:component-scan&gt; &lt;!-- 处理器映射器 --&gt; &lt;!--&lt;bean class="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping"/&gt;--&gt; &lt;!-- 处理器适配器 --&gt; &lt;!--&lt;bean class="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter"/&gt;--&gt; &lt;!-- 注解驱动:可以替代以上两个配置 --&gt; &lt;mvc:annotation-driven/&gt; &lt;!-- 视图解析器 --&gt; &lt;!-- 跟 ItemController 的 setViewName 中的内容拼接成完整地址 --&gt; &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix" value="/WEB-INF/jsp/"/&gt; &lt;property name="suffix" value=".jsp"/&gt; &lt;/bean&gt; ItemServiceImpl 中实现接口，并覆写实现方法 将方法放到接口 ItemService controller 控制层中 @RequestMapping(value=”/网页中的 form 中 action 相对地址”) jsp 中 input 的 name 属性中的内容与接受的 Items（bean）的 name 属性一致 jsp 页面上的 name 属性名的参数绑定与 Controller 中传入的 POJO 形参名无关，而是属性名与 POJO 对象中的成员变量名一致 ​ 但是如果将 POJO 进行了包装，将 Items 类封装到 Vo 类中，Vo 类中有着获取、修改 Items 类的方法，则在 jsp 页面的 name 属性名的参数绑定将变为 Items.（Items 类中的成员变量名） 例如：Items.name Q&amp;AQ1: idea 编译出现 “文档中根元素后面的标记必须格式正确” 字样错误提示A: 这个错误一般是元素未正确结束，或者出现未知元素造成的 . 提示这行不代表就是这行，提示是告诉你这个元素有问题，这个元素下面的任何子元素都可能存在问题 错误点：未将 等代码放入 栏 Q2: 运行后网页提示错误：​ org.xml.sax.SAXParseException; lineNumber: 10; columnNumber: 9; cvc-complex-type.2.3: 元素 ‘beans’ 必须不含字符 [子级], 因为该类型的内容类型为“仅元素”。 A: 在 标签中多了一个 、 Q3: debug 报错：​ org.apache.jasper.servlet.TldScanner.scanJars At least one JAR was scanned for TLDs yet contained no TLDs. Enable debug logging for this logger for a complete list of JARs that were scanned but no TLDs were found in them. Skipping unneeded JARs during scanning can improve startup time and JSP compilation time. A: 在apache-tomcat-8.5.29\conf目录下找到logging.properties文件，对文件进行编辑，在最后一行加入： 1234567891011121314151617181920212223242526272829303132333435这样就不再显示错误信息了。http://blog.51cto.com/lavasoft/2087440##### Q4: Tomcat 8报错 SEVERE: One or more listener failed to start​ 06-Nov-2018 17:26:46.429 信息 [RMI TCP Connection(3)-127.0.0.1] org.apache.jasper.servlet.TldScanner.scanJars At least one JAR was scanned for TLDs yet contained no TLDs. Enable debug logging for this logger for a complete list of JARs that were scanned but no TLDs were found in them. Skipping unneeded JARs during scanning can improve startup time and JSP compilation time.​ 06-Nov-2018 17:26:46.465 严重 [RMI TCP Connection(3)-127.0.0.1] org.apache.catalina.core.StandardContext.startInternal One or more listeners failed to start. Full details will be found in the appropriate container log file​ 06-Nov-2018 17:26:46.468 严重 [RMI TCP Connection(3)-127.0.0.1] org.apache.catalina.core.StandardContext.startInternal Context [] startup failed due to previous errorsA: &gt; Full details will be found in the appropriate container log file 意思是让我们在日志文件中查看详细报错信息，那日志文件在哪里呢？这里如果我们是使用idea调试，则日志文件存放在C:\Users\Administrator\.IntelliJIdea2017.1\system\tomcat\Unnamed_SpringMVCDemo\logs 详细问题在 logs 文件夹的几个日志文件中参考：https://blog.csdn.net/dkbnull/article/details/81605157 &gt; If you are using IntelliJ IDEA, and deploy application on Tomcat Server, it says: Under File menu -&gt; select project Structure -&gt; click artifact -&gt; select your jars and right click -&gt; put in WEB\lib -&gt; restart server参考：https://stackoverflow.com/questions/6210757/java-lang-classnotfoundexception-org-springframework-web-context-contextloaderl##### Q5: 启动服务后网页报错```javaorg.springframework.beans.factory.BeanCreationException: Error creating bean with name &apos;itemController&apos;: Injection of autowired dependencies failed; nested exception is org.springframework.beans.factory.BeanCreationException: Could not autowire field: private com.itheima.springmvc.service.ItemService com.itheima.springmvc.controller.ItemController.itemService; nested exception is org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of type [com.itheima.springmvc.service.ItemService] found for dependency: expected at least 1 bean which qualifies as autowire candidate for this dependency. Dependency annotations: &#123;@org.springframework.beans.factory.annotation.Autowired(required=true)&#125; A: spring在管理创建bean的时候发生了错误，一是检查注解是否正确@Service;二是看看web.xml中配置的 spring容器的 xml 文件是否错误 未添加 ItemServiceImpl 的 @Service 注释 参考：https://blog.csdn.net/zxz9325/article/details/79179444 Q6: HTTP Status 500 – Internal Server Error Type Exception Report Message Request processing failed; nested exception is java.lang.NumberFormatException: null Description The server encountered an unexpected condition that prevented it from fulfilling the request. Exception 1org.springframework.web.util.NestedServletException: Request processing failed; nested exception is java.lang.NumberFormatException: null A: 应该打开查询网页 http://localhost:8080/itemEdit.action 而非直接打开 http://localhost:8080/item/itemEdit.action，无法直接访问，而且没有传 id 导致为空 Q7: 运行后显示 404Type Status Report Description The origin server did not find a current representation for the target resource or is not willing to disclose that one exists. A: http://blog.csdn.net/DBC_121/article/details/79204340 @requestMapping(value=””) 中 value 地址书写错误 Q8:HTTP Status 400 – Bad RequestType Status Report Description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). A: jsp 页面上的 name 属性名的参数绑定与 Controller 中传入的 POJO 形参名无关，而是属性名与 POJO 对象中的成员变量名一致,如果不一致则在后台获取不到参数 Q9:jsp 页面 name 属性名应与 POJO 内部成员变量一致HTTP Status 500 – Internal Server Error Type Exception Report Message Request processing failed; nested exception is java.lang.NullPointerException Description The server encountered an unexpected condition that prevented it from fulfilling the request. A: 将 POJO 进行包装后没有在 jsp 页面进行 name 属性修改 如果将 POJO 进行了包装，将 Items 类封装到 Vo 类中，Vo 类中有着获取、修改 Items 类的方法，则在 jsp 页面的 name 属性名的参数绑定将变为 Items.（Items 类中的成员变量名） 例如：Items.name Q10:自定义异常错误HTTP Status 500 – Internal Server Error Type Exception Report Message Request processing failed; nested exception is java.lang.ClassCastException: java.lang.ArithmeticException cannot be cast to com.itheima.springmvc.exception.MessageException Description The server encountered an unexpected condition that prevented it from fulfilling the request. Exception 12345678910org.springframework.web.util.NestedServletException: Request processing failed; nested exception is java.lang.ClassCastException: java.lang.ArithmeticException cannot be cast to com.itheima.springmvc.exception.MessageException org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:978) org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:857) javax.servlet.http.HttpServlet.service(HttpServlet.java:635) org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:842) javax.servlet.http.HttpServlet.service(HttpServlet.java:742) org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52) org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:88) org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) org.apache.logging.log4j.core.web.Log4jServletFilter.doFilter(Log4jServletFilter.java:66) Root Cause 123456789101112131415java.lang.ClassCastException: java.lang.ArithmeticException cannot be cast to com.itheima.springmvc.exception.MessageException com.itheima.springmvc.exception.CustomExceptionResolver.resolveException(CustomExceptionResolver.java:19) org.springframework.web.servlet.DispatcherServlet.processHandlerException(DispatcherServlet.java:1167) org.springframework.web.servlet.DispatcherServlet.processDispatchResult(DispatcherServlet.java:1004) org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:955) org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:877) org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:966) org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:857) javax.servlet.http.HttpServlet.service(HttpServlet.java:635) org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:842) javax.servlet.http.HttpServlet.service(HttpServlet.java:742) org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52) org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:88) org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) org.apache.logging.log4j.core.web.Log4jServletFilter.doFilter(Log4jServletFilter.java:66) Note The full stack trace of the root cause is available in the server logs. A： 12345678910ModelAndView mav = new ModelAndView();if(e instanceof MessageException)&#123; MessageException me = (MessageException)e; mav.addObject("error",me.getMsg());&#125;else &#123; mav.addObject("error", "未知异常");&#125;mav.setViewName("error");return mav; Tips：intelj idea 添加本地 xsd 文件​ intellij idea配置外部dtd文件 ​ 打开file——Settings..(快捷键ctrl+alt+s); ​ 找到Languages&amp;Frameworks——Schemas and DTDs ​ 找到右侧的External Schemas and DTDs窗口中点击添加按钮 ​ 在 Explorer 栏找到下载好的外部 dtd 文件 ​ 在 URI 栏可以填入从 xml 文件头上找到的相对应约束 URI ​ intelj idea jar 包 导入​ 导入 jar 包 3种方法 intelj idea 中的 mybatis 逆向工程​ Mybatis在IDEA中使用generator逆向工程生成pojo,mapper ​ 12345// servlet 开发// String id = request.getParameter("id");// Items items = itemService.selectItemsById(Integer.parseInt(id));// Spring 底层还是使用 request 的 getParameter 方法获取 id 的值的，但是我们不需要自己去写，并且会自动帮我们转换 Int 类型 Items items = itemService.selectItemsById(id); Springmvc 与 Strus2 的区别参数绑定区别​ Strus2 绑定参数在类的属性（ Action 的成员变量上） ​ Springmvc 从客户端请求 key/value 数据，通过参数绑定，将其绑定在 controller 方法的形参上 ​ SpringMVC中的参数绑定总结 存储数据区别​ Springmvc 使用 ModelAndView.addObject(“”,””); ​ 底层是 request.setAttribute(“”,””); 存在 request 的域中，没有值栈概念 ​ Strus2 有值栈概念 入口区别​ Springmvc 入口是 servlet 前端控制器 ​ Strus2 是过滤器 filter 模式区别​ Springmvc 是单例模式（以方法为单位，每次请求复制一个方法副本） ​ Strus2 是多例模式（以类为单位，每个请求创建一个类） 代码实现简易 springmvc 代码 Springmvc-mybatis]]></content>
      <categories>
        <category>SpringMvc</category>
      </categories>
      <tags>
        <tag>spring springmvc mybatis Maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linuxInstall]]></title>
    <url>%2F2018%2F09%2F12%2FlinuxInstall%2F</url>
    <content type="text"><![CDATA[linux 无法使用 ifconfig https://www.cnblogs.com/dunitian/p/4974761.html ：使用新指令 ip 没有 ifcfg-eth0 ，可能为 ifcfg-ens33 或其他 https://hk.saowen.com/a/227c3c22a44418b6927076afcd72c05d41291f7d0e9dc7fa60031b591d9bedbc Centos 下安装与设置VIM编辑器]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[黑马 Spring]]></title>
    <url>%2F2018%2F09%2F03%2FHMSpring%2F</url>
    <content type="text"><![CDATA[maven dependency 机制 idea 无法导入 jdbcjdbcDaosupport 解决 Project Structure－&gt;Facets 配置。添加spring配置文件的模块 参考： https://blog.csdn.net/tiantiandjava/article/details/41204607 Caused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name ‘accountService’ defined in class path resource [applicationContext.xml]: Initialization of bean failed; nested exception is org.springframework.beans.ConversionNotSupportedException: Failed to convert property value of type ‘com.mchange.v2.c3p0.ComboPooledDataSource’ to required type ‘cn.itcast.dao.AccountDao’ for property ‘ad’; nested exception is java.lang.IllegalStateException: Cannot convert value of type ‘com.mchange.v2.c3p0.ComboPooledDataSource’ to required type ‘cn.itcast.dao.AccountDao’ for property ‘ad’: no matching editors or conversion strategy found xml 配置中需要将 accountDao 注入到 accountService ， 将 dataSource（连接池） 注入到 accountDao Caused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name ‘transactionManager’ defined in class path resource [applicationContext.xml]: BeanPostProcessor before instantiation of bean failed; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name ‘org.springframework.aop.support.DefaultBeanFactoryPointcutAdvisor#0’: Cannot resolve reference to bean ‘txPc’ while setting bean property ‘pointcut’; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name ‘txPc’: Lookup method resolution failed; nested exception is java.lang.IllegalStateException: Failed to introspect Class [org.springframework.aop.aspectj.AspectJExpressionPointcut] from ClassLoader [sun.misc.Launcher$AppClassLoader@b4aac2] Caused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name ‘org.springframework.aop.support.DefaultBeanFactoryPointcutAdvisor#0’: Cannot resolve reference to bean ‘txPc’ while setting bean property ‘pointcut’; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name ‘txPc’: Lookup method resolution failed; nested exception is java.lang.IllegalStateException: Failed to introspect Class [org.springframework.aop.aspectj.AspectJExpressionPointcut] from ClassLoader [sun.misc.Launcher$AppClassLoader@b4aac2] Caused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name ‘txPc’: Lookup method resolution failed; nested exception is java.lang.IllegalStateException: Failed to introspect Class [org.springframework.aop.aspectj.AspectJExpressionPointcut] from ClassLoader [sun.misc.Launcher$AppClassLoader@b4aac2] 加粗语句表示缺少 jar 包 aspectjweaver.jar 下载导入此 jar 包即可]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
        <tag>idea</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[idea_create_web]]></title>
    <url>%2F2018%2F08%2F31%2Fidea-create-web%2F</url>
    <content type="text"><![CDATA[流程参考：https://www.cnblogs.com/xuange306/p/7012341.html 遇见的小问题：没有 javax.servlet.* 的 jar 包 在 Project Structure 中选择 libraries 点击左侧加号选择 java 添加 tomcat 文件夹下 lib 文件夹中的 servlet-api.jar 同时也可添加常用 jar 包 tomcat-api 与 jsp-api 可以使用 ctrl+shift+alt+s 打开 Project Structure 选择 Modules 点击右侧 + 号，选择 libraries ，选择 Project Libraries 下的 tomcat 添加即可 普通 jar 包添加可选方法：在 WEB-INF 下创建 lib 目录，把 jar 包复制到 lib 目录下，ctrl+shift+alt+s 打开 Project Structure 选择左侧 libraries ，点击左侧加号 选择 java，选择 创建的 lib 目录添加，选择左侧 Modules 栏，勾选 lib https://my.oschina.net/fdblog/blog/161305 创建Web项目后没有WEB-INF文件夹及web.xml shift+ctrl+alt+s进入Project Structure打开Project Structure，在facets中选中次级的web或者在Modules中选中web，在deployment Descriptors面板里，点击 +号选择web.xml以及版本号。然后在弹出的对话框中修改xml默认的目录，加上web就可以了 Q: IntelliJ IDEA Tomcal启动报错： org.apache.catalina.core.AprLifecycleListener.init The APR based Apache Tomcat Native library failed to load. The error reported was [C:\tomcat\bin\tcnative-1.dll: Can’t load AMD 64-bit .dll on a IA 32-bit platform] java.lang.UnsatisfiedLinkError: C:\tomcat\bin\tcnative-1.dll: Can’t load AMD 64-bit .dll on a IA 32-bit platform A: 主要是在64位的系统下安装的虚拟机是64位的，而WTK的sublime.dll不能在64位的平台下加载64位的虚拟机，只能加载32位的。由于WTK在安装的时候加载的64虚拟机的地址，它找到的是64位的虚拟机，所以它提示不能加载32位的虚拟机（在目录下没有32的虚拟机） 解决办法下载 the 32bit from http://www.apache.org/dist/tomcat/tomcat-connectors/native/找到最近的版本，我的是 tomcat-native-1.2.16-win32-bin.zip下载后解压，找到tomcat-native-1.2.16-win32-bin.zip\bin\tcnative-1.dll (不是64X文件夹中的)替换到tomcat根目录下tomcat\bin idea tomcat警告参考：http://blog.51cto.com/13765598/2120489 Q: intellj idea启动tomcat服务器后无法访问localhost:8080（白屏）A: 原因：没有将tomcat主页的工程部署到intellj idea的虚拟tomcat路径，可在Run/Debug Configurations中Deployment选项中点击右边的绿色加号，选择External Source，然后添加Tomcat安装目录tomcat/webapps/Root目录即可；参考资料：https://blog.csdn.net/qq_22708467/article/details/79070973 tips：在部署 tomcat 服务器时，点击右上角 edit configurations 选择Deployment 添加了 Artifact 后，右边的Application context中的 / 代表项目部署的虚拟路径（网址访问主页面路径）: 若 index.jsp 在 aaa/web 目录下，虚拟路径为 /则访问 index.jsp 地址为 localhost/8080 或 localhost/8080/index.jsp . 若虚拟路径设为 /aaa 则访问 index.jsp 的地址为 localhost/8080/aaa/index.jsp 或 localhost/8080/aaa-request.getContextPath(); 得到的值为虚拟路径]]></content>
      <categories>
        <category>idea</category>
      </categories>
      <tags>
        <tag>idea</tag>
        <tag>intelj</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单例设计模式]]></title>
    <url>%2F2018%2F08%2F20%2FSingleDemo%2F</url>
    <content type="text"><![CDATA[单例设计模式：解决一个类中只存在一个对象单例设计模式特性：保证对象在内存中的唯一性： 为了避免其他程序创建过多对象，先禁止其他程序创建该类对象 为了让其他类访问到该对象，在本类中自定义一个对象 方便其他对象对自定义对象的访问，可以对外提供一些访问方式 用代码的方式实现对象在内存中唯一性： 将构造函数私有化 在类中创建一个本类对象 提供一个方法可以获取到该对象 单例模式使用方式：按平时的描述方式描述事物，加上 单例模式 的 3 步方式即可 单例设计模式饿汉式 java 代码实现：1234567891011121314151617181920class Single&#123; private Single()&#123;&#125;; //内置成员变化需要私有化 private static Single s = new Single(); /** 方法被调用的方法只有两种：对象、类名 因为该对象被私有化了，无法外部创建该方法，所以用类名调用 类名调用需要设置静态方法 静态方法只能访问静态成员，所以成员也需要静态 */ private Single getInstance()&#123; return s; &#125;&#125;class SingleDemo&#123; public static void main(String [] args)&#123; Single ss = Single.getInstance(); &#125;&#125; 栈中加载 main 函数 和 ss 方法区中有了 Single 的空间、静态的 s 变量、getInstance() 方法 堆中有了一个 new Single() 地址假设为 0x0015 方法区的 s 变量指向了 堆中 new Single() 的地址 0x0015 return s Single ss = Single.getInstance(); 使得 ss 也指向 0x0015 普通方式创建多个对象：1234567891011121314151617181920212223242526272829303132333435363738394041424344class Single&#123; private int num; public void setNum(int num)&#123; this.num = num; &#125; public int getNum()&#123; return num; &#125; //不设置私有化，可外部创建该对象 Single()&#123;&#125;; //单例模式下设置私有化，不可外部创建该对象 //private Single()&#123;&#125;; private static Single s = new Single(); private Single getInstance()&#123; return s; &#125;&#125;class SingleDemo&#123; public static void main(String [] args)&#123; //创建 2 个 Single 对象 Single s1 = new Single(); Single s2 = new Single(); //设置值为 30 s1.setNum(30); /**输出值为默认值 0 创建了两个对象，修改其中一个值跟另一个无关 */ System.out.println(s2.getNum()); /* ss2 的值为 23，表明 ss1 与 ss2 是同一个对象 单例模式内存中一个一个对象在执行，该对象有 3 个引用： SingleDemo 的 ss1、ss2 和 Single 中的 s */ //Single ss1 = Single.getInstance(); //Single ss2 = Single.getInstance(); //ss1.setNum(15); //System.out.println(ss2); &#125;&#125; 单例设计模式 懒汉式 java 代码123456789101112131415161718192021222324252627282930/*先初始化对象：称为 饿汉式Single 类一进内存，就已经创建好了对象class Single&#123; private Single()&#123;&#125;; private static Single s = new Single(); private Single getInstance()&#123; return s; &#125; &#125;*///对象在方法被调用时才初始化，也叫作对象的延时加载 称为 懒汉式//Single 类进内存，对象还没有存在，只有调用 getInstance() 方法时，才建立对象class Single&#123; private Single()&#123;&#125;; private static Single s = null; private Single getInstance()&#123; if(s==null)&#123; s = new Single(); &#125; return s; &#125; &#125;class SingleDemo&#123; public static void main(String [] args)&#123; Single ss = Single.getInstance(); &#125;&#125; 饿汉式：Single 类 加载进内存时，方法区就有 s，堆中就有对象，对象的地址值赋给 s 懒汉式：Single 类 加载进内存时，方法区 s 为空，当调用 getInstance() 方法时，才在内存中建立建立对象，将堆内存中的地址赋给 s，替换空值 懒汉式防止多个用户创建多个对象1234567891011121314151617class Single&#123; private Single()&#123;&#125;; private static Single s = null; //锁加载判断内部，提升效率 private Single getInstance()&#123; if(s==null)&#123; //加锁，防止创建多个对象 synchronized(Single.class)&#123; if(s==null)&#123; s = new Single(); &#125; &#125; &#125; return s; &#125; &#125;]]></content>
      <categories>
        <category>Design Patterns</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>Singleton Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring4x_2]]></title>
    <url>%2F2018%2F08%2F14%2FSpring4x-2%2F</url>
    <content type="text"><![CDATA[Spring 名词参考POJO：POJO（Plain Ordinary Java Object）简单的Java对象，实际就是普通JavaBeans，是为了避免和EJB混淆所创造的简称 使用POJO名称是为了避免和EJB混淆起来, 而且简称比较直接. 其中有一些属性及其getter setter方法的类,没有业务逻辑，有时可以作为VO(value -object)或dto(Data Transform Object)来使用.当然,如果你有一个简单的运算属性也是可以的,但不允许有业务方法,也不能携带有connection之类的方法。 教程参考 idea 创建 log4j 文件 Q&amp;AQ1:application context not configured for this file A: application context not configured for this file于spring框架使用中的原因 Q2: cvc-complex-type.2.4.c: 通配符的匹配很全面, 但无法找到元素 ‘tx:Advisor’ 的声明。 A: 在 smart-context.xml 中加入 Spring 引用 Q3:1Caused by: java.sql.SQLException: Access denied for user &apos;root&apos;@&apos;localhost&apos; (using password: YES) A: smart-context.xml 配置 数据库的用户密码错误 Q4:c:if 与 c:url 标签无效 A: accepted First add this to the top of your “.jsp” file: 1&lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot; prefix=&quot;c&quot; %&gt; It will still give syntax error but you can fix that by adding “javax.servlet:jstl:1.2” (without quotes) as a module dependency. To do that, follow these steps: Click your project name and press “F4” to bring up the module settings dialog. Then go to the “dependencies” tab in the “modules” section. Click the green “+” icon –&gt; library –&gt; new library –&gt; From Maven. Search for javax.servlet:jstl:1.2 in the search bar and press OK and it will download and add the above mentioned library as a module. Now you should not have any kind of syntax error. c:if标签 Cannot resolve symbol]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springAutoAssembly]]></title>
    <url>%2F2018%2F08%2F10%2FspringAutoAssembly%2F</url>
    <content type="text"><![CDATA[通过 Java 代码装配 bean通常组件扫描和自动化装配实现 Spring 的自动化配置，但是有时候例如要将第三方库中的组件装配到你的应用中，这种情况下没办法在它的类上添加 @Component 和 @Autowired 注解，就不能使用自动化配置了。 需要进行显示装配方式：java/XML java(javaConfig) 是比较好的方案，它更强大、类型安全、对重构友好，它是 java 代码，但是 JavaConfig 是配置代码，不应该包含任何业务逻辑，会将其放在单独的包中与其他应用程序逻辑分离开。 创建配置类如果去掉 CDPlayerConfig 的 @ComponentScan 注解，再次运行 CDPlayerTest 的话，测试会失败，出现异常。测试期望被注入CDPlayer 和 CompactDisc，但是这些 bean 没有被创建，组件扫描不会发现它们。 123456789package com.soundsystem;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;@Configuration//@ComponentScanpublic class CDPlayerConfig &#123;&#125; 声明简单的 bean在 JavaConfig 中声明 bean ，编写一个创建所需类型的实例的方法，给这个方法添加 @Bean 注解。 声明 CompactDisc bean : 1234@Beanpublic CompactDisc sgtPeppers()&#123; return new SgtPeppers();&#125; @Bean 注解告诉 Spring 这个方法返回一个对象，该对象要注册为 Spring 应用上下文中的 bean ，方法体中包含了最终产生 bean 实例的逻辑。 默认情况下，bean 的 id 跟带有@bean注解的方法名一样，本例中为 sgtPeppers，如果要重新设置可以通过name属性指定： 1234@Bean(name="lonelyHeartsClubBand")public CompactDisc sgtPeppers()&#123; return new SgtPeppers();&#125; 方法体返回了一个新的 SgtPeppers 实例，因为是java代码所以可以使用java提供的全部功能，只要最终能生成CompactDisc实例就行。 可以用 java的功能在一组 CD 中随机选择一个 CompactDisc 播放： 12345678910111213@Beanpublic CompactDisc randomBeatlesCD()&#123; int choice = (int)Math.floor(Math.random()*4); if(choice==0)&#123; return new WhiteAlbum(); &#125;else if(choice==1)&#123; return new SgtPeppers(); &#125;else if(choice==2)&#123; return new HardDaysNight(); &#125;else if(choice==3)&#123; return enw Revolver(); &#125;&#125; Spring中Bean及@Bean的理解 java 是面相对象，对象有方法和属性，需要对象实例来调用方法和属性（实例化），有方法或属性的类都需要实例化才能具象化地去使用这些方法和属性。bean 是类的代理，这样它就能代表类拥有该拥有的东西了。 注解： 使用 bean: 即是把已经在xml文件中配置好的Bean拿来用，完成属性、方法的组装；比如@Autowired , @Resource，可以通过byTYPE（@Autowired）、byNAME（@Resource）的方式获取Bean； 注册Bean: @Component , @Repository , @ Controller , @Service , @Configration这些注解都是把你要实例化的对象转化成一个Bean，放在IoC容器中，等你要用的时候，它会和上面的@Autowired , @Resource配合到一起，把对象、属性、方法完美组装。 @bean: 意思是@Bean明确地指示了一种方法，什么方法呢——产生一个bean的方法，并且交给Spring容器管理；从这我们就明白了为啥@Bean是放在方法的注释上了，因为它很明确地告诉被注释的方法，你给我产生一个Bean，然后交给Spring容器，剩下的你就别管了 Spring 注入： IOC 容器加载时会扫描 xml 文件中 bean 的配置，对这些 bean 进行实例化（初始化）。注入指在初始化一个实例的时候对这个实例的成员变量进行赋值。 借助 JavaConfig 实现注入当需要声明一个依赖于 CompactDisc 的 CDPlayer bean 时，可用如下方法在 JavaConfig 中进行装配： 引用创建 bean 的方法： 1234@Beanpublic CDPlayer cdPlayer()&#123; return new CDPlayer(sgtPeppers());&#125; 创建的 bean ID 为 cdPlayer，与方法名相同。cdPlayer() 方法没有使用默认的构造器构建实例，而是调用了需要传入 CompactDisc 对象的构造器来创建 CDPlayer 实例，但是它并不是通过调用 sgtPeppers() 方法得到的，sgtPeppers() 方法上添加了 @Bean 注解，所以 Spring 将会拦截所有对它的条用，会直接返回该方法所创建的 bean cdPlayer() 方法请求一个 CompactDisc 作为参数 1234@Beanpublic CDPlayer cdPlayer(CompactDisc compactDisc)&#123; return new CDPlayer(compactdisc);&#125; 不管 CompactDisc 使用什么方式创建出来的，Spring 都会将其传入到配置方法中，并用来创建 CDPlayer bean。以上构造器和下面的 Setter 方法只是 @Bean 的其中一些方法： 123456@Beanpublic CDPlayer cdPlayer(CompactDisc compactDisc)&#123; CDPlayer cdPlayer = new CDPlayer(compactDisc); cdPlayer.setCompactDisc(compactDisc) return cdPlayer;&#125; 声明一个简单的 属性注入（设值注入） 元素类似于 JavaConfig 的 @Bean 注解。 1234&lt;bean id="cdPlayer" class="soundsystem.CDPlayer"&gt; &lt;constructor-arg name="compactDisc" ref="compactDisc" /&gt;&lt;/bean&gt; 1234&lt;bean id="cdPlayer" class="soundsystem.CDPlayer"&gt; &lt;property name="compactDisc" ref="compactDisc" /&gt;&lt;/bean&gt; id 为 cdPlayer 的 CDPlayer 类，其中有一个名称为 compactDisc 的成员变量。 元素为属性的 Setter 方法所提供的功能与 元素为构造器所提供的功能相同。 通过 ref 属性，引用了 ID 为 compactDisc 的 bean，用 setCompactDisc() 方法将其注入到 compactDisc 属性中。所以 CDPlayer 中必须有 setCompactDisc() 的方法，由 IOC 容器自动调用方法进行赋值。]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>autoAssembly</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring 框架基础]]></title>
    <url>%2F2018%2F08%2F02%2Fspring%2F</url>
    <content type="text"><![CDATA[Spring 框架基础控制反转（Inversion of Control，缩写为IoC），是面向对象编程中的一种设计原则，可以用来减低计算机代码之间的耦合度。其中最常见的方式叫做依赖注入（Dependency Injection，简称DI），还有一种方式叫“依赖查找”（Dependency Lookup）。通过控制反转，对象在被创建的时候，由一个调控系统内所有对象的外界实体，将其所依赖的对象的引用传递给它。也可以说，依赖被注入到对象中。 IOC 是一种设计模式，原来创建对象的主动权和时间是由自己控制的，现在把需要使用的对象的创建，销毁的控制权交给别人（IOC容器），使用时直接获取，这种对象可以单例或多例。IOC 有利于降低耦合度。 依赖注入和控制反转的理解 AOP为Aspect Oriented Programming的缩写，意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。 idea 的简单 Spring 文件创建及测试 创建一个 project 勾选 Spring 及 web Application 创建 interface、实现接口类、配置类以及测试类 idea 创建测试类方法： 在 bean 同目录下创建一个 test 测试文件夹，同时按住 ctrl+shift+alt+s 调出 project structure 窗口，选择modules 栏中的 Sources 栏，选中创建 test 文件夹，在 Mark as 栏选择 Tests，将 Tests 文件夹作为 Test 文件创建的目录。 在 实现接口类的类名上 alt+enter 选择 create test，在 TestLibrary 选择 JUnit4， 如果出现 JUnit4 Library notfound in the module ，点击 fix 选择 Use ‘JUnit4’ from idea distribution 点 ok，在下方 Member 栏将方法选中，可创建该类方法的测试方法 在测试类文件中类的上方添加注释 @RunWith(SpringJUnit4ClassRunner.class) 以便在测试开始的时候自动创建 Spring 的应用上下文 添加注解 @ContextConfiguration(classes=CDPlayerConfig.class) 表示需要在 CDPlayerConfig 中加载配置，因为 CDPlayerConfig 类中包含了 @ComponentScan ，则最终引用上下文也会包含 CompactiDisc 的bean 在类中添加 注释 表示将 bean 注入到测试代码之中 12@Autowiredprivate CompactDisc cd; 一个简单的测试方法，断言测试 cd 属性不为 null ，表示 spring 能够发现 CompactDisc 类，能自动在 Spring 上下文中创建 bean 并将其注入到测试代码中 1234@Testpublic void cdShouldNotBeNull()&#123; assertNotNull(cd);&#125; 如果运行测试类报错 org.junit 不存在 ctrl + shift + alt + s 进入 project structure 窗口 ，在 Library 窗口 点击左边绿色的加号 -&gt; Java -&gt; 找到 IDEA 安装路径下的 Lib 中的junit-4.12 -&gt; 确定 ctrl + shift + t 在 测试 文件与 被测试 文件间切换 idea 使用 Junit4 测试教程（需科学上网） idea 打开显示 Spring Configure check 解决方法 ​ 打开 Project Structure－&gt;Facets 配置。左侧 + 号，选择 Spring (添加 spring 配置文件的模块) ​ 右侧 + 号，勾选项目，会选中项目及其下的 xml 文件 (设置添加没有被映射的Spring配置文件)，点击应用即可 为组件扫描的 bean 命名Spring 应用上下文所有的 bean 一般都会根据类名指定一个 ID，将类名的第一个字母变为小写（SgtPeppers 设置为 sgtPeppers），如果要自己设置不同的 ID，则在 SgtPeppers 类注解 @Component 中配置 ID 名，如 1234@Component("lonelyHeartsClub")public class SgtPeppers implements CompactDisc&#123; ...&#125; 或者使用 @Named 注解也可以，但是通常使用 @Component 1234@Named("lonelyHeartsClub")public class SgtPeppers implements CompactDisc&#123; ...&#125; 设置组件扫描基础包如果没有为 @ComponentScan 设置任何属性，它会以配置类所在的包作为基础包（base package）来扫描组件（扫描）。如果想将装配类放在单独的包中跟其他的应用代码进行区分，那么默认基础包将不能满足要求。 为了指定不同的基础包，可以在 @ComponentScan 的 value 属性中指明包的名称： 1234@Configuration@ComponentScan("soundsystem)public class CDPlayerConfig &#123;&#125; 如果为了更清楚地表明设置的是基础包，可以通过 basePackages 属性进行配置： 1234@Configuration@ComponentScan(basePackages="soundsystem")public class CDPlayerConfig &#123;&#125; 若要设置多个基础包，可以将 basePackages 属性设置为需要扫描包的数组即可： 1234@Configuration@ComponentScan(basePackages="soundsystem","video")public class CDPlayerConfig &#123;&#125; 以上用 String 类型表示的基础包设置是类型不安全的(not type-safe)，如果重构代码的话，所指定的基础包可能会出错。 此时应用 @ComponentScan 指定包中所包含的类或接口,为 basePackageClasses 属性所设置的数组中包含了类，这些类所在的的包会作为组件扫描的基础包。 1234@Configuration@ComponentScan(basePackageClasses=(CDPlayer.class,DVDPlayer.class))public class CDPlayerConfig &#123;&#125; 为 bean 添加注解实现自动装配 CDPlayer 类中，给构造器添加 @Autowired 注解，表明当 Spring 创建 CDPlayer bean 时，会通过这个构造器来进行实例化，并且传入一个可设置给 CompactDisc 类型的 bean。 12345package com.soundsystem;public interface MediaPlayer &#123; void play();&#125; 1234567891011121314151617package com.soundsystem;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Component;@Componentpublic class CDPlayer implements MediaPlayer &#123; private CompactDisc cd; @Autowired public CDPlayer(CompactDisc cd)&#123; this.cd = cd; &#125; public void play()&#123; cd.play(); &#125;&#125; 该注解可用在构造器，也可用在属性的 Setter 方法上，CDPlayer 有一个 setCompactDisc() 方法，可以采用如下的注解装配： 1234@Autowired public void setCompactDisc(CompactDisc cd)&#123; this.cd = cd; &#125; 在 Spring 初始化 bean 后，它会尽可能满足 bean 的依赖，本例中的依赖是通过带有 @Autowired 注解声明的，@Autowired 能在构造器、Setter 方法，或者其他方法上发挥同样的作用，Spring 都会去满足方法参数上所声明的依赖。 如果有且只有一个 bean 匹配依赖需求的话，那么这个 bean 会被装配进来。但没有匹配 bean 的情况下，在应用上下文创建的时候，Spring 会抛出一个异常，为了避免异常出现可以将 @Autowired 的 required 属性设置为 false，同时代码中需进行 null 检查。 如果有多个 bean 满足依赖关系 Spring 会抛出一个异常。 Autowired 是 Spring 特有注解，可以选择 @Inject 注解（源自 Java 依赖注入规范）代替。 验证自动装配 System Rules 库 Java 单元测试如何断言(检查)控制台输出 注入 CompactDisc ，注入 CDPlayer bean 到测试代码的 player 成员变量之中（为更通用的 MediaPlayer 类型），在 play 测试方法中，可以调用 CDPlayer 的 player() 方法，断言其行为与你的预期一致 123456789101112131415161718192021222324252627282930313233343536package com.soundsystem;import static org.junit.Assert.*;import org.junit.Rule;import org.junit.Test;import org.junit.contrib.java.lang.system.StandardOutputStreamLog;import org.junit.contrib.java.lang.system.SystemOutRule;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import static org.junit.Assert.*;@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(classes=CDPlayerConfig.class)public class CDPlayerTest &#123; @Rule public final SystemOutRule log = new SystemOutRule(); @Autowired private MediaPlayer player; @Autowired private CompactDisc cd; @Test void cdShouldNotBeNull()&#123; assertNotNull(cd); &#125; @Test public void play() &#123; player.play(); assertEquals( "playing Sgt. Pepper's Lonely Hearts Club Band" + "by The Beatles\n", log.getLog(); ); &#125;&#125;]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
        <tag>IOC</tag>
        <tag>依赖</tag>
        <tag>注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis_Reply 微信自动回复]]></title>
    <url>%2F2018%2F07%2F30%2FMyBatis-Reply%2F</url>
    <content type="text"><![CDATA[实现输入关键字微信自动回复的功能添加一对多关系配置创建 command 与关联数据库 12create table command(id int primary key , name varchar(16) , description varchar(16));create table command_content (id int primary key , content varchar(2048) , command_id int, foreign key(command_id) references command(id) on delete cascade on update cascade); 查询主表的实体，将查询 sql 语句放在主表对应的 xml 文件中，将查询出的数据填充到主表对应的属性中，同时填充子表的列表 left join COMMAND_CONTENT 关联附表 COMMAND a COMMAND_CONTENT b 给表取别名，主表为 a ；附表为 b a.ID C_ID 给 a 表 ID 取别名为 C_ID 1select a.ID C_ID,a.NAME,a.DESCRIPTION,b.Id,b.CONTENT,b.COMMAND_ID from COMMAND a left join COMMAND_CONTENT b on a.ID=b.COMMAND_ID mybatis 取属性名时，用的是 ResultSet 的 getMetaData().getColumnName(column); 方法 不会取到 a.ID 的 a 前缀 如果创建了不存在的 主表 id 对应 command_id 则无法再创建新的 column 空语句可以产生提示，有了内容就无法发送 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253HTTP Status 500 – Internal Server ErrorType Exception ReportDescription The server encountered an unexpected condition that prevented it from fulfilling the request.Exceptionorg.apache.ibatis.exceptions.PersistenceException: ### Error querying database. Cause: java.lang.IllegalArgumentException: Result Maps collection does not contain value for CommandContent.Content### The error may exist in com/imooc/config/sqlxml/Command.xml### The error may involve Command.queryCommandList### The error occurred while handling results### SQL: select a.ID C_ID,a.NAME,a.DESCRIPTION,b.Id,b.CONTENT,b.COMMAND_ID from COMMAND a left join COMMAND_CONTENT b on a.ID=b.COMMAND_ID### Cause: java.lang.IllegalArgumentException: Result Maps collection does not contain value for CommandContent.Content org.apache.ibatis.exceptions.ExceptionFactory.wrapException(ExceptionFactory.java:30) org.apache.ibatis.session.defaults.DefaultSqlSession.selectList(DefaultSqlSession.java:150) org.apache.ibatis.session.defaults.DefaultSqlSession.selectList(DefaultSqlSession.java:141) com.imooc.dao.CommandDao.queryCommandList(CommandDao.java:34) com.imooc.service.QueryService.queryByCommand(QueryService.java:53) com.imooc.servlet.AutoReplyServlet.doGet(AutoReplyServlet.java:18) javax.servlet.http.HttpServlet.service(HttpServlet.java:635) javax.servlet.http.HttpServlet.service(HttpServlet.java:742) org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52)Root Causejava.lang.IllegalArgumentException: Result Maps collection does not contain value for CommandContent.Content org.apache.ibatis.session.Configuration$StrictMap.get(Configuration.java:888) org.apache.ibatis.session.Configuration.getResultMap(Configuration.java:640) org.apache.ibatis.executor.resultset.DefaultResultSetHandler.getNestedResultMap(DefaultResultSetHandler.java:1011) org.apache.ibatis.executor.resultset.DefaultResultSetHandler.applyNestedResultMappings(DefaultResultSetHandler.java:945) org.apache.ibatis.executor.resultset.DefaultResultSetHandler.getRowValue(DefaultResultSetHandler.java:918) org.apache.ibatis.executor.resultset.DefaultResultSetHandler.handleRowValuesForNestedResultMap(DefaultResultSetHandler.java:881) org.apache.ibatis.executor.resultset.DefaultResultSetHandler.handleRowValues(DefaultResultSetHandler.java:328) org.apache.ibatis.executor.resultset.DefaultResultSetHandler.handleResultSet(DefaultResultSetHandler.java:303) org.apache.ibatis.executor.resultset.DefaultResultSetHandler.handleResultSets(DefaultResultSetHandler.java:196) org.apache.ibatis.executor.statement.PreparedStatementHandler.query(PreparedStatementHandler.java:64) org.apache.ibatis.executor.statement.RoutingStatementHandler.query(RoutingStatementHandler.java:79) org.apache.ibatis.executor.SimpleExecutor.doQuery(SimpleExecutor.java:63) org.apache.ibatis.executor.BaseExecutor.queryFromDatabase(BaseExecutor.java:326) org.apache.ibatis.executor.BaseExecutor.query(BaseExecutor.java:156) org.apache.ibatis.executor.CachingExecutor.query(CachingExecutor.java:109) org.apache.ibatis.executor.CachingExecutor.query(CachingExecutor.java:83) org.apache.ibatis.session.defaults.DefaultSqlSession.selectList(DefaultSqlSession.java:148) org.apache.ibatis.session.defaults.DefaultSqlSession.selectList(DefaultSqlSession.java:141) com.imooc.dao.CommandDao.queryCommandList(CommandDao.java:34) com.imooc.service.QueryService.queryByCommand(QueryService.java:53) com.imooc.servlet.AutoReplyServlet.doGet(AutoReplyServlet.java:18) javax.servlet.http.HttpServlet.service(HttpServlet.java:635) javax.servlet.http.HttpServlet.service(HttpServlet.java:742) org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52)Note The full stack trace of the root cause is available in the server logs.Apache Tomcat/8.5.29 原因：在 Command.xml 中的 collention 属性的 ResultMap 引用 CommandContent.xml 下的 id ,引用名错误 方法：(CommandContent.ResultMap).id=”Content” (Command.Collection)ResultMap=”CommandContent.Content” 如果没有在 Configuration.xml 文件中引入 CommandContent.xml 与 Command.xml 也会产生该错误 mybatis 一对多关系的配置数据库子表内含“段子”关键词的多个内容，对应主表的“段子”的 id 。每次用户发送”段子“时，取出其中的所有内容，拼接进查询服务 QueryService 中创建的 (List)contentList 集合中，再创建随机数返回其中一条内容 12345678910111213&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;!--类似于 java package 的用法，用来区分不同项目,namespace 必须添加--&gt;&lt;!--作为子表包含具体多个内容对应主表的一个 id 然后被主表所引用--&gt;&lt;mapper namespace="CommandContent"&gt; &lt;resultMap type="com.imooc.bean.CommandContent" id="Content"&gt; &lt;id column="ID" jdbcType="INTEGER" property="id"/&gt; &lt;result column="CONTENT" jdbcType="VARCHAR" property="content"/&gt; &lt;result column="COMMAND_ID" jdbcType="VARCHAR" property="commandId"/&gt; &lt;/resultMap&gt;&lt;/mapper&gt; 1234567891011121314151617181920212223242526272829303132&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;!--类似于 java package 的用法，用来区分不同项目,namespace 必须添加--&gt;&lt;mapper namespace="Command"&gt;&lt;!--要反应一个一对多关系，需要用到在主表中引用子表列表的集合,引用CommandContent.xml 中的 Content 属性--&gt; &lt;resultMap type="com.imooc.bean.Command" id="Command"&gt; &lt;id column="C_ID" jdbcType="INTEGER" property="id"/&gt; &lt;result column="NAME" jdbcType="VARCHAR" property="name"/&gt; &lt;result column="DESCRIPTION" jdbcType="VARCHAR" property="description"/&gt; &lt;collection property="contentList" resultMap="CommandContent.Content"/&gt; &lt;/resultMap&gt; &lt;!--查询主表同时关联子表--&gt; &lt;select id="queryCommandList" parameterType="com.imooc.bean.Command" resultMap="Command"&gt; select a.ID C_ID,a.NAME,a.DESCRIPTION,b.Id,b.CONTENT,b.COMMAND_ID from COMMAND a left join COMMAND_CONTENT b on a.ID=b.COMMAND_ID &lt;!--where 关键字指，在其中的 if 语句都不满足条件则不输出 where 关键字，反之，有一个 if 满足则输出 where + if 中语句--&gt; &lt;!--where 还能将 if 拼接的 sql 语句最前端的 and 去掉，防止语句不准确--&gt; &lt;where&gt; &lt;if test="name != null &amp;amp;&amp;amp; !&amp;quot;&amp;quot;.equals(name.trim()) "&gt; and a.NAME=#&#123;name&#125; &lt;/if&gt; &lt;if test="description != null and !&amp;quot;&amp;quot;.equals(description.trim()) "&gt; and a.DESCRIPTION like '%' #&#123;description&#125; '%' &lt;/if&gt; &lt;/where&gt; &lt;/select&gt;&lt;/mapper&gt; 以上两个 xml 要引入到 Configuration.xml 中 将原来的单条信息查询改为一对多的数据查询1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package com.imooc.service;import com.imooc.bean.Command;import com.imooc.bean.CommandContent;import com.imooc.bean.Message;import com.imooc.dao.CommandDao;import com.imooc.dao.MessageDao;import com.imooc.util.Iconst;import java.util.List;import java.util.Random;public class QueryService &#123; //调用 MessageDao 进行数据操作，再由 ListServlet 调用。将值返回给 ListServlet public List&lt;Message&gt; queryMessageList(String command, String description)&#123; MessageDao messageDao = new MessageDao(); return messageDao.queryMessageList(command,description); &#125; /** * 通过指令查询自动回复内容 */ public String queryByCommand(String command)&#123;// MessageDao messageDao = new MessageDao(); CommandDao commandDao = new CommandDao();// List&lt;Message&gt; messageList; List&lt;Command&gt; commandList; if(Iconst.HELP_COMMAND.equals(command))&#123;// 如果指令是帮助，则将所有指令查出来并拼接；// messageList = messageDao.queryMessageList(null, null); commandList = commandDao.queryCommandList(null, null); StringBuilder result = new StringBuilder();// for(int i= 0;i &lt; messageList.size();i++)&#123; for(int i= 0;i &lt; commandList.size();i++)&#123; //如果不是第一行则添加换行 if(i !=0)&#123; result.append("&lt;br/&gt;"); &#125;// 拼接所有查询出来的指令及描述// result.append("回复[" + messageList.get(i).getCommand() + "]可以查看"// + messageList.get(i).getDescription()); result.append("回复[" + commandList.get(i).getName() + "]可以查看" + commandList.get(i).getDescription()); &#125; return result.toString(); &#125; //只需要通过指令，不需要描述来查询自动回复,如果为 null 则不进入 if 判断语句，不会添加 and sql 语句// messageList = messageDao.queryMessageList(command, null);// if(messageList.size() &gt; 0)&#123;// return messageList.get(0).getContent();// &#125; commandList = commandDao.queryCommandList(command, null); if(commandList.size() &gt; 0)&#123; //取得第一条查询语句的 子表集合内容/列表信息 List&lt;CommandContent&gt; contentList = commandList.get(0).getContentList(); //取得列表信息其中一条返回 //取 [0,size()) 的随机数 int i = new Random().nextInt(contentList.size());// 取得随机的 commandContent 的对象，然后从对象中取得内容 return contentList.get(i).getContent(); &#125; //当指令没有匹配的回复内容时，用此内容替代 return Iconst.NO_MATCHING_CONTENT; &#125;&#125; 自动回复 servlet 将跳转功能转换为 写查询返回语句的功能 123456789101112131415161718192021222324252627package com.imooc.servlet;import com.imooc.service.QueryService;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;public class AutoReplyServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; resp.setContentType("text/html;charset=utf-8"); PrintWriter out = resp.getWriter(); QueryService queryService = new QueryService(); out.write(queryService.queryByCommand(req.getParameter("content"))); out.flush(); out.close(); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; this.doGet(req,resp); &#125;&#125; 常用标签 where 标签 where标签 在其中的 if 语句都不满足条件则不输出 where 关键字，反之，有一个 if 满足则输出 where + if 中语句where 还能将 if 拼接的 sql 语句最前端的 and 去掉，防止语句不准确 123456select ID,COMMAND,DESCRIPTION,CONTENT from MESSAGE where 1=1 &lt;if test="command != null &amp;amp;&amp;amp; !&amp;quot;&amp;quot;.equals(command.trim()) "&gt; and COMMAND=#&#123;command&#125; &lt;/if&gt; &lt;if test="description != null and !&amp;quot;&amp;quot;.equals(description.trim()) "&gt; and DESCRIPTION like '%' #&#123;description&#125; '%' &lt;/if&gt; 去掉 where 1=1 ，但是加上 where 标签即可 1234567select ID,COMMAND,DESCRIPTION,CONTENT from MESSAGE&lt;where&gt; &lt;if test="command != null &amp;amp;&amp;amp; !&amp;quot;&amp;quot;.equals(command.trim()) "&gt; and COMMAND=#&#123;command&#125; &lt;/if&gt; &lt;if test="description != null and !&amp;quot;&amp;quot;.equals(description.trim()) "&gt; and DESCRIPTION like '%' #&#123;description&#125; '%' &lt;/if&gt;&lt;/where&gt; include 引用标签 1select ID,COMMAND,DESCRIPTION,CONTENT from MESSAGE 语句能用以下语法代替 12select &lt;include refid="columns"/&gt; from MESSAGE&lt;sql id="columns"&gt;ID,COMMAND,DESCRIPTION,CONTENT&lt;/sql&gt; set 标签 修改升级数据库的功能 1update MESSAGE set COMMAND=#&#123;command&#125;,DESCRIPTION=#&#123;description&#125; update 标签 为了使 sql 语句结尾的 ‘,’ 不多余加入了 set 标签，效果跟 where 去 and 类似，能去掉语句最后多余的 ‘,’ 123456789101112&lt;update id=""&gt; &lt;set&gt; update MESSAGE set &lt;if test="command != null &amp;amp;&amp;amp; !&amp;quot;&amp;quot;.equals(command.trim()) "&gt; COMMAND=#&#123;command&#125;, &lt;/if&gt; &lt;if test="description != null and !&amp;quot;&amp;quot;.equals(description.trim()) "&gt; and DESCRIPTION=#&#123;description&#125;, &lt;/if&gt; COMMAND=#&#123;command&#125;,DESCRIPTION=#&#123;description&#125; &lt;/set&gt;&lt;/update&gt; trim标签 trim 标签中的 prefix 属性，表示前缀，可以等于 where/set…（可自定义）如果各种判断结束有字符串输出就加入 where/set… trim 标签中的 suffix 属性，表示后面，可以加 test 或自定义 ，如果 if 中有内容输出就在最后加一个 test trim 标签的 prefixOverride 属性，表示删除前面内容，例如 prefixOverride=”and/or” 如果在前面出现了and 与 or 则切掉，同理 suffixOverride=”,” 可以去除结尾的 ‘,’ 12345当 prefix 值为 where 且能去掉首部的 and/or，该 trim 能替换 where 标签&lt;trim prefix="where" prefixOverride="and/or"&gt;&lt;/trim&gt;同理当 prefix 值为 set 且去掉尾部的 ','，该 trim 能替换 set 标签&lt;trim prefix="set" suffixOverride=","&gt;&lt;/trim&gt; choose 标签 chosse when 相当于 java 中的 else if，又或者是 switch case choose otherwise 相当于 else，或者是 default 123456789101112131415161718select ID,COMMAND,DESCRIPTION,CONTENT from MESSAGE&lt;where&gt; &lt;if test="command != null &amp;amp;&amp;amp; !&amp;quot;&amp;quot;.equals(command.trim()) "&gt; and COMMAND=#&#123;command&#125; &lt;/if&gt; &lt;if test="description != null and !&amp;quot;&amp;quot;.equals(description.trim()) "&gt; and DESCRIPTION like '%' #&#123;description&#125; '%' &lt;/if&gt; &lt;choose&gt; &lt;when test=""&gt; &lt;/when&gt; &lt;when test=""&gt; &lt;/when&gt; &lt;when test=""&gt; &lt;/when&gt; &lt;when test=""&gt; &lt;/when&gt; &lt;otherwise&gt;&lt;/otherwise&gt; &lt;/choose&gt;&lt;/where&gt; association 标签 需要根据子表内容查询相关联的主表内容，association 与 collection 标签相似 。 property 为 bean 中主表实体的引用，resultMap 指向主表的 nameSpace.(resultMap 的 id) 1&lt;association property="command" resultMap="Command.Command"/&gt; 标签总结 定义 sql 语句 insert，delete，update，select 配置 java 对象属性与查询结果集中列名的对应关系（列名不是数据库表中的列名，而是查询结果集的列名） resultMap 动态拼接 sql 语句 foreach，if，choose 格式化输出（动态拼接 sql 语句不符合 sql 语法，对该语法进行格式化） where，set，trim 配置关联关系（一对多，多对一） collention，association 常量标签（可在需要地方引用他） sql 引用标签（引用常量标签） include resultMap 使用标签配置对应关系，结果集列名与 java 类属性名可以不相同，有 typeHandler 可以配置字符集 resultType 不需要进行配置，但是结果集中的列名与 java 类中的属性名相同 parameterType 与 ognl 表达式相关联 #{} parameterMap 与 resultMap 相似，需要指向 ParameterMap 标签配置的映射关系的 id 。表示参数中的属性与数据库列的对应关系。 以 Map 结尾表示映射，需要配置映射关系 Type 结尾表示类型，resultType 与 parameterType 原名 resultClass 与 parameterClass，与 java 类类似 #{} 被 mybatis 解析为 ？，然后被 preparedStatement 赋值为 ‘段子’，有预编译效果，一半采用该方法 ${} 直接被 mybatis 拼接 字符串 （String）段子，没有引号，需要自己添加单引号 ‘${command}’ ${} 一般用于取直接从页面上传过来的列名进行操作 常见错误 sql 语法错误：使用 log4j 查看拼接后的 sql 语句，将其复制到 nativeMysql 中，将值赋给 ？的占位符，进行 sql 语句的判断 注解型 sql 比 配置型 sql 方便，但是有局限性 编码问题 ：文件本身编码、jsp 设置编码、servlet 接受页面传值，用来转换的编码、用 get 方式提交中文时，tomcat 也要配置编码 网页乱码 : 在talk.jsp上方加上 12&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt;&lt;%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c" %&gt; 若以上全部配置好，而与数据库交互出现乱码，则在 Configuration.xml 写连接数据库的 url 时，就需要加上编码方式、建立数据库与建表时的编码也需要注意获取自增主键值： useGeneratedKeys : 表示插入到这张表时采用生成的主键,而不是自己指定一个主键，Command 这个类的其他属性值来自于页面，而 id 是自增的，所以页面中没有 id 值 keyProperty : mybatis 会取到新增数据的主键，keyProperty 用来告诉 mybatis 将主键存到 Command 对象的哪一个属性中，这里的主键应该是 id. 在 Command 对象传入 xml 时，id 是没有值的，在 sqlSession 调用配置中 sql 语句执行完后，id 就有值了 在talk.jsp上方加上 12&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt;&lt;%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c" %&gt; 123&lt;insert id="insert" userGeneratedKeys="ture" property="id" parameterType="com.imooc.bran.Command"&gt; insert into COMMAND(NAME,DESCRIPTION) value(#&#123;name&#125;,#&#123;description&#125;)&lt;/insert&gt; 向 js 文件中传地址： 添加一个隐藏块，通过 id 与 value 向 js 中传入 basePath 的值 idea rename 一个类： 在一个类上右键 refactor → rename → 修改类名 → 取消 Search in Comments and strings (在评论和字符串中搜索) 跟 Search for textoccurrences (搜索文本事件) → 选择 variable name 点击 ok 即可 如果不取消 2 个勾选，rename 会无效。 选择 variable name 会使得子类重命名在调用该类对象的对象名]]></content>
      <categories>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>MyBatis</tag>
        <tag>autoReply</tag>
        <tag>weChat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jdbcToMyBatis]]></title>
    <url>%2F2018%2F07%2F25%2FjdbcToMyBatis%2F</url>
    <content type="text"><![CDATA[css 设置不显示问题： 将 resources 放入了 WEB-INF 文件夹中（这文件夹中的内容只能根据内部跳转或重定向等网页操作才能访问，不能直接访问） request.getContextPath() 获取的是上下文路径。是你的web项目的根路径，就是 webContent (MyEclipse中是webRoot) 或者 idea 中的 web 路径 拼装当前网页相对路径 url-pattern 配置 此文为 jdbc 版，如已了解直接转至 mybatis版 第一版大体框架 123456789101112131415161718192021222324package com.imooc.servlet;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;/** * 列表页面初始化控制 */@WebServlet(name="ListServlet" ,urlPatterns = "/List.action")public class ListServlet extends HttpServlet&#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; req.getRequestDispatcher("/WEB-INF/jsp/back/list.jsp").forward(req,resp); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; this.doGet(req, resp); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;&lt;%--拼接当前网页相对路径--%&gt;&lt;% String path = request.getContextPath(); String basePath = request.getScheme()+"://"+request.getServerName()+":"+request.getServerPort()+path;%&gt;&lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /&gt;&lt;meta http-equiv="X-UA-Compatible"content="IE=9; IE=8; IE=7; IE=EDGE" /&gt;&lt;title&gt;内容列表页面&lt;/title&gt;&lt;%--css 文件的相对路径--%&gt;&lt;link href="resources/css/all.css" rel="stylesheet" type="text/css" /&gt;&lt;/head&gt;&lt;body style="background: #e1e9eb;"&gt; &lt;form action="" id="mainForm" method="post"&gt; &lt;div class="right"&gt; &lt;div class="current"&gt;当前位置：&lt;br/&gt; &lt;a href="javascript:void(0)" style="color:#6E6E6E;"&gt; 内容管理 &lt;/a&gt; &amp;gt; 内容列表 &lt;/div&gt; &lt;div class="rightCont"&gt; &lt;p class="g_title fix"&gt;内容列表 &lt;a class="btn03" href="#"&gt;新 增&lt;/a&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;a class="btn03" href="#"&gt;删 除&lt;/a&gt; &lt;/p&gt; &lt;table class="tab1"&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td width="90" align="right"&gt;演示字段1：&lt;/td&gt; &lt;td&gt; &lt;input type="text" class="allInput" value=""/&gt; &lt;/td&gt; &lt;td width="90" align="right"&gt;演示字段2：&lt;/td&gt; &lt;td&gt; &lt;input type="text" class="allInput" value=""/&gt; &lt;/td&gt; &lt;td width="85" align="right"&gt; &lt;input type="submit" class="tabSub" value="查 询" /&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;div class="zixun fix"&gt; &lt;table class="tab2" width="100%"&gt; &lt;tbody&gt; &lt;tr&gt; &lt;th&gt;&lt;input type="checkbox" id="all" onclick="#"/&gt;&lt;/th&gt; &lt;th&gt;序号&lt;/th&gt; &lt;th&gt;演示字段1&lt;/th&gt; &lt;th&gt;演示字段2&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;input type="checkbox" /&gt;&lt;/td&gt; &lt;td&gt;1&lt;/td&gt; &lt;td&gt;演示值1&lt;/td&gt; &lt;td&gt;演示值2&lt;/td&gt; &lt;td&gt; &lt;a href="#"&gt;修改&lt;/a&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;a href="#"&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr style="background-color:#ECF6EE;"&gt; &lt;td&gt;&lt;input type="checkbox" /&gt;&lt;/td&gt; &lt;td&gt;2&lt;/td&gt; &lt;td&gt;演示值1&lt;/td&gt; &lt;td&gt;演示值2&lt;/td&gt; &lt;td&gt; &lt;a href="#"&gt;修改&lt;/a&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;a href="#"&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;input type="checkbox" /&gt;&lt;/td&gt; &lt;td&gt;3&lt;/td&gt; &lt;td&gt;演示值1&lt;/td&gt; &lt;td&gt;演示值2&lt;/td&gt; &lt;td&gt; &lt;a href="#"&gt;修改&lt;/a&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;a href="#"&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr style="background-color:#ECF6EE;"&gt; &lt;td&gt;&lt;input type="checkbox" /&gt;&lt;/td&gt; &lt;td&gt;4&lt;/td&gt; &lt;td&gt;演示值1&lt;/td&gt; &lt;td&gt;演示值2&lt;/td&gt; &lt;td&gt; &lt;a href="#"&gt;修改&lt;/a&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;a href="#"&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;div class='page fix'&gt; 共 &lt;b&gt;4&lt;/b&gt; 条 &lt;a href='###' class='first'&gt;首页&lt;/a&gt; &lt;a href='###' class='pre'&gt;上一页&lt;/a&gt; 当前第&lt;span&gt;1/1&lt;/span&gt;页 &lt;a href='###' class='next'&gt;下一页&lt;/a&gt; &lt;a href='###' class='last'&gt;末页&lt;/a&gt; 跳至&amp;nbsp;&lt;input type='text' value='1' class='allInput w28' /&gt;&amp;nbsp;页&amp;nbsp; &lt;a href='###' class='go'&gt;GO&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011121314151617181920212223&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd" version="3.1"&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt;/*此处可用 servlet 中的注释代替*/ &lt;!--&lt;servlet&gt;--&gt; &lt;!--&lt;servlet-name&gt;ListServlet&lt;/servlet-name&gt;--&gt; &lt;!--&lt;servlet-class&gt;com.imooc.servlet.ListServlet&lt;/servlet-class&gt;--&gt; &lt;!--&lt;/servlet&gt;--&gt; &lt;!--&lt;servlet-mapping&gt;--&gt; &lt;!--&lt;servlet-name&gt;ListServlet&lt;/servlet-name&gt;--&gt; &lt;!--访问 http://localhost:8080/List.action 后跳转到 list.jsp 页面--&gt; &lt;!--&lt;url-pattern&gt;/List.action&lt;/url-pattern&gt;--&gt; &lt;!--&lt;/servlet-mapping&gt;--&gt;&lt;/web-app&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package com.imooc.bean;public class Message &#123; /** * 主键 */ private String id; /** * 指令名称 */ private String command; /** * 描述 */ private String description; /** * 内容 */ private String content; public String getId() &#123; return id; &#125; public void setId(String id) &#123; this.id = id; &#125; public String getCommand() &#123; return command; &#125; public void setCommand(String command) &#123; this.command = command; &#125; public String getDescription() &#123; return description; &#125; public void setDescription(String description) &#123; this.description = description; &#125; public String getContent() &#123; return content; &#125; public void setContent(String content) &#123; this.content = content; &#125;&#125; 第一版完善 完善 list.jsp 及 ListSerlvet.java 的相关部分 sql 语句 1234567891011//sql preparedstatement 语句// ? 占位符// 用缺省值的方式，使用 List 在后面遍历填充字段信息比较方便stringsql = "select * from people p where p.id = ? and p.name = ?";preparedstatement ps = connection.preparestatement(sql);//设置缺省值的值//index 的值从 1 开始ps.setint(1,id);ps.setstring(2,name);//执行 sql 语句resultset rs = ps.executequery(); list.jsp 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;&lt;%--使用 jstl--%&gt;&lt;%@taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %&gt;&lt;%--拼接当前网页相对路径--%&gt;&lt;% String path = request.getContextPath(); String basePath = request.getScheme()+"://"+request.getServerName()+":"+request.getServerPort()+path;%&gt;&lt;html xmlns="http://www.w3.org/1999/xhtml"&gt; &lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /&gt; &lt;meta http-equiv="X-UA-Compatible"content="IE=9; IE=8; IE=7; IE=EDGE" /&gt; &lt;title&gt;内容列表页面&lt;/title&gt; &lt;%--css 文件的相对路径--%&gt; &lt;link href="&lt;%=basePath%&gt;/resources/css/all.css" rel="stylesheet" type="text/css" /&gt; &lt;/head&gt; &lt;body style="background: #e1e9eb;"&gt; &lt;%--提交到 ListServlet 上进行初始化与查询--%&gt; &lt;form action="&lt;%=basePath%&gt;/List.action" id="mainForm" method="post"&gt; &lt;div class="right"&gt; &lt;div class="current"&gt;当前位置：&lt;a href="javascript:void(0)" style="color:#6E6E6E;"&gt;内容管理&lt;/a&gt; &amp;gt; 内容列表&lt;/div&gt; &lt;div class="rightCont"&gt; &lt;p class="g_title fix"&gt;内容列表 &lt;a class="btn03" href="#"&gt;新 增&lt;/a&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;a class="btn03" href="#"&gt;删 除&lt;/a&gt;&lt;/p&gt; &lt;table class="tab1"&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td width="90" align="right"&gt;指令名称：&lt;/td&gt; &lt;td&gt; &lt;input name="command" type="text" class="allInput" value="$&#123;command&#125;"/&gt; &lt;/td&gt; &lt;td width="90" align="right"&gt;描述：&lt;/td&gt; &lt;td&gt; &lt;input name="description" type="text" class="allInput" value="$&#123;description&#125;"/&gt; &lt;/td&gt; &lt;td width="85" align="right"&gt;&lt;input type="submit" class="tabSub" value="查 询" /&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;div class="zixun fix"&gt; &lt;table class="tab2" width="100%"&gt; &lt;tbody&gt; &lt;tr&gt; &lt;th&gt;&lt;input type="checkbox" id="all" onclick="#"/&gt;&lt;/th&gt; &lt;th&gt;序号&lt;/th&gt; &lt;th&gt;演示字段1&lt;/th&gt; &lt;th&gt;演示字段2&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;c:forEach items="$&#123;messageList&#125;" var="message" varStatus="status"&gt; &lt;tr &lt;c:if test="$&#123;status.index % 2 != 0&#125;"&gt;style='background-color:#ECF6EE;'&lt;/c:if&gt;&gt; &lt;td&gt;&lt;input type="checkbox" /&gt;&lt;/td&gt; &lt;td&gt;$&#123;status.index + 1&#125;&lt;/td&gt; &lt;td&gt;$&#123;message.command&#125;&lt;/td&gt; &lt;td&gt;$&#123;message.description&#125;&lt;/td&gt; &lt;td&gt; &lt;a href="#"&gt;修改&lt;/a&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;a href="#"&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;div class='page fix'&gt; 共 &lt;b&gt;4&lt;/b&gt; 条 &lt;a href='###' class='first'&gt;首页&lt;/a&gt; &lt;a href='###' class='pre'&gt;上一页&lt;/a&gt; 当前第&lt;span&gt;1/1&lt;/span&gt;页 &lt;a href='###' class='next'&gt;下一页&lt;/a&gt; &lt;a href='###' class='last'&gt;末页&lt;/a&gt; 跳至&amp;nbsp;&lt;input type='text' value='1' class='allInput w28' /&gt;&amp;nbsp;页&amp;nbsp; &lt;a href='###' class='go'&gt;GO&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; ListServlet 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081package com.imooc.servlet;import com.imooc.bean.Message;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.sql.*;import java.util.ArrayList;import java.util.List;/** * 列表页面初始化控制 */@WebServlet(name="ListServlet" ,urlPatterns = "/List.action")public class ListServlet extends HttpServlet&#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; try &#123; //得到表单文本框提交的数据 req.setCharacterEncoding("utf-8"); String command = req.getParameter("command"); String description = req.getParameter("description"); //将查询完的值保留在查询栏中 req.setAttribute("command",command); req.setAttribute("description",description); Class.forName("com.mysql.jdbc.Driver"); Connection conn = DriverManager.getConnection("jdbc:mysql://127.0.0.1:3306/micro_message", "root","dfwhj43815"); StringBuilder sql = new StringBuilder("select ID,COMMAND,DESCRIPTION,CONTENT from MESSAGE where 1=1"); //创建一个 List 将需要拼接的 sql 语句查询内容装进去，最后用 for 循环取出，set 到 PreparedStatement 后执行 List&lt;String&gt; paramList = new ArrayList&lt;String&gt;(); //.trim() 方法返回一个 String 的副本，用来去除首尾的空格 if(command != null &amp;&amp; !"".equals(command.trim()))&#123; //查询sql语句拼接不用sql.append(" and command = '"+command+"'") 因为容易被SQL注入攻击 sql.append(" and COMMAND=?"); paramList.add(command); &#125; if(description != null &amp;&amp; !"".equals(description.trim()))&#123; sql.append(" and DESCRIPTION like '%' ? '%'"); paramList.add(description); &#125; PreparedStatement ps = conn.prepareStatement(sql.toString()); //在 sql 语句执行前，将参数加进去 for (int i = 0; i &lt; paramList.size(); i++) &#123; ps.setString(i + 1,paramList.get(i)); &#125; ResultSet rs = ps.executeQuery(); List&lt;Message&gt;messageList = new ArrayList&lt;Message&gt;(); while(rs.next())&#123; Message message = new Message(); //添加到容器中的不是对象本身，此时操作对象仍可以改变在容器中的内容。 //也可以将对象在最后添加到容器 message.setId(rs.getString("ID")); message.setCommand(rs.getString("COMMAND")); message.setDescription(rs.getString("DESCRIPTION")); message.setContent(rs.getString("CONTENT")); messageList.add(message); &#125; //将容器添加到 request 的 attribute 可以在页面上显示出来 req.setAttribute("messageList",messageList); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; req.getRequestDispatcher("/WEB-INF/jsp/back/list.jsp").forward(req,resp); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; this.doGet(req, resp); &#125;&#125; idea 引入 c 标签 网页有框架没有数据，提示找不到 jdbc，没有正确导入 Driver 包； You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ‘message’ at line 1 ​ at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method) at sun.reflect.NativeConstructorAccessorImpl.newInstance(Unknown Source) at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(Unknown Source) at java.lang.reflect.Constructor.newInstance(Unknown Source) Sql 语句有语法错误：from 写成了 form 第一版代码重构 将原来 servlet 的功能分出去 servlet 的功能 设置编码 接受页面的值 向页面传值 dao 层的功能 根据查询条件查询消息列表，跟表 Message 相关的所有操作都在这层 service 层的功能 调用 MessageDao 进行数据操作，再由 ListServlet 调用。将值返回给 ListServlet ListSerlvet 123456789101112131415161718192021222324252627282930313233343536373839404142package com.imooc.servlet;import com.imooc.bean.Message;import com.imooc.service.ListService;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.sql.*;import java.util.ArrayList;import java.util.List;/** * 列表页面初始化控制 */@WebServlet(name="ListServlet" ,urlPatterns = "/List.action")public class ListServlet extends HttpServlet&#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //设置编码 req.setCharacterEncoding("utf-8"); //接受页面的值 String command = req.getParameter("command"); String description = req.getParameter("description"); //向页面传值 req.setAttribute("command",command); req.setAttribute("description",description); //查询消息列表并传给页面。调用 ListService 的函数，将查询的结果放到 req 中 ListService listService = new ListService(); req.setAttribute("messageList",listService.queryMessageList(command,description)); //向页面跳转 req.getRequestDispatcher("/WEB-INF/jsp/back/list.jsp").forward(req,resp); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; this.doGet(req, resp); &#125;&#125; MessageDao 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package com.imooc.dao;import com.imooc.bean.Message;import java.sql.*;import java.util.ArrayList;import java.util.List;//Dao 层跟表相关，此 dao 包含跟 message 表相关的操作public class MessageDao &#123; /** * 根据查询条件查询消息列表 */ public List&lt;Message&gt; queryMessageList(String command,String description)&#123; List&lt;Message&gt;messageList = new ArrayList&lt;Message&gt;(); try &#123; Class.forName("com.mysql.jdbc.Driver"); Connection conn = DriverManager.getConnection("jdbc:mysql://127.0.0.1:3306/micro_message", "root","dfwhj43815"); StringBuilder sql = new StringBuilder("select ID,COMMAND,DESCRIPTION,CONTENT from MESSAGE where 1=1"); //创建一个 List 将需要拼接的 sql 语句查询内容装进去，最后用 for 循环取出，set 到 PreparedStatement 后执行 List&lt;String&gt; paramList = new ArrayList&lt;String&gt;(); //.trim() 方法返回一个 String 的副本，用来去除首尾的空格 if(command != null &amp;&amp; !"".equals(command.trim()))&#123; //查询sql语句拼接不用sql.append(" and command = '"+command+"'") 因为容易被SQL注入攻击 sql.append(" and COMMAND=?"); paramList.add(command); &#125; if(description != null &amp;&amp; !"".equals(description.trim()))&#123; sql.append(" and DESCRIPTION like '%' ? '%'"); paramList.add(description); &#125; PreparedStatement ps = conn.prepareStatement(sql.toString()); //在 sql 语句执行前，将参数加进去 for (int i = 0; i &lt; paramList.size(); i++) &#123; ps.setString(i + 1,paramList.get(i)); &#125; ResultSet rs = ps.executeQuery(); while(rs.next())&#123; Message message = new Message(); //添加到容器中的不是对象本身，此时操作对象仍可以改变在容器中的内容。 //也可以将对象在最后添加到容器 message.setId(rs.getString("ID")); message.setCommand(rs.getString("COMMAND")); message.setDescription(rs.getString("DESCRIPTION")); message.setContent(rs.getString("CONTENT")); messageList.add(message); &#125; &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return messageList; &#125;&#125; ListService 1234567891011121314package com.imooc.service;import com.imooc.bean.Message;import com.imooc.dao.MessageDao;import java.util.List;public class ListService &#123; //调用 MessageDao 进行数据操作，再由 ListServlet 调用。将值返回给 ListServlet public List&lt;Message&gt; queryMessageList(String command, String description)&#123; MessageDao messageDao = new MessageDao(); return messageDao.queryMessageList(command,description); &#125;&#125;]]></content>
      <categories>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>jdbc</tag>
        <tag>myBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis]]></title>
    <url>%2F2018%2F07%2F23%2FMyBatis%2F</url>
    <content type="text"><![CDATA[用 mybatis 替代 jdbcmybatis 下载地址 jdbc 版跳转此处 dao 层、mybatis 及 SqlSession 作用dao (data access objection 数据访问对象)层需求 ： 能与数据库交互 能执行 sql 语句 mybatis ：向 dao 层提供对象 SqlSession SqlSession 作用： 向 sql 语句传入参数 执行 sql 语句 获取执行 sql 语句的结果 事务的控制 如何得到 SqlSession： 通过配置文件获取数据库连接的相关信息 通过配置信息构建 SqlSessionFactory 通过 SqlSessionFactory 打开 数据库会话（SqlSession） 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package com.imooc.bean;public class Message &#123; /** * 主键 */ private String id; /** * 指令名称 */ private String command; /** * 描述 */ private String description; /** * 内容 */ private String content; public String getId() &#123; return id; &#125; public void setId(String id) &#123; this.id = id; &#125; public String getCommand() &#123; return command; &#125; public void setCommand(String command) &#123; this.command = command; &#125; public String getDescription() &#123; return description; &#125; public void setDescription(String description) &#123; this.description = description; &#125; public String getContent() &#123; return content; &#125; public void setContent(String content) &#123; this.content = content; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!-- Copyright 2009-2016 the original author or authors. Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.--&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;!--类似于 java package 的用法，用来区分不同项目,namespace 必须添加--&gt;&lt;mapper namespace="Message"&gt; &lt;!--对应 jdbc 的 message.setId(rs.getString("ID")); 等方法--&gt; &lt;!--type 表示的是数据库字段对应 java 中哪个类的对象；id 随意取名；--&gt; &lt;!--如果在数据库中为主键，则配 id colum,否则配 result colum 标签；--&gt; &lt;!--colum 对应数据库列的属性名；property 是数据库对应 java bean对象中的属性名--&gt; &lt;!--jdbcType 对应数据库中属性的类型 Int、varchar 等--&gt; &lt;resultMap type="com.imooc.bean.Message" id="MessageResult"&gt; &lt;id column="ID" jdbcType="INTEGER" property="id"/&gt; &lt;result column="COMMAND" jdbcType="VARCHAR" property="command"/&gt; &lt;result column="DESCRIPTION" jdbcType="VARCHAR" property="description"/&gt; &lt;result column="CONTENT" jdbcType="VARCHAR" property="content"/&gt; &lt;/resultMap&gt; &lt;!--select id 必须是唯一的，但与 resultMap 中的 id 可以重名--&gt; &lt;!--parameterType 是传入 sqlSession 的参数的属性--&gt; &lt;!--resultMap 指向 resultMap 标签的 id--&gt; &lt;!--OGNL 表达式 如果是自定义类型就直接写自定义属性的属性名（command）--&gt; &lt;!--可以从 java 对象中调用属性值 而且可以直接调用 java 对象的方法--&gt; &lt;!--但是 与符号 &amp;&amp; 需要转义成 &amp;amp;&amp;amp 或者用 OGNl 的 and 操作符--&gt; &lt;!--双引号 "" 需要转义成 &amp;quot;&amp;quot;--&gt; &lt;!--占位符 ? 需要用 #&#123;command&#125; 来替换，表示用 command 值来填充 ? 这是 mybatis 的解析规则--&gt; &lt;!--mybatis 配置中 sql 语句前后不需要留空格，会自动拼接--&gt; &lt;!--模糊查询 like 跟 '%' 保留，问号 ? 替换，问号两边依旧保留空格 --&gt; &lt;select id="queryMessageList" parameterType="com.imooc.bean.Message" resultMap="MessageResult"&gt; select ID,COMMAND,DESCRIPTION,CONTENT from MESSAGE where 1=1 &lt;if test="command != null &amp;amp;&amp;amp; !&amp;quot;&amp;quot;.equals(command.trim()) "&gt; and COMMAND=#&#123;command&#125; &lt;/if&gt; &lt;if test="description != null and !&amp;quot;&amp;quot;.equals(description.trim()) "&gt; and DESCRIPTION like '%' #&#123;description&#125; '%' &lt;/if&gt; &lt;/select&gt; &lt;!--单个删除--&gt; &lt;!--#&#123;&#125; 中的取值写法可以视为与 OGNL 相同：当参数为 String 与基本数据类型时，标签属性为 _parameter, 若为自定义类型则写自定义类型属性名--&gt; &lt;delete id="deleteOne" parameterType="int"&gt; delete from MESSAGE where ID = #&#123;_parameter&#125; &lt;/delete&gt; &lt;!--批量删除--&gt; &lt;delete id="deleteBatch" parameterType="java.util.List"&gt; delete from MESSAGE where ID in ( &lt;foreach collection="list" item="item" separator=","&gt; #&#123;item&#125; &lt;/foreach&gt; ) &lt;/delete&gt;&lt;/mapper&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!-- Copyright 2009-2016 the original author or authors. Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.--&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;!-- &lt;settings&gt; &lt;setting name="useGeneratedKeys" value="false"/&gt; &lt;setting name="useColumnLabel" value="true"/&gt; &lt;/settings&gt; &lt;typeAliases&gt; &lt;typeAlias alias="UserAlias" type="org.apache.ibatis.submitted.complex_property.User"/&gt; &lt;/typeAliases&gt; --&gt; &lt;environments default="development"&gt; &lt;environment id="development"&gt; &lt;transactionManager type="JDBC"&gt; &lt;property name="" value=""/&gt; &lt;/transactionManager&gt; &lt;dataSource type="UNPOOLED"&gt; &lt;property name="driver" value="com.mysql.jdbc.Driver"/&gt; &lt;property name="url" value="jdbc:mysql://127.0.0.1:3306/micro_message"/&gt; &lt;property name="username" value="root"/&gt; &lt;property name="password" value="dfwhj43815"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!--用来引入 sqlxml 配置文件的内容--&gt; &lt;mappers&gt; &lt;!--mapper 可以多个--&gt; &lt;mapper resource="com/imooc/config/sqlxml/Message.xml"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110package com.imooc.dao;import com.imooc.bean.Message;import com.imooc.db.DBAccess;import org.apache.ibatis.session.SqlSession;import java.io.IOException;import java.sql.*;import java.util.ArrayList;import java.util.List;//Dao 层跟表相关，此 dao 包含跟 message 表相关的操作public class MessageDao &#123; /** * mybytis 根据查询条件查询消息列表 */ public List&lt;Message&gt; queryMessageList(String command,String description)&#123; DBAccess dbAccess = new DBAccess(); //要在 final 中关闭此会话，所以放在外面 SqlSession sqlSession = null; //创建 List 将查询语句内容放进 List 中 List&lt;Message&gt;messageList = new ArrayList&lt;Message&gt;(); //捕获 DBAccess 抛出的异常 try &#123; sqlSession = dbAccess.getSqlSession(); //新建一个对象，将 command description 对象封装到对象中 Message message = new Message(); message.setCommand(command); message.setDescription(description); //通过 sqlSession 执行 查找sql 语句；值为 namespace.resultMap messageList = sqlSession.selectList("Message.queryMessageList",message); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally&#123; if(sqlSession!=null)&#123; sqlSession.close(); &#125; &#125; return messageList; &#125; /** * * 单条删除 */ public void deleteOne(int id)&#123; DBAccess dbAccess = new DBAccess(); //要在 final 中关闭此会话，所以放在外面 SqlSession sqlSession = null; //捕获 DBAccess 抛出的异常 try &#123; sqlSession = dbAccess.getSqlSession(); //通过 sqlSession 执行 删除sql 语句；值为 Message.mapper 的 namespace.resultMap sqlSession.delete("Message.deleteOne",id); //使用 mybatis 时对 commit 进行了封装，需要手动进行提交 /** * Connection conn; * 下面两条sql语句是自动提交互不影响的 * 但是将 conn.setAutoCommit(false) 设定后，下面的 sql 语句将处于一个事物中 * 需要进行 conn.commit(); 或 conn.roolback(); 才能一次性手动提交 * conn.prepareStatement("sql").execute(); * conn.prepareStetement("sql").execute(); * conn.commit(); * * * 如下的 sqlSession.commit()；实际上就是 conn.commmit(); */ sqlSession.commit(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally&#123; if(sqlSession!=null)&#123; sqlSession.close(); &#125; &#125; &#125; /** * 批量删除 */ public void deleteBatch(List&lt;Integer&gt; ids)&#123; DBAccess dbaccess = new DBAccess(); SqlSession sqlsession = null; try &#123; sqlsession = dbaccess.getSqlSession(); //执行删除语句 sqlsession.delete("Message.deleteBatch",ids); sqlsession.commit(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; // public static void main(String[] args) &#123;// MessageDao messageDao = new MessageDao();// messageDao.queryMessageList("","");//// &#125;&#125; 123456789101112131415161718192021222324package com.imooc.db;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import java.io.IOException;import java.io.Reader;/** * 访问数据库类 */public class DBAccess &#123; public SqlSession getSqlSession() throws IOException &#123; //通过配置文件获取数据库连接信息 Reader reader = Resources.getResourceAsReader("com/imooc/config/Configuration.xml"); //通过配置信息构建一个 SqlSessionFactory SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(reader); //通过 sqlSessionFactory 打开一个数据库会话 SqlSession sqlSession = sqlSessionFactory.openSession(); return sqlSession; &#125;&#125; 1234567891011121314package com.imooc.service;import com.imooc.bean.Message;import com.imooc.dao.MessageDao;import java.util.List;public class ListService &#123; //调用 MessageDao 进行数据操作，再由 ListServlet 调用。将值返回给 ListServlet public List&lt;Message&gt; queryMessageList(String command, String description)&#123; MessageDao messageDao = new MessageDao(); return messageDao.queryMessageList(command,description); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.imooc.service;import com.imooc.dao.MessageDao;import java.util.ArrayList;import java.util.List;/** * 维护 Service * 维护相关业务的功能 * 页面的一个动作对应了一个 Servlet ；而 Service 不应该同时增加 * 把相似的功能（修改，新增，删除，批量删除等）放在一个维护 Service 中 * 以后可以一直添加新功能 * * 将取值的转型及判断是否为空 都放在 Service 中进行 */public class MaintainService &#123; /** * 单条删除 */ public void deleteOne(String id)&#123; //判断 id 是否为空，或 空字符串 if(id != null &amp;&amp; !"".equals(id.trim())) &#123; MessageDao messageDao = new MessageDao(); //将 id 从 String 转型为 int 并作为参数传入 deleteOne 函数 messageDao.deleteOne(Integer.valueOf(id)); &#125; &#125; /** * 批量删除 */ public void deleteBatch(String [] ids)&#123; MessageDao messageDao = new MessageDao(); //创建 id 的 List List&lt;Integer&gt; idList = new ArrayList&lt;Integer&gt;(); for (String id : ids) &#123; //转型为 Integer 再传入 List if(id!=null &amp;&amp; !"".equals(id.trim())) &#123; idList.add(Integer.valueOf(id)); &#125; &#125; //调用 messageDao 的 deleteBatch 方法 messageDao.deleteBatch(idList); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142package com.imooc.servlet;import com.imooc.bean.Message;import com.imooc.service.ListService;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.sql.*;import java.util.ArrayList;import java.util.List;/** * 列表页面初始化控制 */@WebServlet(name="ListServlet" ,urlPatterns = "/List.action")public class ListServlet extends HttpServlet&#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //设置编码 req.setCharacterEncoding("utf-8"); //接受页面的值 String command = req.getParameter("command"); String description = req.getParameter("description"); //向页面传值 req.setAttribute("command",command); req.setAttribute("description",description); //查询消息列表并传给页面。调用 ListService 的函数，将查询的结果放到 req 中 ListService listService = new ListService(); req.setAttribute("messageList",listService.queryMessageList(command,description)); //向页面跳转 req.getRequestDispatcher("/WEB-INF/jsp/back/list.jsp").forward(req,resp); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; this.doGet(req, resp); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435package com.imooc.servlet;import com.imooc.service.ListService;import com.imooc.service.MaintainService;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;/** * 单条删除控制层 */public class DeleteOneServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //设置编码 req.setCharacterEncoding("utf-8"); //接受页面的值 String id = req.getParameter("id"); MaintainService maintainService = new MaintainService(); //需要接受的参数为 int 但是判断接受的值是否为空以及转型应该在 Service 中进行 maintainService.deleteOne(id); //向页面跳转 直接跳转到 list.jsp 会使得列表全部消失；列表初始化需要 listServlet 进行一些操作 //所以应该先跳到 listServlet// req.getRequestDispatcher("/WEB-INF/jsp/back/list.jsp").forward(req,resp); req.getRequestDispatcher("/List.action").forward(req,resp); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; this.doGet(req, resp); &#125;&#125; 1234567891011121314151617181920212223242526272829package com.imooc.servlet;import com.imooc.service.MaintainService;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;/** * 批量删除控制层 */public class DeleteBatchServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; req.setCharacterEncoding("utf-8"); MaintainService maintainService = new MaintainService(); String[] ids = req.getParameterValues("id"); maintainService.deleteBatch(ids); //页面跳转 req.getRequestDispatcher("/List.action").forward(req,resp); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; this.doGet(req,resp); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;&lt;%--使用 jstl--%&gt;&lt;%@taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %&gt;&lt;%--拼接当前网页相对路径--%&gt;&lt;% String path = request.getContextPath(); String basePath = request.getScheme()+"://"+request.getServerName()+":"+request.getServerPort()+path;%&gt;&lt;html xmlns="http://www.w3.org/1999/xhtml"&gt; &lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /&gt; &lt;meta http-equiv="X-UA-Compatible"content="IE=9; IE=8; IE=7; IE=EDGE" /&gt; &lt;title&gt;内容列表页面&lt;/title&gt; &lt;link href="&lt;%=basePath%&gt;/resources/css/all.css" rel="stylesheet" type="text/css" /&gt; &lt;script src="&lt;%=basePath %&gt;/resources/js/common/jquery-1.8.0.min.js"&gt;&lt;/script&gt; &lt;script src="&lt;%=basePath %&gt;/resources/js/back/list.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; function deleteOne(path,id)&#123; if(confirm("确定要删除吗？"))&#123; document.getElementById("id").value=id; document.getElementById("mainForm").action = path+"/DeleteOneServlet.action"; document.getElementById("mainForm").submit(); &#125; &#125; &lt;/script&gt; &lt;/head&gt; &lt;body style="background: #e1e9eb;"&gt; &lt;%--提交到 ListServlet 上进行初始化与查询--%&gt; &lt;form action="&lt;%=basePath%&gt;/List.action" id="mainForm" method="post" &gt; &lt;div class="right"&gt; &lt;div class="current"&gt;当前位置：&lt;a href="javascript:void(0)" style="color:#6E6E6E;"&gt;内容管理&lt;/a&gt; &amp;gt; 内容列表&lt;/div&gt; &lt;div class="rightCont"&gt; &lt;p class="g_title fix"&gt; 内容列表 &lt;a class="btn03" href="#"&gt; 新 增 &lt;/a&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;a class="btn03" href="javascript:deleteBatch('&lt;%=basePath%&gt;');"&gt; 删 除 &lt;/a&gt; &lt;/p&gt; &lt;table class="tab1"&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td width="90" align="right"&gt;指令名称：&lt;/td&gt; &lt;td&gt; &lt;input name="command" type="text" class="allInput" value="$&#123;command&#125;"/&gt; &lt;/td&gt; &lt;td width="90" align="right"&gt;描述：&lt;/td&gt; &lt;td&gt; &lt;input name="description" type="text" class="allInput" value="$&#123;description&#125;"/&gt; &lt;/td&gt; &lt;td width="85" align="right"&gt;&lt;input type="submit" class="tabSub" value="查 询" /&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;div class="zixun fix"&gt; &lt;table class="tab2" width="100%"&gt; &lt;tbody&gt; &lt;tr&gt; &lt;th&gt;&lt;input type="checkbox" id="all" onclick="#"/&gt;&lt;/th&gt; &lt;th&gt;序号&lt;/th&gt; &lt;th&gt;演示字段1&lt;/th&gt; &lt;th&gt;演示字段2&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;input type="hidden" id="id" name="id" /&gt; &lt;c:forEach items="$&#123;messageList&#125;" var="message" varStatus="status"&gt; &lt;tr &lt;c:if test="$&#123;status.index % 2 != 0&#125;"&gt;style='background-color:#ECF6EE;'&lt;/c:if&gt;&gt; &lt;%--value 值与下面的 id 表达式相同--%&gt; &lt;td&gt;&lt;input type="checkbox" name="id" value="$&#123;message.id&#125;"/&gt;&lt;/td&gt; &lt;td&gt;$&#123;status.index + 1&#125;&lt;/td&gt; &lt;td&gt;$&#123;message.command&#125;&lt;/td&gt; &lt;td&gt;$&#123;message.description&#125;&lt;/td&gt; &lt;td&gt; &lt;a href="#"&gt;修改&lt;/a&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;%--使用 get 方法提交，不适合隐私信息及中文信息提交--%&gt; &lt;%--&lt;a href="$&#123;basePath&#125;/DeleteOneServlet.action?id=$&#123;message.id&#125;"&gt;删除&lt;/a&gt;--%&gt; &lt;%--&lt;a href="$&#123;basePath&#125;/DeleteOneServlet.action?id=$&#123;message.id&#125;"--%&gt; &lt;%--onclick="return confirm('确定要删除这条信息吗？');"&gt;删除&lt;/a&gt;--%&gt; &lt;a href="#" onclick="deleteOne('$&#123;pageContext.request.contextPath&#125;',$&#123;message.id&#125;)"&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;div class='page fix'&gt; 共 &lt;b&gt;4&lt;/b&gt; 条 &lt;a href='###' class='first'&gt;首页&lt;/a&gt; &lt;a href='###' class='pre'&gt;上一页&lt;/a&gt; 当前第&lt;span&gt;1/1&lt;/span&gt;页 &lt;a href='###' class='next'&gt;下一页&lt;/a&gt; &lt;a href='###' class='last'&gt;末页&lt;/a&gt; 跳至&amp;nbsp;&lt;input type='text' value='1' class='allInput w28' /&gt;&amp;nbsp;页&amp;nbsp; &lt;a href='###' class='go'&gt;GO&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 123456789程序未报错，但 tomcat 连接后直接停止：Connected to the target VM, address: &apos;127.0.0.1:10605&apos;, transport: &apos;socket&apos;Disconnected from the target VM, address: &apos;127.0.0.1:10605&apos;, transport: &apos;socket&apos;解决方法：把 main 测试函数注释掉，通过 tomcat 发布文件 12345678910&lt;script type="text/javascript"&gt; function deleteOne(path,id)&#123; if(confirm("确定要删除吗？"))&#123; document.getElementById("id").value=id; //将路径首字母小写会使函数失效，这里对应的是web.xml 配置的 url //"/deleteOneServlet.action" document.getElementById("mainForm").action = path+"/DeleteOneServlet.action"; document.getElementById("mainForm").submit(); &#125; &#125; &lt;/script&gt; 123456789idea 未报错，点击删除，批量删除无效，网页前台控制台报错：Uncaught ReferenceError: deleteBatch is not defined at &lt;anonymous&gt;:1:1 解决：DeleteBatchServlet 后忘记加 .action 应将其提交到 web.xml 配置的 url 上$(&quot;#mainForm&quot;).attr(&quot;action&quot;,basePath+&quot;/DeleteBatchServlet.action&quot;);//此处 name = &quot;id&quot; 而不是 id = &quot;id&quot;,而且不加 value 时，checkbox 选中时返回的值是 on&lt;td&gt;&lt;input type=&quot;checkbox&quot; name=&quot;id&quot; value=&quot;$&#123;message.id&#125;&quot;/&gt;&lt;/td&gt; 12345678910111213141516171819202122232425262728网页报错：Type Exception ReportMessage For input string: &quot;&quot;Description The server encountered an unexpected condition that prevented it from fulfilling the request.Exceptionjava.lang.NumberFormatException: For input string: &quot;&quot; java.lang.NumberFormatException.forInputString(Unknown Source) java.lang.Integer.parseInt(Unknown Source) java.lang.Integer.valueOf(Unknown Source) com.imooc.service.MaintainService.deleteBatch(MaintainService.java:41) com.imooc.servlet.DeleteBatchServlet.doGet(DeleteBatchServlet.java:17) com.imooc.servlet.DeleteBatchServlet.doPost(DeleteBatchServlet.java:25) javax.servlet.http.HttpServlet.service(HttpServlet.java:661) javax.servlet.http.HttpServlet.service(HttpServlet.java:742) org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52)Note The full stack trace of the root cause is available in the server logs.问题：ids 在接受值时 String[] ids = req.getParameterValues(&quot;id&quot;);会多出一个 index[0] = &quot;&quot;;解决： 在 service 中判断是否为空 if(id!=null &amp;&amp; !&quot;&quot;.equals(id.trim())) &#123; idList.add(Integer.valueOf(id)); &#125; 123456789101112131415点击删除后，页面跳转到 http://localhost:8080/DeleteBatchServlet.action但是没有删除所选中的几条值日志：2018-07-27 12:54:52,186 [http-nio-8080-exec-3] DEBUG [Message.deleteBatch] - ==&gt; Preparing: delete from MESSAGE where ID in( ? , ? ) 2018-07-27 12:54:52,187 [http-nio-8080-exec-3] DEBUG [Message.deleteBatch] - ==&gt; Parameters: 5(Integer), 6(Integer)2018-07-27 12:54:52,188 [http-nio-8080-exec-3] DEBUG [Message.deleteBatch] - &lt;== Updates: 22018-07-27 12:54:52,226 [http-nio-8080-exec-3] DEBUG [Message.queryMessageList] - ==&gt; Preparing: select ID,COMMAND,DESCRIPTION,CONTENT from MESSAGE where 1=1 2018-07-27 12:54:52,227 [http-nio-8080-exec-3] DEBUG [Message.queryMessageList] - ==&gt; Parameters: 2018-07-27 12:54:52,229 [http-nio-8080-exec-3] DEBUG [Message.queryMessageList] - &lt;== Total: 3解决：messageDao 中传入的参数类型错误，应该为 List&lt;Integer&gt;idspublic void deleteBatch(List&lt;Integer&gt; ids) idea 导入本地 jar 包源码的方法idea 导入本地 jar 包源码 log4j 中的代码意义log4j.appender.Console.layout.ConversionPattern=%d [%t] %-5p [%c] - %m%n %d 日志生成的时间 %t 是产生日志所处的线程名称 %p 输出日志的级别，%-5p 将占5位字符，不足5位用空格填补，- 指的是在右边补空 %c 你输出日志的包以及类的全名 %m 是你附加的信息 %n 换行 代码实现demo 源码]]></content>
      <categories>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AnnTest java 注解]]></title>
    <url>%2F2018%2F07%2F18%2FAnnTest%2F</url>
    <content type="text"><![CDATA[运行机制划分注解 源码注解：只在源码中存在，编译成 .class 文件就不存在了。 编译时注解：注解在源码和 .class 文件中都存在 @Override @Deprecated @Suppvisewarning @Override ：表示覆写了某一个方法 @Deprecated ：表示一个方法已经过期，可用 @Suppvisewarning 忽略警告 运行时注解：在运行阶段还起作用，甚至会影响运行逻辑的注解。 @Autowired 1234567891011package com.ann.test;public class Test &#123; //忽略方法中的方法过期警告，也可以放在类外，忽略整个类的过期警告 @SuppressWarnings("deprecation") public void sing()&#123; Person p = new Child(); p.sing(); &#125;&#125; 123456789package com.ann.test;public interface Person &#123; public String name(); public int age(); //提示方法已过期 @Deprecated public void sing();&#125; 解析注解1234元注解RetentionPolicy，表明注解的生命周期：1、SOURCE：在原文件中有效，被编译器丢弃。 2、CLASS：在class文件有效，可能会被虚拟机忽略。 3、RUNTIME：在运行时有效。 @Inherited 元注解是一个标记注解，@Inherited阐述了某个被标注的类型是被继承的。 如果一个使用了@Inherited修饰的annotation类型被用于一个class，则这个annotation将被用于该class的子类。 注意：@Inherited annotation类型是被标注过的class的子类所继承。类并不从它所实现的接口继承annotation， 方法并不从它所重载的方法继承annotation。 @Inherited 对接口没作用，只会继承类 123456789101112package com.ann.test;import java.lang.annotation.*;import java.util.Map;//自定义注解，在 Child 中使用@Target(&#123;ElementType.METHOD,ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Inherited@Documentedpublic @interface Description &#123; String value();&#125; 12345678910111213141516171819package com.ann.test;@Description("i am class annotation")public class Child implements Person &#123; @Override @Description("i am method annotation") public String name() &#123; return null; &#125; @Override public int age() &#123; return 0; &#125; @Override public void sing() &#123; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.ann.test;import java.lang.annotation.Annotation;import java.lang.reflect.Method;//只能取到运行时加载public class PraseAnn &#123; public static void main(String[] args) &#123; try &#123; //使用类加载器加载类 Class c = Class.forName("com.ann.test.Child"); //找到类上的注解 boolean isExist = c.isAnnotationPresent(Description.class); if(isExist)&#123; //拿到注解实例 Description d = (Description) c.getAnnotation(Description.class); System.out.println(d.value()); &#125; //找到方法上的注解 Method[] ms = c.getMethods(); for (Method m : ms) &#123; boolean isMExist = m.isAnnotationPresent(Description.class); if(isMExist)&#123; Description d = m.getAnnotation(Description.class); System.out.println(d.value()); &#125; &#125; //另一种解析方法 for (Method m : ms) &#123; Annotation[]as = m.getAnnotations(); for (Annotation a : as) &#123; if(a instanceof Description)&#123; Description d = (Description) a; System.out.println(d.value()); &#125; &#125; &#125; &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 运行 PraseAnn 输出结果 i am class annotationi am method annotationi am method annotation java 注解 Element 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192package com.imooc.test;@Table("user")public class Filter &#123; /** Column column = field.getAnnotation(Column.class);得到的是字段上注解内容，然后通过 String columnName = column.value();得到就是此注解下的字段名， @Column("id") （好比上面的 column，不过只是比如column是一个注解对象） private int id; （columnName 就得到的是 id ） @Table("数据库中的表名") @Column("数据库中的列名/字段名:id/user_name...") */ @Column("id") private int id; @Column("user_name") private String userName; @Column("nick_name") private String nickName; @Column("age") private int age; @Column("city") private String city; @Column("email") private String email; @Column("mobile") private String mobile; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getUserName() &#123; return userName; &#125; public void setUserName(String userName) &#123; this.userName = userName; &#125; public String getNickName() &#123; return nickName; &#125; public void setNickName(String nickName) &#123; this.nickName = nickName; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getCity() &#123; return city; &#125; public void setCity(String city) &#123; this.city = city; &#125; public String getEmail() &#123; return email; &#125; public void setEmail(String email) &#123; this.email = email; &#125; public String getMobile() &#123; return mobile; &#125; public void setMobile(String mobile) &#123; this.mobile = mobile; &#125;&#125; 123456789101112131415package com.imooc.test;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;//作用域：类或接口@Target(&#123;ElementType.TYPE&#125;)//生命周期：运行时@Retention(RetentionPolicy.RUNTIME)public @interface Table &#123; //使用值只有一个：表名 user String value();&#125; 1234567891011121314package com.imooc.test;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;//作用域：字段、枚举的常量@Target(&#123;ElementType.FIELD&#125;)//生命周期：运行时有效@Retention(RetentionPolicy.RUNTIME)public @interface Column &#123; String value();&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485package com.imooc.test;import java.io.ObjectInputStream;import java.lang.reflect.Field;import java.lang.reflect.Method;public class Test &#123; public static void main(String[] args) &#123; Filter f1 = new Filter(); f1.setId(10);//查询 id 为 10 的用户 Filter f2 = new Filter(); f2.setUserName("lucy");//查询用户名为 lucy 的用户 Filter f3 = new Filter(); f3.setEmail("liu@sina.com,zh@163.com,77777@qq.com");//查询邮箱为其中任意一个用户 String sql1 = query(f1); String sql2 = query(f2); String sql3 = query(f3); System.out.println(sql1); System.out.println(sql2); System.out.println(sql3); &#125; private static String query(Filter f)&#123; StringBuilder sb = new StringBuilder(); //获取 class Class c = f.getClass(); //获取 table 的名字 boolean exists = c.isAnnotationPresent(Table.class); if(!exists)&#123; return null; &#125; Table t = (Table) c.getAnnotation(Table.class); String tableName = t.value(); /** * 例如为不定数量的查询条件，我们在后台写查询的时候， 类似于这样的语句 string sql ="select * from table where" 为了使语句通顺不报错，加上 where 1=1 */ sb.append("select * form").append(tableName).append("where 1=1"); //遍历所有的字段 Field[] fArray = c.getDeclaredFields(); for (Field field : fArray) &#123; //处理每个字段对应的 sql //拿到字段名 boolean fExists = field.isAnnotationPresent(Column.class); if(!fExists)&#123; continue; &#125; Column column = field.getAnnotation(Column.class); String columnName = column.value(); //拿到字段值 String filedName = field.getName(); String getMethodName = "get" + filedName.substring(0,1).toUpperCase()+filedName.substring(1); //通过反射取得 method System.out.println(getMethodName); Object fieldValue = null; try &#123; Method getMethod = c.getMethod(getMethodName); fieldValue = getMethod.invoke(f); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; //拼装 sql if(fieldValue==null ||(fieldValue instanceof Integer &amp;&amp; (Integer)fieldValue==0))&#123; continue; &#125; sb.append(" and ").append(filedName); if(fieldValue instanceof String)&#123; sb.append("=").append("'").append(columnName).append("'"); &#125;else if(fieldValue instanceof Integer) &#123; sb.append("=").append(columnName); &#125; &#125; return sb.toString(); &#125;&#125;]]></content>
      <categories>
        <category>Annotation</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>注解</tag>
        <tag>imooc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Reflection 反射]]></title>
    <url>%2F2018%2F07%2F17%2Factive-class%2F</url>
    <content type="text"><![CDATA[反射指的是可以于运行时加载,探知和使用编译期间完全未知的类. 程序在运行状态中, 可以动态加载一个只有名称的类, 对于任意一个已经加载的类,都能够知道这个类的所有属性和方法; 对于任意一个对象,都能调用他的任意一个方法和属性; 加载完类之后, 在堆内存中会产生一个Class类型的对象(一个类只有一个Class对象), 这个对象包含了完整的类的结构信息,而且这个Class对象就像一面镜子,透过这个镜子看到类的结构,所以被称之为:反射。 不是所有的实例化都是 new ，new 时必须知道这个类是什么，而很多时候做不到预先知道类名，很多框架如 Spring 应用了反射的原理。 new 创建的对象是 静态加载类，在编译时就需要加载所有可能用到的类，若在编译时找不到类直接报错。一个功能有问题，其他功能都无法使用。 class 为类类型/字节码（编译后的类） OfficeBetter.java 1234567891011121314151617181920212223class OfficeBetter&#123; public static void main(String args [])&#123; try&#123; //动态加载类，在运行时加载 Class c = Class.forName(args[0]); OfficeAble oa = (OfficeAble)c.newInstance(); oa.start(); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; &#125;&#125; OfficeAble.java 1234567interface OfficeAble&#123; //创建接口，由使用者来实现该接口,重写 start 方法 public void start();&#125; Word.java 123456789class Word implements OfficeAble&#123; public void start()&#123; System.out.println("word--starts"); &#125;&#125; 编译 javac *.java 运行 java OfficeBetter Word (main 类 + 实现接口类) 输出结果 word–starts 获取类的信息首先要获取类的类类型 Class c1 = int.class; //int 的类类型 String c2 = String.class //String 的类类型 void c3 = void.class System.out.println(c1.getName()); //打印包含包名的类的名称 System.out.println(c2.getSimpleName()); //打印不包含包名的类的名称 System.out.println(c3.getName()); //打印结果：void 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package com.imooc.reflect;public class ClassUtil &#123; public static void PrintClassMessage(Object obj) &#123; //传递的是哪个子类的对象，c 就是该子类的类类型 Class c = obj.getClass(); //getMethods() 获取所有 public 的函数，包括父类继承而来的 //getDeclaredMethods() 获取的是该类自己声明的方法，不问访问权限； Method [] ms = c.getMethods(); for(int i = 0; i &lt; ms.length; i++)&#123; //得到方法返回值类型的类类型 Class returnType = ms[i].getReturnType(); System.out.print(returnType.getName()+""); //得到方法的名称 System.out.print(ms[i].getName()+"("); //获取参数类型，得到的是参数列表的类型的类类型 Class [] paramTypes = ms[i].getParameterTypes(); for(Class class1:paramTypes)&#123; System.out.print(class1.getName()+","); &#125; System.out.println(")"); &#125; public static void printFieldMessage(Object obj) &#123; Class c = obj.getClass(); //成员变量也是对象； Field[] fs = c.getDeclaredFields(); for (Field field : fs) &#123; Class fieldType = field.getType(); String typeName = fieldType.getName(); //得到成员变量名称 String fieldName = field.getName(); System.out.println(typeName + " " + fieldName); &#125; &#125; //打印对象的构造函数信息 public static void printConMessage(Object obj)&#123; Class c = obj.getClass(); /*构造函数也是对象 java.lang.Constructor 封装了构造函数的信息 getConstructors 获取所有的 public 的构造函数 Constructor []cs = c.getConstructors(); */ Constructor [] cs = c.getDeclaredConstructors(); for (Constructor constructor : cs) &#123; System.out.print(constructor.getName()+"("); //获取构造函数的参数列表--&gt;得到的是参数列表的类类型 Class[] parameterTypes = constructor.getParameterTypes(); for (Class class1 : parameterTypes) &#123; System.out.print(class1.getName()+","); &#125; System.out.println(")"); &#125; &#125;&#125; 1234567891011package com.imooc.reflect;//PrintClassMessage 方法测试类public class ClassDemo3 &#123; public static void main(String[] args) &#123; String s = &quot;hello&quot;; ClassUtil.PrintClassMessage(s); Integer n1 = 1; ClassUtil.PrintClassMessage(n1); &#125;&#125; 123456789package com.imooc.reflect;//printieldMessage() 方法测试类public class ClassDemo4 &#123; public static void main(String[] args) &#123; ClassUtil.printFieldMessage(&quot;hello&quot;); System.out.println(&quot;==========&quot;); ClassUtil.printFieldMessage(new Integer(1)); &#125;&#125; 12345678package com.imooc.reflect;//printConMessage() 方法测试类public class ClassDemo5 &#123; public static void main(String[] args) &#123; ClassUtil.printConMessage(&quot;hello&quot;); ClassUtil.printConMessage(new Integer(1)); &#125;&#125; 方法的反射操作method.invoke(对象，参数列表) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package com.imooc.reflect;import java.lang.reflect.Method;public class MethodDemo1 &#123; public static void main(String[] args) &#123; //获取print(int a,int b)方法，获取一个方法就是获取类的信息，获取类的信息就要获得类的类类型 A a1 = new A(); Class c = a1.getClass(); /** * 获取方法 名称和参数决定 * getMethod 获取的是 public 的方法 * getDelcaredMethod 自己声明的方法 */ try &#123; Method m = c.getMethod("print", int.class, int.class);// 或 Method m = c.getMethod("pirnt", new Class[]&#123;int.class, int.class&#125;); /** * 方法的反射操作 * a1.print(10,20); 方法的反射操作是用 m 对象来进行方法的调用 和 a1.print 调用效果完全相同 * 方法没有返回值，则返回 null ，有返回值则返回具体的返回值 */ Object o = m.invoke(a1, new Object[]&#123;10, 20&#125;); System.out.println("==========="); //获取方法对象 Method m1 = c.getMethod("print", String.class, String.class); //用方法进行反射操作 o = m1.invoke(a1, "Hello", "Word"); System.out.println("==========="); Method m2 = c.getMethod("print"); //或 Method m1 = c.getMethod("print", new Class[]&#123;&#125;); m2.invoke(a1); // 或m2.invoke(a1,new Object[]&#123;&#125;); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125;class A&#123; public void print(int a,int b)&#123; System.out.println(a+b); &#125; public void print(String a,String b)&#123; System.out.println(a.toUpperCase() + "," + b.toLowerCase()); &#125; public void print()&#123; System.out.println("hello Word"); &#125;&#125; 通过反射了解泛型本质class 为类类型/字节码（编译后的类） class/method 等反射操作都是绕过编译的操作 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.imooc.reflect;import java.lang.reflect.Method;import java.util.ArrayList;public class MethodDemo4 &#123; public static void main(String[] args) &#123; ArrayList list = new ArrayList(); //泛型，只能放 String 类型； //防止加入 list1.add(10); 这种操作 ArrayList&lt;String&gt;list1 = new ArrayList&lt;&gt;(); list1.add("hello"); Class c1 = list.getClass(); Class c2 = list1.getClass(); System.out.println(c1 == c2); /** * 反射的操作都是编译之后的操作（跳过编译阶段） * c1 == c2 返回 true 说明编译之后的集合泛型是去泛型化的 * java 中集合的泛型是防止错误输入，只在编译阶段有效，绕过编译就无效 * 验证：通过方法反射操作，绕过编译 */ Method m = null; try &#123; m = c2.getMethod("add", Object.class); m.invoke(list1,10);//绕过编译操作就绕过了泛型 System.out.println(list1.size()); /** * for (String string : list1) &#123; System.out.println(string); &#125; 此时遍历会发生错误异常，提示不能将 int 转换成 String * java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String */ &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>imooc</tag>
        <tag>reflection</tag>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo next 搭建博客]]></title>
    <url>%2F2018%2F07%2F11%2Fblog-create%2F</url>
    <content type="text"><![CDATA[hexo 安装插入图片： node_modules：是依赖包public：存放的是生成的页面scaffolds：命令生成文章等的模板source：用命令创建的各种文章themes：主题_config.yml：整个博客的配置db.json：source解析所得到的package.json：项目所需模块项目的配置信息 接下来依次在命令行输入hexo ghexo s 在浏览器中打开http://localhost:4000/，看到网页则配置结束 将Hexo与github page 联系起来 设置Git的user name和email：(如果是第一次的话) git config --global user.name &quot;crow-song&quot;git config --global user.email &quot;crowsong.end@gmail.com&quot; 设置 ssh 密钥参考：https://blog.csdn.net/love_fdu_llp/article/details/38752365 https://jingyan.baidu.com/article/a65957f4e91ccf24e77f9b11.html 检查本机是否有ssh key设置 $ cd ~/.ssh 或cd .ssh 如果没有则提示： No such file or directory 如果有则进入~/.ssh路径下（ls查看当前路径文件，rm * 删除所有文件) ssh-keygen -t rsa -C &quot;crowsong.end@gmail.com&quot; 生成密钥对 之后全部 enter 就行 秘钥存放路径为：c:/Users/xxxx_000/.ssh/下 查看你生成的公钥：$ cat ~/.ssh/id_rsa.pub 复制公钥到 github 账户的 AccountSettings → SSHKeys → 点击 new SSH Key title 随意填写，公钥复制进文本域内 点击确定 确认设置 验证下这个key是不是正常工作。 $ ssh -T git@github.com # Attempts to ssh to github 键入 yes 看到： Hi username! You’ve successfully authenticated, but GitHub does not # provide shell access. 就表示设置成功。 接下来使用 hexo d 不再需要输入用户和密码了 配置Deployment同样在_config.yml文件中，找到Deployment，然后按照如下修改：repo 中是仓库地址（自己的 git 发布网址） deploy: type:git repo:https://crow-song.github.io/ branch:master 写博客新建一篇博客，执行下面的命令： hexo new post “article title” 这时候在我的 电脑的目录下 ..\hexo\source\ _posts 将会看到 article title.md 文件 用MarDown编辑器打开就可以编辑文章了。文章编辑好之后，运行生成、部署命令： hexo g hexo d 参考：https://blog.csdn.net/gdutxiaoxu/article/details/53576018 hexo的next主题个性化教程 Typora md文档多标签样式： tags: 博客创建 hexo 修改 css 样式，找到目标对应 css 文件，修改 background:#transparent （面板透明色） rgba(255,255,255,.9) 添加网易云音乐插件 在 mian.xxxx.css 中设置位置 .header-music {margin-top: 55px;margin-left: 0px; } nofollw 作用 添加图片 可用样式为 图片放在对应 md 文件的文件夹中 添加链接： ctrl+k 添加背景图： 将括号里面的这里填写背景图片地址替换为你所要显示的背景图片地址，#ffffff表示背景颜色为#ffffff(白色)修改为你想要的背景颜色代码，repeat表示图片平铺，不平铺改为no-repeat，scroll表示图片随对象滚动，图片固定不滚动改为fixed。 头像旋转放大： hover 选择器使用 选择鼠标移到链接上的样式 xxx:hover(xxx 可以是 img 也可以是类选择器等。如果直接使用 img:hover 会将插入图片一起放大) .site-author-image:hover 设置网站图标 Favicon 设置网站图标时使用 ico 图片会无法正常显示，使用 32*32 png 图片即可 Typora markdown 语法 设置标签随机大小与颜色 设置过程中出现 jQuery 报错：Uncaught ReferenceError: $ is not defined 可以添加 jQuery 引用 网站 debug 通过但部署后报错：(index):1 Mixed Content: The page at ‘https://crow-song.github.io/tags/&#39; was loaded over HTTPS, but requested an insecure script ‘http://libs.baidu.com/jquery/1.9.0/jquery.js&#39;. This request has been blocked; the content must be served over HTTPS. 将其 http 改为 https github fork 别人的博客后 404 错误https://github.com/qiubaiying/qiubaiying.github.io/issues/98在code下找到CNAME文件，将里面的内容改为：https://你的Github账号名.github.io，然后点底部的commit changes，应该就可以了 hexo d 或 hexo deploy 无反应解决: 配置文档中 _config.yml 冒号后需要加空格deploy:type: gitrepo: https://github.com/crow-song/crow-song.github.io.gitbranch: master hexo g 错误ERROR Process failed: _posts/article-title.mdYAMLException: can not read a block mapping entry; a multiline key may not be an implicit key at line 4, column 1:md 文档中开头 3 个标题冒号后也需要加空格title: article titledate: 2018-07-11 23:09:21tags: 博客创建]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>博客创建</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
