<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[BOS]]></title>
    <url>%2F2019%2F02%2F14%2Fbos%2F</url>
    <content type="text"><![CDATA[主流软件系统管理： OA 系统（Office automation）办公自动化，将现代化办公和计算机网络结合的新型办公方式 CRM 系统（Customer Relationship Management）客户关系管理，企业用 CRM 技术来管理与客户间的关系 ERP 系统（Enterprise Resource Planning）企业资源计划，针对物资管理（物流）、人力资源管理（人流）、财务资源管理（财流）、信息资源管理（信息流）集成一体的企业管理软件 Maven 项目环境使用 maven 工具可以进行 依赖管理 和 项目构建 bos-parent：父工程，统一管理依赖，是一个聚合工程（可以简化操作，只需要在聚合中执行一次，其子工程可以一起执行） bos-web bos-service bos-dao bos-domain bos-utils struts 配置文件中，action 中不写 class=“” ，就会访问org/apache/struts/struts2-core/2.3.24/struts2-core-2.3.24.jar!/struts-default.xml 下的默认 class&lt;default-class-ref class=&quot;com.opensymphony.xwork2.ActionSupport&quot; /&gt; ActionSupport 的默认方法 execute(){return SUCCESS}，当restult 中没有 name 属性，默认为 success，直接跳转到 WEB-INF 下 pages/xxx/yyy.jsp。因为 WEB-INF 下的页面收到保护不能直接访问，只能通过 action 跳转 123&lt;action name="page_*_*"&gt; &lt;result type="dispatcher"&gt;/WEB-INF/pages/&#123;1&#125;/&#123;2&#125;.jsp&lt;/result&gt;&lt;/action&gt; easyui 页面布局 layout 12345678&lt;body class="easyui-layout"&gt; &lt;div title="东部菜单" style="height:100px" data-options="region:'north'"&gt;北部区域 &lt;/div&gt; &lt;div style="width:200px" data-options="region:'west'"&gt;西部区域&lt;/div&gt; &lt;div data-options="region:'center'"&gt;中部区域&lt;/div&gt; &lt;div style="width:200px" data-options="region:'east'"&gt;东部区域&lt;/div&gt; &lt;div style="height:50px" data-options="region:'south'"&gt;南部区域&lt;/div&gt;&lt;/body&gt; 折叠面板 accordion 12345678910111213141516&lt;body class="easyui-layout"&gt;&lt;div title="管理系统" style="height:100px" data-options="region:'north'"&gt;北部区域&lt;/div&gt;&lt;div title="系统菜单" style="width:200px" data-options="region:'west'"&gt; &lt;%--fit:自适应，填充父容器--%&gt; &lt;%--arrordion 折叠面板--%&gt; &lt;div class="easyui-accordion" data-options="fit:true"&gt; &lt;div title="面板一"&gt;aaa&lt;/div&gt; &lt;div title="面板二"&gt;bbb&lt;/div&gt; &lt;div title="面板三"&gt;ccc&lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;div data-options="region:'center'"&gt;中部区域&lt;/div&gt;&lt;div style="width:200px" data-options="region:'east'"&gt;东部区域&lt;/div&gt;&lt;div style="height:50px" data-options="region:'south'"&gt;南部区域&lt;/div&gt;&lt;/body&gt; 选项卡面板 tabs 1234567891011121314&lt;body class="easyui-layout"&gt;&lt;div title="管理系统" style="height:100px" data-options="region:'north'"&gt;北部区域&lt;/div&gt;&lt;div title="系统菜单" style="width:200px" data-options="region:'west'"&gt;&lt;/div&gt;&lt;/div&gt;&lt;%--tabs选项卡面板--%&gt;&lt;div class="easyui-tabs" data-options="region:'center'"&gt; &lt;div data-options="iconCls:'icon-cut',closable:true" title="面板一"&gt;aaa&lt;/div&gt; &lt;div data-options="closable:true" title="面板二"&gt;bbb&lt;/div&gt; &lt;div title="面板三"&gt;ccc&lt;/div&gt;&lt;/div&gt;&lt;div style="width:200px" data-options="region:'east'"&gt;东部区域&lt;/div&gt;&lt;div style="height:50px" data-options="region:'south'"&gt;南部区域&lt;/div&gt;&lt;/body&gt; jquery 动态添加 tabs12345678910111213141516171819202122&lt;div class="easyui-accordion" data-options="fit:true"&gt; &lt;div data-options="iconCls:'icon-cut'" title="面板一"&gt; &lt;a id="but1" class="easyui-linkbutton"&gt;添加选项卡&lt;/a&gt; &lt;script type="text/javascript"&gt; $(function()&#123; // 页面加载完成，为按钮添加绑定事件 $("#but1").click(function()&#123; // 调用 tabs 对象的 add 方法 if($("#mytabs").tabs("exists","系统管理"))&#123; $("#mytabs").tabs("select","系统管理"); &#125;else&#123; $("#mytabs").tabs("add",&#123; title:'系统管理', iconCls:'icon-edit', closable:true, content:'&lt;iframe frameborder="0" height="100%" width="100%" src="http://www.baidu.com"&gt;&lt;/iframe&gt;' &#125;); &#125; &#125;); &#125;); &lt;/script&gt; &lt;/div&gt; Ztree 的使用方法一（了解）：利用 json 嵌套 1234567891011121314151617181920212223&lt;div title="面板二"&gt; &lt;%--展示 ztree--%&gt; &lt;%-- 这里 class 必须为 ztree，不然展开样式会无法应用 --%&gt; &lt;ul id="ztree1" class="ztree"&gt;&lt;/ul&gt; &lt;script type="text/javascript"&gt; $(function()&#123; // 页面加载后执行这段代码，表示创建 stree 属性全部为默认值 var setting = &#123;&#125;; // 构造节点数组 var zNodes = [ // 每个 json 对象表示一个节点数据 &#123;"name":"节点一","children":[ &#123;"name":"子节点一"&#125;, &#123;"name":"子节点二"&#125; ]&#125;, &#123;"name":"节点二"&#125;, &#123;"name":"节点三"&#125; ]; // 调用 api 初始化 ztree $.fn.zTree.init($("#ztree1"),setting,zNodes); &#125;); &lt;/script&gt;&lt;/div&gt; 方法二（重要）：利用简单 json 构建子节点 1234567891011121314setting 的区别，将 simpleDate enable 设置为 truevar setting2 = &#123; data: &#123; simpleData: &#123; enable: true &#125; &#125;&#125;;节点数组的区别var zNodes2 = [ // 每个 json 对象表示一个节点数据 &#123;"id":1,"pId":0,"name":"节点一"&#125;, &#123;"id":2,"pId":1,"name":"节点二"&#125;, &#123;"id":3,"pId":2,"name":"节点三"&#125;]; idea 下反向工程生成 entity 及其 hbm.xml 为模块添加 hibernate（不然后面会找不到 persistence 选项） 右侧 （或者 view tool windows） database 点击 + 号，选择 DataSource、Mysql，添加用户密码数据库 左侧（或者 view tool windows）persistence，选择右键 Generate Persistence Mapping - By DataBase Schema 添加 hibernate 持久层支持，生成实体 Bean 、配置文件 选择数据库和要存放 bean 的包，选择需要生成的 DataBase Schema 可以选择不添加 Session Factory，但需要手动添加 选择 Xml per Entity（hbm.xml）或者 JPA Annotation（注释） idea 逆向工程实践 idea hibernate 反向工程 代码抽取持久层代码抽取 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273package com.itheima.bos.dao.base.impl;import com.itheima.bos.dao.base.IbaseDao;import org.hibernate.SessionFactory;import org.springframework.orm.hibernate5.support.HibernateDaoSupport;import javax.annotation.Resource;import java.io.Serializable;import java.lang.reflect.ParameterizedType;import java.lang.reflect.Type;import java.util.List;public class BaseDaoImpl&lt;T&gt; extends HibernateDaoSupport implements IbaseDao&lt;T&gt; &#123;// 代表某个实体类型 private Class&lt;T&gt; entityClass; public BaseDaoImpl()&#123; /**在该类的构造方法中获得调用它的子类的实体类型 * this 代表调用 BaseDaoImpl 的子类,getClass 获得 BaseDaoImpl 子类的类类型， * getGenericSuperclass 表示获得 BaseDaoImpl 子类的父类的类类型，即 BaseDaoImpl 本身 * 为了获取运行时 BaseDaoImpl&lt;T&gt; 中 T 的值,需要用到 Type 的子接口的方法， * 所以将其强转成 ParameterizedType, * 使用 getActualTypeArguments 可以获得父类声明的泛型数组的值,&lt;T,a,b,c&gt; 中可以为多个值 */ ParameterizedType superclass = (ParameterizedType)this.getClass().getGenericSuperclass(); Type[] types = superclass.getActualTypeArguments(); entityClass = (Class) types[0]; &#125; /** * 因为 spring 中使用了注解的方式，没有配置 * &lt;bean id="userDao" class="xxxUserImpl"&gt; * &lt;property name="sessionFactory" ref="sessionFactory"&gt;&lt;/property&gt; * &lt;/bean&gt; * 所以 userDao 无法获得 sessionFactory 对象，需要自己配置注入方法 * 随便创建一个方法，给予 SessionFactory 对象 * spring 中已经配置了 SessionFactory，所以 mySessionFactory可以获得 SessionFactory 参数 * 利用 @Resource 注解注入到 spring * 调用 父类也就是 HibernateDaoSupport 的 * this.hibernateTemplate = createHibernateTemplate(sessionFactory);方法 * 创建 hibernateTemplate 模板对象，然后用 @Resource 注解注入到 spring * @param sessionFactory */ @Resource public void mySessionFactory(SessionFactory sessionFactory)&#123; super.setSessionFactory(sessionFactory); &#125; @Override public void save(T entity) &#123; this.getHibernateTemplate().save(entity); &#125; @Override public void delete(T entity) &#123; this.getHibernateTemplate().delete(entity); &#125; @Override public void update(T entity) &#123; this.getHibernateTemplate().update(entity); &#125; @Override public T findById(Serializable id) &#123; return this.getHibernateTemplate().get(entityClass,id); &#125; @Override public List&lt;T&gt; findAll(T entity) &#123; String hql = "FROM " + entityClass.getSimpleName(); return (List&lt;T&gt;)this.getHibernateTemplate().find(hql); &#125;&#125; 表现层代码抽取 1234567891011121314151617181920212223242526272829303132333435package com.itheima.bos.web.action;import com.opensymphony.xwork2.ActionSupport;import com.opensymphony.xwork2.ModelDriven;import java.lang.reflect.ParameterizedType;import java.lang.reflect.Type;public class BaseAction&lt;T&gt; extends ActionSupport implements ModelDriven&lt;T&gt; &#123; private T model; @Override public T getModel() &#123; return model; &#125; /** * 构造方法动态获取实体类型 * 通过反射获得子类的类类型，然后用 反射 实例化（创建 model 对象） */ public BaseAction()&#123;// 为了使用子类的方法，强转 ParameterizedType genericSuperclass = (ParameterizedType) this.getClass().getGenericSuperclass();// 获得 BaseAction &lt;T&gt; 中 T 的值（获得范型数组&lt;T&gt;) Type[] actualTypeArguments = genericSuperclass.getActualTypeArguments(); Class&lt;T&gt; entityClass = (Class&lt;T&gt;) actualTypeArguments[0];// 通过反射创建对象 try &#123; model = entityClass.newInstance(); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; &#125;&#125; easyUI 的一些方法123456789101112信息提示框$.messager.alert（title, msg, icon, fn）确认方法$.messager.confirm（title, msg, fn）右下角的信息窗$.messager.show(&#123; title:'标题', msg:'内容', timeout:3000, // 表示滑动出现跟消失 showType:'slide' &#125;)； 菜单制作 1234567891011&lt;%--制作菜单--%&gt;&lt;a data-options="iconCls:'icon-help',menu:'#mm'" class="easyui-menubutton" &gt;控制面板&lt;/a&gt;&lt;%--使用 div 创建下拉菜单--%&gt;&lt;div id="mm"&gt; &lt;%--添加修改图标--%&gt; &lt;div onclick="alert('点击事件')" data-options="iconCls:'icon-edit'"&gt;修改密码&lt;/div&gt; &lt;div&gt;联系管理员&lt;/div&gt; &lt;%--分隔符 separate 的缩写，添加分割线--%&gt; &lt;div class="menu-sep"&gt;&lt;/div&gt; &lt;div&gt;退出系统&lt;/div&gt;&lt;/div&gt; 设置拦截器将未登录用户跳转到登录页面编写拦截器，继承 struts2 框架的 MethodFilterInterceptor 类 12345678910111213141516171819public class BOSLoginInterceptor extends MethodFilterInterceptor&#123; /** * 自定义拦截器，实现未登录用户自动跳转到登录页面 * @param actionInvocation * @return * @throws Exception */ @Override protected String doIntercept(ActionInvocation actionInvocation) throws Exception &#123;// 用工具类 从 session 获取登录对象 User user = BOSUtils.getLoginUser(); if(user==null)&#123;// 没登录，跳转到登录页面,LOGIN 等常量来自于 Action 接口，拦截器没有实现 action 接口，所以无法使用，只能自己写字符串 “login” return "login"; &#125;// 放行 return invocation.invoke(); &#125;&#125; 工具类 123456789101112131415161718192021package com.itheima.bos.utils;import com.itheima.bos.domain.User;import org.apache.struts2.ServletActionContext;import javax.servlet.http.HttpSession;/** * BOS 项目的工具类 */public class BOSUtils &#123;// 获取 session 对象 public static HttpSession getSession()&#123; return ServletActionContext.getRequest().getSession(); &#125;// 获取 登录用户对象 public static User getLoginUser()&#123; return (User) BOSUtils.getSession().getAttribute("loginUser"); &#125;&#125; struts2.xml 配置拦截器 123456789101112131415&lt;interceptors&gt; &lt;!--注册自定义拦截器--&gt; &lt;interceptor name="bosLoginInterceptor" class="com.itheima.bos.web.interceptor.BOSLoginInterceptor"&gt; &lt;!--排除登录方法拦截--&gt; &lt;param name="excludeMethods"&gt;login&lt;/param&gt; &lt;/interceptor&gt; &lt;!--定义拦截器栈--&gt; &lt;interceptor-stack name="myStack"&gt; &lt;interceptor-ref name="bosLoginInterceptor"/&gt; &lt;!--struts2 自带的拦截器栈--&gt; &lt;interceptor-ref name="defaultStack"/&gt; &lt;/interceptor-stack&gt;&lt;/interceptors&gt;&lt;!--配置拦截器--&gt;&lt;default-interceptor-ref name="myStack"/&gt; 使用 validatabox 进行非空校验和长度校验 12345678910&lt;tr&gt; &lt;td&gt;新密码：&lt;/td&gt; &lt;%--使用 easyui-valudatebox 属性需要 class 中填写该值，然后可以使用 required=“true”/"required" 进行非空判断，data-optoins="validType:'length[4,6]'"，进行输入密码的长度判断--%&gt; &lt;td&gt;&lt;input required="true" data-options="validType:'length[4,6]'" id="txtNewPass" type="Password" class="txt01 easyui-validatebox" /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt; &lt;td&gt;确认密码：&lt;/td&gt; &lt;td&gt;&lt;input required="true" data-options="validType:'length[4,6]'" id="txtRePass" type="Password" class="txt01 easyui-validatebox" /&gt;&lt;/td&gt; &lt;/tr&gt; 为 jsp 页面方法添加 onclick 事件校验输入密码是否一致 1234567891011121314151617181920212223&lt;script type="text/javascript"&gt;$("#btnEp").click(function()&#123; var isValid = $("#editPasswordForm").form('validate'); if(isValid)&#123; //两次输入是否一致 var v1 = $("#txtNewPass").val(); var v2 = $("#txtRePass").val(); if(v1==v2)&#123; // 一致 $.post("UserAction_editPassword.action",&#123;"password":v2&#125;,function(data)&#123; if(data=="1")&#123; // 提示成功，关闭窗口 $("#editPwdWindow").window("close"); &#125;else&#123; $.messager.alert("提示","修改密码失败") &#125; &#125;); &#125;else&#123; $.messager.alert("提示","两次输入密码不一致"); &#125; &#125;&#125;);&lt;/script&gt; UserAction 的密码校验方法 12345678910111213141516/** * 用户修改密码方法 */ public String editPassword() throws IOException &#123; String flag="1";// 修改当前用户密码 User user = BOSUtils.getLoginUser(); try &#123; userService.editPassword(user.getId(),model.getPassword()); &#125; catch (Exception e) &#123; flag="0"; e.printStackTrace(); &#125; ServletActionContext.getResponse().getWriter().write(flag); return NONE; &#125; UserDao 的密码校验方法,使用 executeUpdate 增加复用性，传入 queryName 参数表示在 hbm.xml 的 hibernate 映射文件中配置的 query 语句名，objects 表示多个参数 123456789101112131415@Override public void executeUpdate(String queryName, Object... objects) &#123; Session currentSession = this.getSessionFactory().getCurrentSession(); Query query = currentSession.getNamedQuery(queryName);// 为 HQL 中 ？ 赋值 int i =0; int length = objects.length; for(Object obj : objects)&#123; query.setParameter(i++,obj); &#125;// 执行更新 query.executeUpdate(); &#125; hibernate 实体 bean 的 映射文件中定义更新语句 1234567891011121314151617181920212223&lt;?xml version='1.0' encoding='utf-8'?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN" "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd"&gt;&lt;hibernate-mapping&gt; &lt;class name="com.itheima.bos.domain.User" table="t_user" schema="bos32"&gt; &lt;id name="id" column="id"/&gt; &lt;property name="username" column="username"/&gt; &lt;property name="password" column="password"/&gt; &lt;property name="salary" column="salary"/&gt; &lt;property name="birthday" column="birthday"/&gt; &lt;property name="gender" column="gender"/&gt; &lt;property name="station" column="station"/&gt; &lt;property name="telephone" column="telephone"/&gt; &lt;property name="remark" column="remark"/&gt; &lt;/class&gt;&lt;%--query 语句--%&gt; &lt;query name="user.editPassword"&gt; UPDATE User SET password = ? WHERE id = ? &lt;/query&gt;&lt;/hibernate-mapping&gt; idea hibernate 映射关系配置 idea hibernae 映射关系配置 添加手机号码校验jsp 端 1234567891011121314151617181920212223242526272829&lt;tr&gt; &lt;td&gt;手机&lt;/td&gt; &lt;td&gt; &lt;script type="text/javascript"&gt; // 扩展手机号校验规则 $(function()&#123; // 为保存按钮添加保存功能 $("#save").click(function()&#123; var v = $("#addStaffForm").form("validate"); if(v)&#123; $("#addStaffForm").submit(); &#125; &#125;); var reg = /^1[3|4|5|7|8][0-9]&#123;9&#125;$/; $.extend($.fn.validatebox.defaults.rules, &#123; telephone:&#123; validator:function(value,param)&#123; return reg.test(value); &#125;, message:'手机号输入格式错误' &#125; &#125;); &#125;); &lt;/script&gt; &lt;input type="text" data-options="validType:'telephone'" name="telephone" class="easyui-validatebox" required="true"/&gt;&lt;/td&gt;&lt;/tr&gt; easyui-datagrid 创建12345678910111213141516171819202122232425262728293031323334&lt;%--使用插件提供的 api 动态创建 datagrid--%&gt;&lt;table id="mytable"&gt;&lt;/table&gt;&lt;script type="text/javascript"&gt; $(function()&#123; $("#mytable").datagrid(&#123; // 指定 ajax 发送请求地址 url:'$&#123;pageContext.request.contextPath&#125;/json/datagrid_data.json', //定义标题行所有的列 columns:[[ &#123;title:'编号',field:'id',checkbox:true&#125;, &#123;title:'姓名',field:'name'&#125;, &#123;title:'性别',field:'age'&#125;, &#123;title:'住址',field:'address'&#125; ]], rownumbers:true, singleSelect:true, // 定义工具栏 toolbar:[ &#123;text:"添加",iconCls:"icon-add", //为按钮绑定单击事件 handler:function()&#123; alert("点击添加"); &#125;&#125;, &#123;text:"删除",iconCls:"icon-remove"&#125;, &#123;text:"修改",iconCls:"icon-edit"&#125;, &#123;text:"查询",iconCls:"icon-search"&#125; ], // 显示分页条 pagination:true &#125;); &#125;);&lt;/script&gt; dao 查询分页方法 123456789101112131415161718192021222324252627/** * 通用查询分页方法 * @param pageBean */ @Override public void pageQuery(PageBean pageBean) &#123; int currentPage = pageBean.getCurrentPage(); int pageSize = pageBean.getPageSize(); DetachedCriteria detachedCriteria = pageBean.getDetachedCriteria(); //查询 pageBean 的 total （总记录数）// 指定 hibernate 发出 sql 语句的形式，rowCount 会发出 count(*) 的 sql detachedCriteria.setProjection(Projections.rowCount()); List&lt;Long&gt; countList = (List&lt;Long&gt;) this.getHibernateTemplate().findByCriteria(detachedCriteria);// 获得 list 集合的第一个数据，因为只有一个数据所以就是 记录数 Long count = countList.get(0);// 将总条数放入 pageBean pageBean.setTotal(count.intValue()); //查询 rows（当前页需要展示的数据集合）// 将 hibernate 发出 sql 语句的形式改回来，select * from xxx 的形式 detachedCriteria.setProjection(null); int firstResult = (currentPage-1)*pageSize; int maxResults = pageSize; List rows = this.getHibernateTemplate().findByCriteria(detachedCriteria, firstResult, maxResults); pageBean.setRows(rows); &#125; web 层分页查询方法 1234567891011121314151617181920212223242526272829/** * 分页查询方法 */ public String pageQuery() throws IOException &#123; PageBean pageBean = new PageBean(); pageBean.setCurrentPage(page); pageBean.setPageSize(rows);// 创建提交离线查询对象，告诉 hibernate 该查哪张表 DetachedCriteria detachedCriteria = DetachedCriteria.forClass(Staff.class); pageBean.setDetachedCriteria(detachedCriteria); staffService.pageQuery(pageBean);// 使用 json-lib 将 pageBean 转化为 json 对象，通过输出流返回页面// jsonObject 用于将单一对象转换成 josn// jsonArray 用于将数组集合转换成 json JsonConfig jsonConfig = new JsonConfig();// 指定不需要转为 josn 的属性 jsonConfig.setExcludes(new String[]&#123;"currentPage","detachedCriteria","pageSize"&#125;); String json = JSONObject.fromObject(pageBean,jsonConfig).toString();// 该方法有重载方法，可以选择是否传入 jsonConfig// String json = JSONObject.fromObject(pageBean).toString();// 将 json 用输出流写回页面 ServletActionContext.getResponse().setContentType("text/json;charset=utf-8"); ServletActionContext.getResponse().getWriter().write(json); return NONE; &#125; response.getWriter()返回的是PrintWriter，这是一个打印输出流。response.getWriter().print(),不仅可以打印输出文本格式的（包括html标签），还可以将一个对象以默认的编码方式转换为二进制字节输出 response.getWriter().write() 和 print 区别 数组集合区别 派件员批量删除按钮添加事件1234567891011121314151617181920212223242526272829&lt;script type="text/javascript"&gt;function doDelete()&#123; // 获得数据表格中选中的行，返回数组对象,如果没有选择则返回空数组 var rows = $("#grid").datagrid("getSelections"); if(rows.length==0)&#123; //没有选中记录，弹出信息 $.messager.alert("提示信息","请选择需要删除的取派员","warning"); &#125;else&#123; //选中了取派员，弹出确认框，是否删除 $.messager.confirm("确认提醒","是否需要删除选中的取派员", function(r)&#123; if(r)&#123; var array = new Array(); //确认删除，发送请求，获取所有选中取派员的 id for(var i=0;i&lt;rows.length;i++)&#123; var staff = rows[i]; var id = staff.id; array.push(id); &#125; // alert(array.join(",")); var ids = array; // location.href = "staffAction_deleteBatch.action?ids="+ids; $.post("staffAction_deleteBatch.action?ids="+ids); &#125; &#125;); &#125;&#125;&lt;/script&gt; 使用 array.join(“,”); 可以指定 array 各个数组间的分割类型，如果不用 array.join(),默认为 , 分隔符 表单回显 12345function doDblClickRow(rowIndex, rowData)&#123; $(&quot;#editStaffWindow&quot;).window(&quot;open&quot;); // 自动回显表单，rowData 参数是一个 json 字段，里面的 name 与表单名一致，所以可以回显 $(&quot;#editStaffForm&quot;).form(&quot;load&quot;,rowData);&#125; web 层表单修改 1234567891011121314151617 /** * 修改取派员信息 * @return */ public String edit()&#123;// 一般表之间有关联关系，直接用 model 数据覆盖会造成其他关联表误操作// 根据 id 查询查询原始数据 Staff staff = staffService.findById(model.getId()); //使用页面提交的数据覆盖原始数据 staff.setName(model.getName()); staff.setTelephone(model.getTelephone()); staff.setHaspda(model.getHaspda()); staff.setStation(model.getStation()); staff.setStandard(model.getStandard()); staffService.update(staff); return LIST; &#125; 文件上传页面不刷新（伪）12345&lt;iframe style="display:none" name="abc"&gt;&lt;/iframe&gt;&lt;form target="abc" action="xxx" method="post" enctype="multipart/form-data"&gt; &lt;input type="file" name="myfile"/&gt; &lt;input type="submit" value="upload"/&gt;&lt;/form&gt; easyui 中 $(&quot;#form&quot;).form(&quot;submit&quot;) 也是采用了隐藏的 iframe 来达到页面不刷新的效果，需要刷新需要使用 $(&quot;#form&quot;).submit() ocupload 的 upload 方法实现文件上传不刷新底层也是 iframe 原理，利用 jquery 页面加载完毕时修改 div 属性，创建一个 div 块来包裹代码，创建一个文件上传的 form 表单，target 提交到 iframe ，创建 type=”file” 的 input 来覆盖在原来的按钮上，点击原来的按钮时，会上传文件并且刷新隐藏的 iframe 页面 不需要点击提交按钮自动提交文件：按钮绑定一个 onchange 事件，选完文件触发 submit() 123456789&lt;script type="text/javascript"&gt; $(function()&#123; $("#myButton").upload(&#123; action:'xxx.action', name:'myFile' &#125;); &#125;);&lt;/script&gt;&lt;input id="myButton" type="button" value="上传"/&gt; hidden 是 style 的 visibility 属性，能让元素不可见，但是还是占据空间 display ：none 是将元素不再渲染，不会占据空间 我们有几种方式可以隐藏一个元素： CSS display的值是none。 type=”hidden”的表单元素。 宽度和高度都显式设置为0。 一个祖先元素是隐藏的，该元素是不会在页面上显示 CSS visibility的值是hidden CSS opacity的指是0 hidden 与 display:none 区别 display:none、visibility:hidden 区别总结 12345//页面加载完成后加载 OCUpload 插件方法$("#button-import").upload(&#123; action:'RegionAction_importXls.action', name:'regionFile'&#125;); 区域导入action 类 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * 区域导入 */ public String importXls() throws Exception &#123; System.out.println(regionFile); List&lt;Region&gt; regionList = new ArrayList&lt;Region&gt;(); //使用 POI 解析 Excel 文件 HSSFWorkbook hssfWorkbook = new HSSFWorkbook(new FileInputStream(regionFile)); HSSFSheet hssfSheet = hssfWorkbook.getSheet("Sheet1"); for(Row row : hssfSheet)&#123; if(row.getRowNum()==0)&#123; continue; &#125; String id = row.getCell(0).getStringCellValue(); String province = row.getCell(1).getStringCellValue(); String city = row.getCell(2).getStringCellValue(); String district = row.getCell(3).getStringCellValue(); String postcode = row.getCell(4).getStringCellValue();// 包装成区域对象 Region region = new Region(id,province,city,district,postcode,null,null,null);// 去除 河北省的 的 省、石家庄市 的 市、桥西区 的 区，等字符串最后一个字符 province = province.substring(0,province.length()-1); city = city.substring(0,city.length()-1); district = district.substring(0,district.length()-1);// 拼接 河北 石家庄 桥西 String info = province + city + district;// 获取各个中文字的首字母 String[] head = PinYin4jUtils.getHeadByString(info);// 把字符数组拼接成字符串 String shortcode = StringUtils.join(head);// 城市编码 shijiazhuang// 将汉字转换成拼音 String cityPY = PinYin4jUtils.hanziToPinyin(city, ""); region.setShortcode(shortcode); region.setCitycode(cityPY); regionList.add(region); &#125; regionService.saveBatch(regionList); return NONE; &#125; 分页类的重构抽取1234567891011121314151617181920212223242526272829303132333435363738//原 action 中定义的属性抽取protected PageBean pageBean = new PageBean(); public void setPage(int page) &#123; pageBean.setCurrentPage(page); &#125; public void setRows(int rows) &#123; pageBean.setPageSize(rows); &#125; DetachedCriteria detachedCriteria = null;/** * 将指定 java 对象转换为 josn，并响应到客户端 * 使用 json-lib 将 pageBean 转化为 json 对象，通过输出流返回页面 * jsonObject 用于将单一对象转换成 josn * jsonArray 用于将数组集合转换成 json * JSONObject.fromObject方法有重载方法，可以选择是否传入 jsonConfig * String json = JSONObject.fromObject(pageBean).toString(); * @param o * @param excludes */public void java2Json(Object o,String [] excludes)&#123; JsonConfig jsonConfig = new JsonConfig(); //指定不需要转为 josn 的属性 jsonConfig.setExcludes(excludes); String json = JSONObject.fromObject(o,jsonConfig).toString(); ServletActionContext.getResponse().setContentType("text/json;charset=utf-8"); try &#123; //将 json 用输出流写回页面 ServletActionContext.getResponse().getWriter().write(json); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; 分区添加功能1234//给 Region bean 添加 name get 方法。在 Region 对象转换为 json 时会增加一个 name 字段public String getName()&#123; return province + " " + city + " " + district;&#125; 模糊查询 jsp 页面 12345678&lt;td&gt;选择区域&lt;/td&gt;&lt;td&gt; &lt;input class="easyui-combobox" name="region.id" data-options="valueField:'id', textField:'name', url:'RegionAction_listajax.action', mode:'remote'" /&gt;&lt;/td&gt; 模糊查询分区 Action 12345678910111213141516171819202122/** *查询所有区域，写回 json 数据 */public String listajax()&#123; List&lt;Region&gt; list =null; if (StringUtils.isNotBlank(q)) &#123; list = regionService.findListByQ(q); &#125;else&#123; list = regionService.findAll(); &#125; this.java2Json(list,new String[]&#123;"province","city","district","postcode","shortcode","citycode","subareas"&#125;); return NONE;&#125;/** * 页面 model = 'remote' 查询条件 q */private String q;public void setQ(String q) &#123; this.q = q;&#125; 模糊查询 dao 12345public List&lt;Region&gt; findListByQ(String q) &#123; String hql = "FROM Region r WHERE r.shortcode LIKE ? OR r.citycode LIKE ? OR r.city LIKE ? OR r.province LIKE ? OR r.district LIKE ?"; List&lt;Region&gt; list = (List&lt;Region&gt;) this.getHibernateTemplate().find(hql, "%" + q + "%", "%" + q + "%", "%" + q + "%", "%" + q + "%", "%" + q + "%"); return list;&#125; 分区组合条件分页查询定义一个 json 转换方法 1234567891011121314151617//定义一个工具方法，用于将指定的表单 form 所有输入项转化为 json 数据 $.fn.serializeJson=function()&#123; var serializeObj=&#123;&#125;; var array=this.serializeArray(); $(array).each(function()&#123; if(serializeObj[this.name])&#123; if($.isArray(serializeObj[this.name]))&#123; serializeObj[this.name].push(this.value); &#125;else&#123; serializeObj[this.name]=[serializeObj[this.name],this.value]; &#125; &#125;else&#123; serializeObj[this.name]=this.value; &#125; &#125;); return serializeObj; &#125;; 方法的调用,为查询窗口的查询按钮绑定事件 123456789$("#btn").click(function()&#123; //调用工具方法，将其转换成 json 格式 var json = $("#searchForm").serializeJson(); //调用数据表格的 load 方法，重新提交一次 ajax 请求，并提交参数 $("#grid").datagrid("load",json); console.info(json); // 关闭查询窗口 $("#searchWindow").window("close");&#125;); 分区组合条件分页查询 Action 123456789101112131415161718192021222324252627282930313233343536/** * 分页列表 */ public String pageQuery()&#123; DetachedCriteria dc = pageBean.getDetachedCriteria(); String addresskey = model.getAddresskey(); if(StringUtils.isNotBlank(addresskey))&#123; // 动态添加过滤条件 dc.add(Restrictions.like("addresskey","%"+addresskey+"%")); &#125; Region region = model.getRegion(); if(region !=null)&#123; String province = region.getProvince(); String city = region.getCity(); String district = region.getDistrict(); dc.createAlias("region","r"); //根据 市、城、区 模糊查询 if(StringUtils.isNotBlank(province))&#123;// 参数一：分区对象中关联区域的属性对象名称// 参数二：任意的一个别称// dc.createAlias("region","r"); dc.add(Restrictions.like("r.province","%"+province+"%")); &#125; if(StringUtils.isNotBlank(city))&#123; dc.add(Restrictions.like("r.city","%"+city+"%")); &#125; if(StringUtils.isNotBlank(district))&#123; dc.add(Restrictions.like("r.district","%"+district+"%")); &#125; &#125; subareaService.pageQuery(pageBean); this.java2Json(pageBean,new String[]&#123;"currentPage","detachedCriteria","pageSize","decidedzone","subareas"&#125;); return NONE; &#125; dao 需要增加语句 //指定 hibernate 封装对象的方式detachedCriteria.setResultTransformer(DetachedCriteria.ROOT_ENTITY); 为了使查询两个表的结果封装到一个 Subarea 下带另一个表结构 Subarea[ {key:value}, {key:value}… [{key:value},{key:value}] ] 1234567891011121314151617181920212223242526272829 /** * 通用查询分页方法 * @param pageBean */ @Override public void pageQuery(PageBean pageBean) &#123; int currentPage = pageBean.getCurrentPage(); int pageSize = pageBean.getPageSize(); DetachedCriteria detachedCriteria = pageBean.getDetachedCriteria(); //查询 pageBean 的 total （总记录数）// 指定 hibernate 发出 sql 语句的形式，rowCount 会发出 count(*) 的 sql detachedCriteria.setProjection(Projections.rowCount()); List&lt;Long&gt; countList = (List&lt;Long&gt;) this.getHibernateTemplate().findByCriteria(detachedCriteria);// 获得 list 集合的第一个数据，因为只有一个数据所以就是 记录数 Long count = countList.get(0);// 将总条数放入 pageBean pageBean.setTotal(count.intValue()); //查询 rows（当前页需要展示的数据集合）// 将 hibernate 发出 sql 语句的形式改回来，select * from xxx 的形式 detachedCriteria.setProjection(null); //指定 hibernate 封装对象的方式 detachedCriteria.setResultTransformer(DetachedCriteria.ROOT_ENTITY); int firstResult = (currentPage-1)*pageSize; int maxResults = pageSize; List rows = this.getHibernateTemplate().findByCriteria(detachedCriteria, firstResult, maxResults); pageBean.setRows(rows); &#125; Q&amp;AQ:idea 的 maven 项目部署后，无法显示 css 等样式谷歌浏览器报错：easyui.css:1 Failed to load resource: the server responded with a status of 404 (Not Found） 提示各种 css 未找到 A:idea 应该会默认忽视 jsp 页面的 el 表达式，所以以下这种 绝对路径方式会失效 1&lt;link rel="stylesheet" type="text/css" href="$&#123;pageContext.request.contextPath&#125;/js/easyui/themes/default/easyui.css"&gt; 需要在 1&lt;%@ page contentType="text/html;charset=UTF-8" language="java" isELIgnored="false" %&gt; 添加最后的 isELIgnored=”false” ，来使得不忽视 el 表达式 Q:点击 ztree callback 中的 onClick 方法无反应A:callback 应该是跟 date 同级的属性，如果将其放在 date 属性中则无效 Q:idea 多模块 maven 项目给模块添加 hibernate 时出现报错 Module must not contain source root. The root already belongs to module idea 多模块项目报错 A:在 project Structure 中选择 module - Sources 选择父模块，将右侧的红色 content root 路径删除（一般是父模块拥有了 src、resources 等路径） Q: hibernate 错误，网页报错 500HTTP Status 500 - User is not mapped [FROM User u WHERE u.username=? AND u.password=?]; nested exception is org.hibernate.hql.internal.ast.QuerySyntaxException: User is not mapped [FROM User u WHERE u.username=? AND u.password=?] nested exception is org.hibernate.hql.internal.ast.QuerySyntaxException: User is not mapped A:配置 application.xml 中 hibernate 的映射文件注入错误 将如下配置的 / 写成了 . （com.itheima.bos.domain.*.xml） 12345&lt;property name="mappingLocations"&gt; &lt;list&gt; &lt;value&gt;classpath:com/itheima/bos/domain/*.xml&lt;/value&gt; &lt;/list&gt;&lt;/property&gt; ssh 整合报错 Q:hibernate 报错 Exception sending context initialized event to listener instance of class org.springframework.web.context.ContextLoaderListenerorg.springframework.beans.factory.BeanCreationException: Error creating bean with name ‘sessionFactory’ defined in class path resource [applicationContext.xml]: Invocation of init method failed; nested exception is org.hibernate.HibernateException: Errors in named queries: user.editPassword A: hbm.xml 中的 query 语句错误，语句最后加了一个 ； 123&lt;query name="user.editPassword"&gt; UPDATE User SET password = ? WHERE id = ?&lt;/query&gt; Q:sturts2 model 提交乱码问题A:form 表单的 method 没有写 post 方法，导致 get 提交了 Q: 500 错误HTTP Status 500 - not-null property references a null or transient value : com.itheima.bos.domain.Staff.haspda; nested exception is org.hibernate.PropertyValueException: not-null property references a null or transient value : com.itheima.bos.domain.Staff.haspda A: hibernate 映射文件中（hbm.xml）的字段属性生成时为 not null=“true”，将其改为 false Q:java.lang.NoSuchMethodExceptionjava.lang.NoSuchMethodException: com.itheima.bos.web.action.StaffAction.deleteBatch() A: 修改了 hbm.xml 文件，没有重启，修改 xml 后无法热部署，而且修改了 hbm.xml 中的 hql 语句错误 Q:hibernate 报错严重: Exception sending context initialized event to listener instance of class org.springframework.web.context.ContextLoaderListenerorg.springframework.beans.factory.BeanCreationException: Error creating bean with name ‘sessionFactory’ defined in class path resource [applicationContext.xml]: Invocation of init method failed; nested exception is org.hibernate.HibernateException: Errors in named queries: staff.deleteCaused by: org.hibernate.HibernateException: Errors in named queries: staff.delete at org.hibernate.internal.SessionFactoryImpl.(SessionFactoryImpl.java:493) at org.hibernate.boot.internal.SessionFactoryBuilderImpl.build(SessionFactoryBuilderImpl.java:444) at org.hibernate.cfg.Configuration.buildSessionFactory(Configuration.java:708) at org.hibernate.cfg.Configuration.buildSessionFactory(Configuration.java:724) at org.springframework.orm.hibernate5.LocalSessionFactoryBean.buildSessionFactory(LocalSessionFactoryBean.java:416) at org.springframework.orm.hibernate5.LocalSessionFactoryBean.afterPropertiesSet(LocalSessionFactoryBean.java:401) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeInitMethods(AbstractAutowireCapableBeanFactory.java:1637) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1574) … 22 more A:HQL 语句 “1” 用了双引号会报错，改为单引号 ‘1’ 123&lt;query name=&quot;staff.delete&quot;&gt; UPDATE Staff SET deltag=&quot;1&quot; WHERE id=?&lt;/query&gt; Q:前台传递了参数但是无法修改数据库A:struts2 属性驱动没有加 get ，set 方法，导致取到 id 为空 Q:InstantiationException 无法实例化 beanjava.lang.InstantiationException: com.itheima.bos.domain.Region at java.lang.Class.newInstance(Class.java:427) at com.itheima.bos.web.action.base.BaseAction.(BaseAction.java:32) at com.itheima.bos.web.action.RegionAction.(RegionAction.java:23) at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method) ​ at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)​ at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)​ at java.lang.reflect.Constructor.newInstance(Constructor.java:423)​ at org.springframework.beans.BeanUtils.instantiateClass(BeanUtils.java:147) A:无法实例化 InstantiationException 错误，用反射类实例化某个对象时，如果内部只有有参构造函数那么会无法实例化（没有有参构造函数时会有默认隐藏的无参构造方法），那么只要手动添加一个无参构造方法就行了 关于InstantiationException错误的原因 Q: 从 excel 表保存取派员数组方法执行，没有报错，但是也没有写进数据库堆栈跟踪 发现如下问题： InvocationTargetException InvocationTargetException是因为反射调用的方法和构造器中出现的异常导致， 继续跟踪发现： turn off your session into flushMode.commit auto or remove ‘readOnly’ marker for transcation defintion 发现应该是事务提交设置了 readOnly 或者 自动提交，于是查看自己的 serviceImpl 发现注释上只写了 @Service 没有 @Transcational，忘记写事务注释了… 因为是 List\&lt;Region> 多个 Region 的保存操作，需要添加事务。 Q: sturts2 服务端 action 返回 NONE，页面为空白无法显示 json 回显数据A: 页面响应 HTTP Status 404 - result ‘null’ not found The requested resource is not available. 堆栈跟踪发现 return NONE 抛出 IOException， 但是另一个相同的 action return NONE 确可以正确返回 json 数组。 因为在 struts.xml 中配置了 \&lt;result name=”none”/> 导致拦截器拦截，然后重定向到一个不存在的页面，导致异常。 return NONE 代表 Action 正确执行，但并不返回任何视图。然后 struts.xml 的 result 的默认配置是 dispatcher，调用 RequestDispatcher，转发页面 result 的 name 和 type 属性 Q: json 转换错误（对象互相引用错误）DEBUG DefaultDispatcherErrorHandler:84 - Exception occurred during processing request: There is a cycle in the hierarchy!net.sf.json.JSONException: There is a cycle in the hierarchy! at net.sf.json.util.CycleDetectionStrategy$StrictCycleDetectionStrategy.handleRepeatedReferenceAsObject(CycleDetectionStrategy.java:97) A: 一个对象 A 中引用了另一个的集合对象 B，B 中又含有对 A 的引用 1this.java2Json(pageBean,new String[]&#123;"currentPage","detachedCriteria","pageSize"&#125;); json 转换时忽略其循环引用的字段 如果循环嵌套的字段是需要在需要展示的字段，那么就需要将该对象的 hbm.xml 中的展示字段属性,懒加载关闭 lazy = ‘false’]]></content>
      <tags>
        <tag>java</tag>
        <tag>web</tag>
        <tag>ssh</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ssh_crm]]></title>
    <url>%2F2019%2F01%2F30%2Fssh-crm%2F</url>
    <content type="text"><![CDATA[使用 SSH 搭建 crm 项目数据库内部数据库内部分为库和服务两部分，库负责存储硬盘上的文件（表的存储方式），服务用来操作库。 JDBC （客户端）连接数据库就是连接服务部分，客户端用 sql 语句告诉服务该做什么，服务负责在库中读写数据（用 Input/OutPut）。服务从库中获得数据，将其转换成结果集（ResultSet）返回给客户端。 计算总页数： 临界值法： totalPage（总页数） totalCount（总条数） pageSize（每页显示条数） totalPage = （totalCount）+（pageSize-1））/pageSize 123&lt;%--隐藏域用来获得表单中 currentPage 的值，传入服务器--%&gt;&lt;input type="hidden" name="currentPage" id="currentPageInput" value="&lt;s:property value="#pageBean.currentPage"/&gt;"/&gt;&lt;input type="hidden" name="pageSize" id="pageSizeInput" value="&lt;s:property value="#pageBean.pageSize"/&gt;"/&gt; 123&lt;bean name="userAction" class="cn.itcast.web.action.UserAction" scope="prototype"&gt; &lt;property name="userService" ref="userService"/&gt;&lt;/bean&gt; 注入 property 的 name 值，是由 userAction 类中的 UserService 的 set 方法为准的（虽然 UserService 对象的名字一般与 set 方法一致，若出现不一致则按 set 方法命名 name 属性） 12345&lt;id name="dict_id" &gt; &lt;!-- generator:主键生成策略(用 varchar 作为主键生成策略的7种里只有2种：uuid 与 assigned--手动指定) 企业中数据字典表的维护，直接修改表维护，一般不会根据项去修改表，所以此时主键生成策略是用不到的--&gt; &lt;generator class="native"&gt;&lt;/generator&gt;&lt;/id&gt; struts2 文件上传前台： &lt;%–文件上传要求：表单 Post 提交，提交类型 enctype=”multipart/form-data” 文件需要 input type=”file”–%&gt; 后台： 1234567891011121314private File photo;//上传的文件自动上传,需要在后台提供一个与前台 input 的 type=file name 相同的属性//文件名,在提交键名后加后缀FileName，文件名会自动封装private String photoFileName;//文件 MIME 类型（text/html）（image/png）private String photoContentType;public String add() throws Exception &#123; //文件上传 photo.renameTo(new File("D:/upload/aa.jpg")); System.out.println(photoFileName); System.out.println(photoContentType); return "toList"; &#125; struts2 文件上传原理： 拦截器 FileUploadInterceptor 中判断是否多段请求，是就处理，提取 photo，photoFileName，photoContentType 的信息，封装到对应 Map 的键值对中，然后放行。参数的赋值交给后续拦截器 param 拦截器。 添加联系人列表点击按钮打开新窗口 1window.open('','','width=200,height=100') 第一个参数 url ，选填，打开新窗口路径 第二个参数 name ，选填，打开的新窗口名称 URL=&#39;${pageContext.request.contextPath}/CustomerAction_list?select=ture&#39; 在按钮提交中添加一个参数，让其在提交到 jsp 页面后可以判断是否显示 选择按钮（context 部分有一个 parameters 键值对，存放有提交的所有参数的 map，key:parameters,value:{select={Ljava.lang.String;@3926ec}}） 让翻页跟查询后都保留选择按钮，需要在进行这些操作时保留参数值，使用隐藏域将参数保留下来 1&lt;input type="hidden" name="select" value="&lt;s:property value="#parameter.select"/&gt;"/&gt; 点击 add.jsp 中选择客户按钮弹出的 list.jsp 中选择按钮将选择的 Customer 对象添加到 add.jsp 的 所属客户栏 123456&lt;%--id 用于后台查询 联系人 getById(),用 name 属性值自动传递参数到后台（struts2）。但是不需要让用户看到，设置隐藏域。id 便于前台获得 input，在打开选择窗口点击选择按钮后，获得客户选择的客户 id，赋值给 input 的 id--%&gt;&lt;input type="hidden" id="cust_id" name="cust_id" style="WIDTH: 180px"/&gt; &lt;%--客户名称不传递到后台，只用于前台显示名称,不用设置 name 属性。 id 便于前台获得 input，在打开选择窗口点击选择按钮后，获得客户选择的客户 name，赋值给 input 的 name--%&gt;&lt;input type="text" id="cust_name" style="WIDTH: 180px"/&gt; window.opener 用于获得打开该窗口的 父类的 window 对象，例如 A 窗口中点击 button 打开了 B 窗口，那么 B 窗口调用 window.opener 即可获得 A 窗口的 window 对象。用来对 A 窗口的各种 input 等 value 值进行赋值或其他操作。 1234567891011function selectCustomer(cust_id,cust_name) &#123; //获得添加页面 window 对象 var win = window.opener; //获得添加页面的 doucument 对象 var doc = win.document; //获得隐藏域和文本框 doc.getElementById("cust_id").value=cust_id; doc.getElementById("cust_name").value=cust_name; window.close(); &#125; 让不同方法的异常跳转到不同的错误页面 使用自定义异常，继承 RunTimeException，在 struts.xml 中配置各种自定义异常（需要定义异常类过多，较繁琐） 使用 try catch 包裹可能抛出异常代码，进行异常的收集与页面重定向到错误页面 service 的实现类中，对查询返回了 Customer 对象的用户名进行异常处理 1234//如果返回了对象抛出异常if(existU!=null)&#123; throw new RuntimeException("该用户名已存在");&#125; Action 中进行try catch 123456789try &#123; userService.saveUser(user); &#125; catch (Exception e) &#123; e.printStackTrace();// 将错误信息放到 request 域，传递给错误页面 ActionContext.getContext().put("error",e.getMessage());// 返回到注册页面 return "register"; &#125; struts.xml 的 Action 中 result 配置 1&lt;result name="error" &gt;/login.jsp&lt;/result&gt; jsp 页面进行异常信息的输出 1&lt;TD style="HEIGHT: 18px" colspan="2" &gt;&lt;font color="red" &gt;&lt;s:property value="#error" /&gt; &lt;/font&gt;&lt;/TD&gt; 添加登录拦截器123456789101112131415161718192021222324252627package cn.itcast.web.interceptor;import cn.itcast.domain.User;import com.opensymphony.xwork2.ActionContext;import com.opensymphony.xwork2.ActionInvocation;import com.opensymphony.xwork2.interceptor.MethodFilterInterceptor;import java.util.Map;public class PrivilegeInterceptor extends MethodFilterInterceptor&#123; @Override //不校验登录注册方法 protected String doIntercept(ActionInvocation actionInvocation) throws Exception &#123;// 获得 session Map&lt;String, Object&gt; session = ActionContext.getContext().getSession();// 获得登录标示 User user = (User) session.get("user");// 判断标记是否存在，存在就放行，不存在就重定向到登录页面 if(user!=null)&#123; //放行 return actionInvocation.invoke(); &#125;else&#123; return "toLogin"; &#125; &#125;&#125; 1234&lt;!--如果没有登录则跳转到登录页面，因为在 CustomerAction 与 LinkManAction 中都要使用，所以配置全局 result--&gt;&lt;global-results&gt; &lt;result name="toLogin" &gt;/login.jsp&lt;/result&gt;&lt;/global-results&gt; 回显就是将本身 input 的 name 属性值赋给 value 隐藏域 id 回显 1&lt;input type="hidden" id="cust_id" name="customer.cust_id" style="WIDTH: 180px" value="&lt;s:property value="#linkMan.customer.cust_id"/&gt;"/&gt; 客户名称回显： 1&lt;input type="text" id="cust_name" style="WIDTH: 180px" value="&lt;s:property value="#linkMan.customer.cust_name"/&gt;"/&gt; 性别回显判断（判断性别的值 1 与 2 要加引号）： 1&lt;input type="radio" value="1" name="lkm_gender" &lt;s:property value="#linkMan.lkm_gender=='1'?'checked':''"/&gt;&gt;男 原生 sql 查询123456789101112131415161718@Override @SuppressWarnings("all") public List&lt;Object[]&gt; getIndustryCount() &#123;// 原生 sql 查询 List&lt;Object[]&gt; list = getHibernateTemplate().execute(new HibernateCallback&lt;List&gt;() &#123; String sql=" select dict_item_name,count(*) total " + " from cst_customer c,base_dict bd where " + " c.cust_industry=bd.dict_id " + " group by " + " c.cust_industry "; @Override public List doInHibernate(Session session) throws HibernateException &#123; SQLQuery query = session.createSQLQuery(sql); return query.list(); &#125; &#125;); return list; &#125; Spring 注解spring 配置文件 application.xml 配置 12345678910111213141516171819202122232425262728293031323334353637 &lt;!--读取配置文件--&gt; &lt;context:property-placeholder location="classpath:db.properties"/&gt; &lt;!--将 dataSource 放入 spring 容器--&gt; &lt;bean name="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;property name="jdbcUrl" value="$&#123;jdbc.jdbcUrl&#125;"/&gt; &lt;property name="driverClass" value="$&#123;jdbc.driverClass&#125;"/&gt; &lt;property name="user" value="$&#123;jdbc.user&#125;"/&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"/&gt; &lt;/bean&gt; &lt;!--核心事务管理器--&gt; &lt;bean name="transactionManager" class="org.springframework.orm.hibernate5.HibernateTransactionManager"&gt; &lt;property name="sessionFactory" ref="sessionFactory"/&gt; &lt;/bean&gt; &lt;!--开启组件扫描类中的注解 component-组件，scan-扫描 --&gt; &lt;context:component-scan base-package="cn.itcast"&gt;&lt;/context:component-scan&gt; &lt;!--开启注解事务--&gt; &lt;tx:annotation-driven transaction-manager="transactionManager"/&gt; &lt;bean name="sessionFactory" class="org.springframework.orm.hibernate5.LocalSessionFactoryBean"&gt; &lt;!--将连接池注入到 sessionFactory,hibernate 会通过连接池获得连接--&gt; &lt;property name="dataSource" ref="dataSource"/&gt; &lt;!--加载配置方案2：在 spring 配置中放置 hibernate 配置信息--&gt; &lt;!--配置 hibernate 基本信息--&gt; &lt;property name="hibernateProperties"&gt; &lt;props&gt; &lt;prop key="hibernate.dialect"&gt;org.hibernate.dialect.MySQLDialect&lt;/prop&gt; &lt;!--可选配置--&gt; &lt;prop key="hibernate.show_sql"&gt;true&lt;/prop&gt; &lt;prop key="hibernate.format_sql"&gt;true&lt;/prop&gt; &lt;prop key="hibernate.hbm2ddl.auto"&gt;update&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;!--引入元数据--&gt; &lt;property name="mappingDirectoryLocations" value="classpath:cn/itcast/domain"/&gt; &lt;/bean&gt;&lt;/beans&gt; dao 注入，需要在每个 dao 的实现类中，用 @Repository(“baseDao”) 将该 dao 托管到 spring。用 @Resource(name=”sessionFactory”) ，在一个 set 上用 父类的 setSessionFactory 将 sessionFactory 注入到每个 dao 实现类中，以便能使用 getHibernateTemplate() 提供的方法完成基本的增删改查功能。 12345678@Repository("baseDao")public class BaseDaoImpl&lt;T&gt; extends HibernateDaoSupport implements BaseDao&lt;T&gt; &#123; private Class clazz;//用于接受运行期泛型类型// 注入 sessionFactory @Resource(name="sessionFactory") public void setSF(SessionFactory sf)&#123; super.setSessionFactory(sf); &#125; service 注入 在每个 service 实现类上注释 @Service ，将该 Service 交给 spring 管理。@Transactional 用来开启事务，具体方式与 xml 配置一样。@Resource(name=”baseDictDao”) 用来在 调用的 dao 定义上注释，来表示从 spring 获得被托管的 dao（spring 帮助创建该 dao 的实例对象） 12345@Service("baseDictService")@Transactional(isolation= Isolation.REPEATABLE_READ,propagation = Propagation.REQUIRED,readOnly = false)public class BaseDictServiceImpl implements BaseDictService &#123; @Resource(name="baseDictDao") private BaseDictDao baseDictDao; action 注入 在每个 action 上注释 @Controller(“baseDictAction”)，将该 action 交给 spring 管理，@Scope(“prototype”) 表示多例方法，struts 必须是多例创建才行，因为每个 访问都要创建一个 ActionContext，不是多例会出现问题。 用 @Resource(name=”baseDictService”)，表示从 spring 获得托管在 spring 上的 Service ，让其帮助创建对应的 Service 对象。 1234567@Controller("baseDictAction")@Scope("prototype")public class BaseDictAction extends ActionSupport &#123; private String dict_type_code; @Resource(name="baseDictService") private BaseDictService baseDictService; Q&amp;AA: HTML 为红色报错：Element HTML must be declareddtd是定义html标记的规则的，不兼容这一个dtd 123&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;!--&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3c.org/TR/1999/REC-html401-19991224/loose.dtd"&gt;--&gt;&lt;HTML xmlns="http://www.w3.org/1999/xhtml"&gt; 将第一个 DOCTYPE 注释掉，或换成第二个 A: applicationContext.xml 配置错误，12345678910&lt;filter&gt; &lt;!--在视图 jsp 中 session 还是打开的--&gt; &lt;filter-name&gt;openSessionInView&lt;/filter-name&gt; &lt;!--OpenSessionInViewFilter 下红色波浪线--&gt; &lt;filter-class&gt;org.springframework.orm.hibernate5.support.OpenSessionInViewFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;openSessionInView&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; Error:(24, 23) ‘org.springframework.orm.hibernate5.support.OpenSessionInViewFilter’ is not assignable to ‘javax.servlet.Filter’ 12345678910&lt;!--struts2 核心过滤器--&gt;&lt;filter&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;!--StrutsPrepareAndExecuteFilter 下红色波浪线--&gt; &lt;filter-class&gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; Error:(34, 23) ‘org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter’ is not assignable to ‘javax.servlet.Filter’ A: 没有导入 servlet 包，在 module 中选中项目点击右侧绿色 + 号， libraries 选择 tomcat 的 lib 添加即可。 如果 OpenSessionInViewFilter、StrutsPrepareAndExecuteFilter 等类的文字是红色，则需要导入 lib 目录下 jar 包 Q: 从 svn 下载的项目导入路径全为红色，但运行没问题xml &lt;context:property-placeholder location=&quot;classpath:db.properties&quot;/&gt; &lt;hibernate-mapping package=&quot;cn.itcast.domain&quot; &gt; 等配置路径都为红色。 A: 在 module 将当前项目 src 目录标记为 Sources 即可解决问题，亦或是多模块项目则将该模块添加到 project 中，在 module 中导入下载 模块的的 iml 文件 多模块错误 Q: jsp action 页面报错 Module “” must not contain source root . The root already belongs to module “*”.多模块错误 A:A: 在 module 将当前项目 src 目录标记为 Sources 即可解决问题，亦或是多模块项目则将该模块添加到 project 中，在 module 中导入下载 模块的的 iml 文件 Q:No result defined for action cn.itcast.web.action.CustomerAction and result errorHibernate: select count(*) as y0_ from cst_customer this_ A: 12//计算总页数(加上临界值)this.totalPage = (this.totalCount + pageSize - 1) / this.pageSize; 此处的 pageSize 没有加 this 导致 pageBean 构造函数错误 Q:404 error No result defined for action cn.itcast.web.action.CustomerAction and result error A: action 中配置的 result 应与 action 中 返回的值一致 return “edit” 123&lt;action name="CustomerAction_*" class="customerAction" method="&#123;1&#125;" &gt; &lt;result name="edit" &gt;/jsp/customer/add.jsp&lt;/result&gt;&lt;/action&gt; Q：数据字典下拉列表(整个列表)不显示，1234loadSelect("009","source","cust_source.dict_id" &lt;s:if test="#customer.cust_source!=null"&gt;, &lt;s:property value='#customer.cust_source.dict_id'/&gt; &lt;/s:if&gt;); A:在 \&lt;s:if> 前多加了一个 , Q：数据字典下拉列表没有回显A：录入时 typeCode 与 调用 loadSelect 函数时查询所得 customer 传入的 typeCode 不一致，重新录入正确的 Customer 对象 1234567891011121314151617181920212223242526function loadSelect(typeCode,positionId,selectName,selectedId)&#123; //创建 select 对象，指定其 name 属性 var $select = $("&lt;select name="+selectName+"&gt;&lt;/select&gt;"); //提示选项，请选择 $select.append($("&lt;option value=''&gt;---请选择---&lt;/option&gt;")); //使用 jquery 的 ajax 访问后台 action $.get("$&#123;pageContext.request.contextPath&#125;/BaseDictAction", &#123; dict_type_code:typeCode &#125;, //返回 json 数组对象，对其遍历。遍历中创建的 option 对象，判断是否回显，添加到 select 中 function(data)&#123; // alert(data); $.each( data, function(i, json)&#123; var $option = $("&lt;option value='"+json['dict_id']+"'&gt;"+json['dict_item_name']+"&lt;/option&gt;"); if(json['dict_id']==selectedId)&#123; // 判断是否要回显 $option.attr("selected","selected"); &#125; $select.append($option); // alert(json["dict_item_name"] ); &#125;); &#125;, type="json" ); //将组装好的 select 放到页面指定位置 $("#"+positionId).append($select);&#125; Q:No result defined for action cn.itcast.web.action.LinkManAction and result errorA: 打断点发现 1pageBean pb = lms.getPageBean(dc,currentPage,pageSize); 中的 lms 值为 cust_name like %…% 的查询语句,应该是之前的修改没有生效,重启 intellj idea 即可解决 为什么会发生 error result 这种错误:在 sturts.xml 中配置了如下出现异常就跳转错误页面的设置 1234&lt;!--开启运行时异常--&gt;&lt;global-exception-mappings&gt; &lt;exception-mapping exception="java.lang.RuntimeException" result="error"&gt;&lt;/exception-mapping&gt;&lt;/global-exception-mappings&gt; 可以在 LinkManAction 下配置如下 result 在跳转页面 list.jsp 中添加 \&lt;s:debug>\&lt;s:debug> 1&lt;result name=&quot;error&quot; &gt;/jsp/linkman/list.jsp&lt;/result&gt; Q:进行双条件框条件查询无结果A: 后台采用 id 查询,前台用选择框进行客户名称的选择,并自动填入 名称 与 id，如果进行手动输入名称，该页面会无法获得 customer.cust_id ，从而后台无法查询到该条件的对应结果。 123if((linkMan.getCustomer()!=null))&#123; dc.add(Restrictions.eq("customer.cust_id",linkMan.getCustomer().getCust_id()));&#125; 1234567891011function selectCustomer(cust_id,cust_name) &#123; //获得添加页面 window 对象 var win = window.opener; //获得添加页面的 doucument 对象 var doc = win.document; //获得隐藏域和文本框 doc.getElementById("cust_id").value=cust_id; doc.getElementById("cust_name").value=cust_name; window.close(); &#125; Q: 拦截器登录页面跳转异常No result defined for action cn.itcast.web.action.LinkManAction and result toLogin A:修改 ctruts.xml 的 Action result 为全局 result 1234&lt;!--如果没有登录则跳转到登录页面，因为在 CustomerAction 与 LinkManAction 中都要使用，所以配置全局 result--&gt;&lt;global-results&gt; &lt;result name="toLogin" &gt;/login.jsp&lt;/result&gt;&lt;/global-results&gt; Q：500 异常 400 异常500问题： ​ Unable to instantiate Action, saleVisitAction, defined for ‘SaleVisitAction_add’ in namespace ‘/‘saleVisitAction ​ description The server encountered an unexpected condition that prevented it from fulfilling the request. A: spring 配置文件 application.xml 中的 action name 与 struts2 配置文件 struts 中的 action class 不一致 400问题： ​ No result defined for action cn.itcast.web.action.SaleVisitAction and result error A: struts 配置文件中 ，result 的 name 应该与 action 中 return 的值相同，表示返回的是什么页面 1&lt;result name="toList" type="redirectAction"&gt; debug 显示 ActionMapping{name=’SaleVisitAction_add’, namespace=’/‘, method=’null’, extension=’null’, params=null, result=null} Q:hibernate 错误提示Unable to evaluate the expression Method threw ‘org.hibernate.LazyInitializationException’ exception. A: 多表的关系问题，经查询应该跟级联操作有关，删除数据库相关数据表，让其自动重新创建。 [http-nio-8080-exec-4] ERROR org.hibernate.internal.SessionImpl - HHH000346: Error during managed flush [object references an unsaved transient instance - save the transient instance before flushing: cn.itcast.domain.Customer] A：级联操作问题： 在页面上写了子表ID的隐藏表单域，传到后面的时候value=”” ,不是value=null，所以执行的时候hibernate判断为更新，所以报错了 用来回显 visit_id 的 input 隐藏域，如果使用了 hibernate 的 saveOrUpdate 方法，则会自动根据 visit_id 是否为null 判断是添加还是升级操作，但是后台根据此隐藏域获得无 visit_id 时，是空字符串 “”，根据 hibernate 判断依旧为升级操作，所以会出现异常。 1&lt;input type="hidden" name="visit_id" value="&lt;s:property value="#saleVisit.visit_id" /&gt;" /&gt; 参考：https://blog.csdn.net/ailaojie/article/details/82689536]]></content>
      <categories>
        <category>SSH</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>SSH</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ssh]]></title>
    <url>%2F2019%2F01%2F15%2Fssh%2F</url>
    <content type="text"><![CDATA[hibernateidea 下 hibernate 的创建 idea 创建 bean.hbm.xml 与 hibernate.cfg.xml 在配置 javaBean.hbm.xml 时，column 如果不配，自动根据属性名 name 填写，如果表的 列名 与 代码的属性名 相同，则不需要配置 column hibernate 中对象的状态 瞬时状态：没有 id，没有在 session 缓存中 持久化状态：有 id ，在 session 缓存中 游离/托管状态：有 id ，没有在 session 缓存中 save 方法实质是将 瞬时状态的转变成持久化状态 执行 save 方法时，为了将对象转换成持久化状态必须生成 id 值，如果需要的话会执行 insert 语句来生成：主键自增的情况下 如果是 increament ：查询数据库 id 最大值作为主键的情况下会执行查询数据库 id 最大值的 sql 语句 持久化对象的特点：持久化对象的任何变化都会自动同步到数据库 save/update ：将瞬时/游离状态的对象转变为持久化状态（saveOrupdate 方法可以通用） delete/close：将持久化状态的对象转变为 瞬时/游离状态 get 直接获得一个持久化状态的对象 hibernate 的作用：把希望持久化到数据库的数据，其对应的对象状态变为持久化 hibernate 事务sf.getCurrentSession();//获得当前与 Thread 绑定的 session（多次获得都是同一个 session） 需要配置 hibernate.cfg.xml 中的&lt;property name=&quot;hibernate.connection.isolation&quot;&gt;4&lt;/property&gt;才能使用 通过 getCurrentSession() 获得的 session 事务提交后，session 会自动关闭，不需要 close HQL 语句只有对象名和属性名，没有数据库的任何表名和属性名 hibernate 一级缓存+缓存快照作用：可以提高查询效率，可以减少不必要的修改语句的发送 程序–&gt;get 方式查询时–&gt;hibernate 先从缓存中查看是否有相同 id 的对象，如果有直接返回缓存中；如果没有，发送 sql 语句查询数据库–&gt;数据库返回一个 ResultSet–&gt;hibernate 将 resultSet 中的数据组装成两个对象，并存入 session 缓存中，另一个存入缓存快照–&gt;session 中的对象返回程序–&gt; 如果程序修改了对象进行事务提交–&gt;hibernate 会比对缓存中对象和快照，如果有变化会同步到数据库，如果没变化则不修改 所以在执行多条 相同 get 语句查询相同 id 对象时，只会执行一次查询数据库操作，其余的都在缓存中查找。 inverse（反转） 属性：inverse 属性为空时，默认 false 表示维护当前外键关系，true 表示放弃维护 一对多时，一的一方放弃维护 当遇到多对多关系时，必须有一方放弃维护关系，具体放弃方由业务决定 例：员工入职时需要指定职位，此时由员工维护，职位放弃维护 cascade （级联操作）属性：save-update:级联保存更新 delete：级联删除 all：级联保存更新+删除 用来简化代码书写，一般只用 save-update，delete 在多对多表中容易多张表关联删除 主键生成策略increment：代理主键，适合于所有数据库，由hibernate维护主键自增，和底层数据库无关，但是不适合于2个或以上hibernate进程。 identity：代理主键，适合于Mysql或ms sql server等支持自增的dbms，主键值不由hibernate维护。 sequence：代理主键，适合于oracle等支持序列的dbms，主键值不由hibernate维护，由序列产生。（Oracle中很常用） native：代理主键，根据底层数据库的具体特性选择适合的主键生成策略，如果是mysql或sqlserver，选择identity，如果是oracle，选择sequence。（推荐） hilo：代理主键，hibernate把特定表的字段作为hign值，生成主键值 uuid.hex：代理主键，hibernate采用uuid 128位算法生成基于字符串的主键值 assigned：适合于应用程序维护的自然主键。 用 varchar 作为主键生成策略的7种里只有2种：uuid 与 assigned–手动指定， 企业中数据字典表的维护，直接修改表维护，一般不会根据项去修改表，所以此时主键生成策略是用不到的。 Hibernate主键生成策略 Hibernate各种主键生成策略与配置详解 123&lt;id name=&quot;dict_id&quot; &gt; &lt;generator class=&quot;native&quot;&gt;&lt;/generator&gt;&lt;/id&gt; 一对多，多对一ORM O:对象 一的一方使用集合，多的一方直接引用一的一方 R:关系型数据库 多的一方使用外键引用一的一方的主键 M:映射文件 12345678一：&lt;set name=""&gt; &lt;key column="外键"&gt; &lt;one-to-many class=""/&gt;&lt;/set&gt;多：&lt;many-to-one name="" column="" class=""&gt; 在一张表的外键访问另一张表的主键时，外键字段的值是多个的，也就是多条记录，是多的一方。另一张表因为是主键，所以只有一个，是一的一方。 在配置时，如果多的一方需要通过数据字典访问一的一方，那么多的一方需要配置多对一关系。如果一的一方不需要通过数据字典反过来访问多的一方，则在数据字典实体中不需要配置一对多关系 多对多ORM O:对象 两方都使用集合 R:关系型数据库 使用中间表，至少两列，作为外键引用两张表的主键 M:映射文件 12345多：&lt;set name="" table="中间表名"&gt;&lt;key column="外键,别人引用我的"/&gt;&lt;many-to-many class="" column="我引用别人的"/&gt;&lt;/set&gt; Hibernate Restrictions 方法 说明 Restrictions.eq ＝ Restrictions.allEq 利用Map来进行多个等于的限制 Restrictions.gt ＞ Restrictions.ge ＞＝ Restrictions.lt ＜ Restrictions.le ＜＝ Restrictions.between BETWEEN Restrictions.like LIKE Restrictions.in in Restrictions.and and Restrictions.or or Restrictions.sqlRestriction 用SQL限定查询 全称： QBC常用限定方法 Restrictions.eq –&gt; equal,等于. Restrictions.allEq –&gt; 参数为Map对象,使用key/value进行多个等于的比对,相当于多个Restrictions.eq的效果 Restrictions.gt –&gt; great-than &gt; 大于 Restrictions.ge –&gt; great-equal &gt;= 大于等于 Restrictions.lt –&gt; less-than, &lt; 小于 Restrictions.le –&gt; less-equal &lt;= 小于等于 Restrictions.between –&gt; 对应SQL的between子句 Restrictions.like –&gt; 对应SQL的LIKE子句 Restrictions.in –&gt; 对应SQL的in子句 Restrictions.and –&gt; and 关系 Restrictions.or –&gt; or 关系 Restrictions.isNull –&gt; 判断属性是否为空,为空则返回true Restrictions.isNotNull –&gt; 与isNull相反 Restrictions.sqlRestriction –&gt; SQL限定的查询 Order.asc –&gt; 根据传入的字段进行升序排序 Order.desc –&gt; 根据传入的字段进行降序排序 MatchMode.EXACT –&gt; 字符串精确匹配.相当于”like ‘value’” MatchMode.ANYWHERE –&gt; 字符串在中间匹配.相当于”like ‘%value%’” MatchMode.START –&gt; 字符串在最前面的位置.相当于”like ‘value%’” MatchMode.END –&gt; 字符串在最后面的位置.相当于”like ‘%value’” Restrictions 用法 懒加载get 方法，立即加载，执行方法时执行 sql 语句查询结果 load 方法（默认）：在执行时，不发送任何 sql 语句，返回一个对象，使用该对象时才执行查询（懒加载/延迟加载：只是获得没有使用，使用时查询）。可以在 class 元素上配置 lazy 属性控制，默认 lazy=true 实行懒加载，改为 lazy=false 则不执行懒加载。 load 方法使用了代理 ，使 返回的代理对象能够在使用属性时，根据关联 session 查询数据库，加载数据 打印对象中 $ 符号，指代理对象，可以对方法进行改造或增强 关联级别查询 为了提高效率，fetch 选择 select ，lazy 取 true，全部为默认值 no-session-Exception:因为在代理对象被放到页面时，session 一定关闭了，所以需要扩大 session 作用域 Struts2用来代替 servlet 层进行处理访问服务器的请求的 servlet 线程安全问题servlet 的线程不安全问题 servlet 只创建一个对象实例，所以只有一个成员变量（它随着对象的创建而创建），多个用户访问 servlet 只修改一个成员变量，可能会有覆盖问题，会导致线程安全问题 struts2 的 Action 在每次请求时都会创建一个新的 Action 实例对象，所以是线程安全的，可以定义成员变量接收参数 struts1 基于 servlet，servlet 有线程不安全问题 struts2 基于 filter 过滤器 struts2 的核心是拦截器（inteceptor） 拦截器封装了很多功能，且用了可插拔设计，使用了 aop 思想（将纵向重复代码，横向抽取），在调用 action 前先调用 inteceptor struts2 Result 详解 i18n:国际化：配置多国语言，根据浏览器发送的不同编码，读取不同语言版本的配置文件，动态将配置文件信息显示到页面。解决 post 提交乱码问题 reload 热加载 redeploy 热部署 动态配置方法调用：通配符方式 POJO：不用继承任何父类，也不需要实现任何接口的类 tomcat 没有 artifact 的配置 idea 项目配置简介 struts 的数据中心：ActionContext（它是一个 Map）用来获得原生 ServletAPI 生命周期：每次请求都会创建一个对应的 ActionContext 对象，请求处理完，ActionContext 销毁。ActionContext 中只是获得 各个域 及对象（request,response,sevletContext 等）的引用，不会影响其生命周期。 request 域 与 session 域 application 域，实质就是在 HttpRequest/HttpSession/servletContext 的一块空间中创建了 Map，用 set/getAttribute 来存取值（param 参数存取也是一个 Map） ActionContext 与 request 的生命周期相同，所以官方推荐使用 ActionContext 代替 requestScope struts2 的 ActionContext 加强了 request 的方法，使其在取值时仍旧使用原有的方法。调用的就是 request.getAttribute() 方法， 先去 request 域中找，也去 ActionContext 的域中找。存值用 ActionContext ； struts 结果集：转发、重定向、转发 Action、重定向 Action Struts mvcc:Filter m:Action v:Result 获得参数的方式有 struts2 的话，表单参数会自动封装到栈顶对象 属性驱动 - Action 准备与参数建同名属性，创建参数的 set 方法 对象驱动 - Action 准备与参数建同名属性（页面属性名需要改为 Obj.property），将属性封装到对象中，模型对象驱动栈顶对象（ModelDriven\&lt;栈顶对象>）不能生成 get set 方法 模型驱动 - 实现 ModelDriven 接口 - 实现 getModel 方法，返回需要封装参数的对象（可以直接返回对象，页面属性名跟 servlet 一样，但返回多对象麻烦） 复杂参数封装 List 集合：提交键：list list[index] Map 集合： 提交键：map[‘key’] 为什么使用模型驱动： 当我们使用params拦截器完成数据自动封装的时候，如果要封装的是JavaBean对象，那么在web表单中就必须的name写上javaBean.属性名…. 这样的话，web层和Action层就耦合了…因为在web层必须要知道封装的JavaBean对象是什么才能够实现自动封装！ 而模型驱动就解决了这个问题！即时不知道Action层的JavaBean对象是什么，也能够完成数据自动封装！ struts2 模型驱动理解 实现方式：参数拦截器 &lt;interceptor name=&quot;params&quot;class=&quot;com.opensymphony.xwork2.interceptor.ParametersInterceptor&quot;/&gt; 数据自动封装获得参数 struts2 获得参数 OGNL 与 Struts2OGNL：Object-Graph Navigation Language 对象视图导航语言 OGNL 与 struts2 没关系，是一种独立的表达式语言 el 表达式 ${user.addr.name} 等表达式是 对象视图导航 OGNL 本质跟 el 表达式差不多，但添加了许多功能 OGNL 包含在 struts2 的包中，包名为：”ognl-var.jar” el表达式的取值范围为 11 大内置对象 OGNL 的取值范围是 OGNLContext：OGNL上下文对象 OGNLContext 内部有两部分组成：root/context root 中可以放置任何对象 context 中需要存放 map （键值对） OGNL 可以调用静态方法（不需要对象） OGNL 表达式要运行先要准备一个 OGNLContext，struts2 准备了一个 ValueStack（值栈） 作为 OGNLCOntext， OGNLContext 由两部分构成，一部分叫 Root，放置的是一个栈，一部分叫 Context，将 AcitonContext （数据中心）放入 默认情况下 Root（栈）中放置当前访问的 Action 对象 ActionContext 下放的是：request、response、servletContext、requestScope、sessionScope、applicationScope、parameters、attrs… list 集合制作栈结构容器 push ：压栈：list.add(0,obj); list 的索引一定是连续的，如果 list 中添加了 0 索引的值，之后的索引会往后延续 pop：弹栈：list.remove(0); list remove 方法会移除 0 索引的值，并返回该值，后续的索引会往前移 在栈中取属性时，从栈顶开始，找不到就往下找，直到找到停止。 struts2 中参数接受由 OGNL 引擎完成 属性驱动:从 Root 中拿到 name 属性值，并赋值为 tom — name = tom 对象驱动：从栈顶对象中获得 user 属性，再获得 user 属性的 name 属性，赋值为 tom – user.name = tom 模型驱动：从栈顶对象获得 name 属性，并赋值为 tom — name = tom 因为实现模型驱动需要在 赋值前，将接受的参数压入栈顶，不然无法赋值。 但是默认的 拦截器中，赋值的 param 拦截器运行比 action（压栈）早，所以需要自己去实现 Preparable 接口,实现 prepare 方法，把 action 的压栈代码放到 prepare 方法。 1234//获得栈值ValueStack vs = ActionContext.getContext().getValueStack();//将 User u 压入栈顶vs.push(u); 或者可以使用 ModelDriven 接口，实现 public User getModel( return u){} 方法，将压栈方法放入其中，实现原理跟 prepare 一致。 拦截器生命周期：随项目启动而创建，随项目关闭而销毁，类似 filter idea 查看源码没有注释的原因及解决方法 idea 直接查看源码是 jar 包反编译 .class 文件得到的，注释不会存在于 .class 文件中， 若需要注释则需要导入 .java 的 jar 包，即 -sources.jar 后缀的文件 。 idea 查看 jar 包没有注释 拦截器放行则调用 invoke() 方法，如果不想放行直接返回一个页面则 return 一个字符串，赋值给 resultCode(源码中)，使其不再递归调用 invoke() 就不会调用后续拦截器及 action 123456window.onload=function()&#123; if(window.parent != window)&#123;//如果页面再框架中 //让框架页面跳转到登陆页面 window.parent.location.href="$&#123;pageContext.request.contextPath&#125;/login.jsp"; &#125; &#125; 解决登录页跳转在框架中的方法 Struts2 xml 配置1234567891011121314151617181920212223242526&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE struts PUBLIC "-//Apache Software Foundation//DTD Struts Configuration 2.3//EN" "http://struts.apache.org/dtds/struts-2.3.dtd"&gt;&lt;struts&gt; &lt;!-- 配置常量 --&gt; &lt;!-- 字符集 --&gt; &lt;constant name="struts.i18n.encoding" value="UTF-8"&gt;&lt;/constant&gt; &lt;!-- 开发模式 --&gt; &lt;constant name="struts.devMode" value="true"&gt;&lt;/constant&gt; &lt;!-- 主题 --&gt; &lt;constant name="struts.ui.theme" value="simple"&gt;&lt;/constant&gt; &lt;!-- 扩展名 --&gt; &lt;constant name="struts.action.extension" value="action"&gt;&lt;/constant&gt; &lt;!-- 通用package --&gt; &lt;package name="customer" namespace="/" extends="struts-default"&gt; &lt;!--如果struts2 没有被 spring 代理时，需要在 class 中填写完整类名，method 表示访问 action 中的某个方法，name 是一个返回的名称，与项目名路径拼接成一个访问路径。如果被 spring 代理则填写 spring 配置的 action 名即可--&gt; &lt;action name="findById" class="cn.itcast.crm.action.CustomerAction" method="findCustomerById"&gt; &lt;result name="success"&gt;/info.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; action 中 name 是访问时根据 项目名+name+.action 来拼接访问网址用的，class 是该类的完整类名（由 spring 管理 struts2 时，spring 的 application.xml 文件中会配置该 action，所以那时只需要填写 spring 中配置的 action 的 name 属性即可），method 表示该 action 中要访问哪个方法，result 表示访问该方法后，return 了 success 后的跳转页面 如果配置扩展名的 constant，则在网站访问时，必须是 actionName.action 等有后缀的方式，具体后缀名根据配置改变 Springspring 管理项目中所有对象 Spring 框架是容器性质的，容器中有什么对象就有什么功能，是一站式框架 创建 idea web项目 创建 spring xml 配置文件： 先创建一个项目，然后配置好spring依赖，随后新建xml文件就可以看到Spring Config选项了，选择它，然后输入配置文件名（applicationContext），建好了spring的配置文件。 spring 导包：4个核心包，2个日志包，1个 web 整合包 控制反转（Inversion of Control，缩写为IOC） 反转控制就是反转对象的创建方式，由我们自己创建反转成 spring（容器）创建 依赖注入（Dependency Injection，简称DI） 依赖注入就是实现 IOC 思想的方式 注入方式： set 方法注入 构造方法注入 字段注入 注入类型： 值注入：8 大数据类型都是值注入，可以将在一个 name 创建时给与值 “三爷” 引用类型注入：将依赖对象注入，将 dao 注入到 service 或将 service 注入到 action BeanFactory spring 的原始接口，针对其接口的功能比较单一，BeanFactory 接口实现类的容器在获得对象时才会创建 AppicationContext Spring 比较末端的接口，每次启动时创建容器中所有配置对象，并提供更多功能 从类路径加载配置文件:classPathXmlApplicationContext web 开发用 AppicationContext，手机等资源匮乏的地方用 BeanFactory spring 配置Bean 元素 name 属性 与 id 属性都是用来给被管理对象起名，在获得对象时根据这个名字来获得。 name 属性是为了解决 id 属性不能使用特殊字符规则而创造出来的 class 属性用来获得 对象完整类名 scope 属性 singleton（单例模式）：单例模式的对象在 Spring 容器中只会存在一个实例 prototyte（多例原型）：多例原型的对象每次在获得时才会创建，每次创建都是新的对象 request：web 环境下，对象与 request 生命周期一致（不用） session：web 环境下，对象与 session 生命周期一致（不用） 一般情况都是用默认配置 singleton，但与 struts2 整合时，给 action 的 bean 必须声明多例（struts 每个请求都会创建一个新的 action） 创建方式 空参构造创建（对象创建必须通过构造函数）(推荐) &lt;bean name=&quot;user&quot; class=&quot;com.xxx.bean.User&quot;&gt;&lt;/bean&gt; 静态工厂 实例工厂 分模块配置 将一个配置文件导入另一个配置文件中 &lt;import resource=&quot;cn.xxx.applicationContext.xml&quot;/&gt; spring 定义 bean 的三种方式 属性注入 12345678910111213&lt;bean name="user" class="cn.xxx.bean.User"&gt; &lt;!--set 注入 ，为 User 对象 name，age 属性 注入值--&gt; &lt;property name="name" value="zhangsan"&gt;&lt;/property&gt; &lt;property name="age" value="11"&gt;&lt;/property&gt; &lt;!--引用类型注入用 ref ，对象注入,将下方配置的 Car 注入到 User--&gt; &lt;property name="car" ref="car"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- 将 Car 配置到容器,注入到其他对象 --&gt;&lt;bean name="car" class="cn.xxx.bean.Car"&gt; &lt;property name="name" value="迈巴赫"&gt;&lt;/property&gt; &lt;property name="cloor" value="黑"&gt;&lt;/property&gt;&lt;/bean&gt; 构造函数注入 123456&lt;!-- index 属性指定构造函数参数的索引地址， type 指定参数类型 --&gt;&lt;bean name="user" class="cn.xxx.bean.User"&gt; &lt;constructor-arg name="name" value="lisi" index="0" type="java.lang.Integer"&gt;&lt;/constructor-arg&gt; &lt;!--引用类型注入用 ref ，对象注入,将上方配置的 Car 注入到 User--&gt; &lt;constructor-arg name="car" ref="car"&gt;&lt;/constructor-arg&gt;&lt;/bean&gt; p名称注入 先导入xmlns:p=&quot;http://www.springframework.org/schema/p&quot; &lt;bean name=&quot;user3&quot; class=&quot;cn.xxx.bean.User&quot; p:name=&quot;jack&quot; p:age=&quot;18&quot; p:car-ref=&quot;car&quot;&gt;&lt;/bean&gt; 本质还是走 set 构造，用来简化 property 配置方式。 spel 注入：spring Expression Language， spring 表达式语言 复杂类型注入 12345678910111213141516171819202122232425262728&lt;bean name="cb" class="cn.itheima.bean.CollectionBean"&gt; &lt;property name="arr"&gt; &lt;!--多元素 array 注入--&gt; &lt;array&gt; &lt;value&gt;tom&lt;/value&gt; &lt;value&gt;jim&lt;/value&gt; &lt;ref bean="car"/&gt; &lt;/array&gt; &lt;/property&gt; &lt;!--map 类型注入--&gt; &lt;property name="map"&gt; &lt;map&gt; &lt;entry key="url" value="jdbc:mysql///hibernate"&gt;&lt;/entry&gt; &lt;entry key="carName" value-ref="car"&gt;&lt;/entry&gt; &lt;entry key-ref="user" value-ref="user"&gt;&lt;/entry&gt; &lt;/map&gt; &lt;/property&gt; &lt;!--property 类型注入--&gt; &lt;property name="prop"&gt; &lt;props&gt; &lt;prop key="driverClass"&gt;com.jdbc.com.Driver&lt;/prop&gt; &lt;prop key="userName"&gt;root&lt;/prop&gt; &lt;prop key="password"&gt;1234&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt; tomcat jar 包导入，并且应用到 mudeule 先在右上角点击 Edit Configurations，选择 tomcat ，设置名称，点击 Application server 右侧的 configure，选择左侧的 tomcat 版本（记住这个版本号），点击第一个 + 号，选择 tomcat 下的 lib 目录。点击确定。 然后 ctrl + alt + shift + s 打开 project structure ，选择 module，选中当前 module。点击右侧 + 号，选择 libraries，选择刚才配置的 tomcat 版本号。完成 Spring 使用注解替代 xml 为主配置导入新的命名空间（约束），导包（4+2+spring-aop) 开启注解代理配置文件 12&lt;!--指定扫描 该 package 下所有类中的注解，扫描时会连带其包下的子孙包一起扫描--&gt; &lt;context:component-scan base-package="cn.xxx.domain"&gt;&lt;/context:component-scan&gt; 在类中使用注解 @Component(“user”) @Service(“user”);（service 层） @Controller(“user”);（web 层，action/servlet） @Repository(“user”);（dao 层，仓库） 四个注解功能相同，下面 3 个更容易区分功能层级（可读性高） 修改对象作用范围： @Scope(ScopeName=”prototype”) 设置为多例，默认为单例(singleton) 值类型注入： @Value(“name”); 可以加在 成员变量上，通过反射的 Field 赋值，破坏封装性 也可以加载 set 方法上，通过 set 方法赋值 @Autowired//自动装配 如果由多个一致类型的对象，则无法选择具体哪一个 @Autowired @Qualifier(&quot;car2&quot;) 有多个一致类型的对象，使用这两条注释，用来选择具体哪个对象 或者直接使用@Resource(name=&quot;car2&quot;) 12345678@PostConstruct//对象创建（被构造）后调用-就是 init-method public void init()&#123; System.out.println("初始化"); &#125; @PreDestroy//对象销毁前调用-destory-method public void destory()&#123; System.out.println("销毁"); &#125; ApplicationContext 没有 close 方法，需要用它的子类 ClassPathXmlApplicationContext spring aop:Spring 能为我们管理的对象动态生成代理对象， 自己创建代理对象需要创建方法 : Proxy.newProxyInstance(classLoader,Interface[] arr,InvocationHandler handler); spring 实现 aop 原理（Spring 混合 2 种代理） 动态代理：被代理对象必须实现接口，才能产生代理对象，如果没有接口就不能使用动态代理技术（有接口时优先使用） cglib 代理：第三方代理技术，可以对任何类生成代理，代理的原理是对目标对象进行继承代理，如果目标对象被 final 修饰，则无法被 cglib 代理（没有接口时使用） aop 名词Joinpoint（连接点）：目标对象中所有可以增强的方法 Pointcut（切入点）：目标对象中已经增强的方法 Advice（通知/增强）：增强的代码（需要添加在 被增强方法 前后的代码） Target（目标对象）：被代理对象 Weaving（织入）：将通知应用到切入点这个过程 Proxy（代理）：将通知织入到目标对象后形成代理 aspect（切面）：切入点+通知 aop 导包： 4个基本包+ spring-aop-5.0.8.RELEASE.jar com.springsource.org.aopalliance-1.0.0.jar com.springsource.org.aspectj.weaver-1.6.8.RELEASE.jar spring-aspects-5.0.8.RELEASE.jar 动态代理 通过动态代理可以实现 aop 思想 对目标对象中方法增强 spring aop 配置 xml aop:config &lt;aop:pointcut expression=”execution( cn.itcast.service.ServiceImpl.*(..))” id=”pc”/&gt; &lt;aop:aspect ref=”myAdvice” &gt; &lt;aop:before method=”before” pointcut-ref=”pc” /&gt; &lt;aop:after-returning method=”afterReturning” pointcut-ref=”pc” /&gt; &lt;aop:around method=”around” pointcut-ref=”pc” /&gt; &lt;aop:after-throwing method=”afterException” pointcut-ref=”pc”/&gt; &lt;aop:after method=”after” pointcut-ref=”pc”/&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt; spring jdbc 配置1234567891011121314151617181920212223242526&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:util="http://www.springframework.org/schema/util" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd"&gt;&lt;context:property-placeholder location="classpath:db.properties"/&gt; &lt;!--将 dataSource 放入 spring 容器--&gt; &lt;bean name="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;property name="jdbcUrl" value="$&#123;jdbc.jdbcUrl&#125;"&gt;&lt;/property&gt; &lt;property name="driverClass" value="$&#123;jdbc.driver&#125;"&gt;&lt;/property&gt; &lt;property name="user" value="$&#123;jdbc.user&#125;"&gt;&lt;/property&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--将 jdbcTemplate 放入 spring 容器--&gt; &lt;!--&lt;bean name="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate"&gt;--&gt; &lt;!--&lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt;--&gt; &lt;!--&lt;/bean&gt;--&gt; &lt;!--将 UserDao 放入 spring容器--&gt; &lt;bean name="userDao" class="cn.itcast.jdbctemplate.UserDaoImpl"&gt; &lt;!--&lt;property name="jt" ref="jdbcTemplate"&gt;&lt;/property&gt;--&gt; &lt;!--直接把 jdbc 连接池注入给 dao --&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; Spring 事务操作事务操作对象：PlatFormTransactionManager 接口 最核心的就是 TransactionManager 对象，给各个数据库操作对象提供不同的接口 Spring 事务属性 事务的隔离级别：1-读已提交，2-读未提交，4-可重复度，8-串行化 是否只读：true（只读）/false（可操作） 事务传播行为：业务（Service）方法之间互相（平行）调用时，事务该如何处理 默认行为：PROPAGATION_REQUIRED 支持当前事务，如果不存在则新建一个（基本只用这个） Spring 事务管理方式 编码式（了解） xml 配置（aop） 123456789101112131415&lt;!--事务核心管理器配置，封装了所有事务操作，依赖于连接池--&gt; &lt;bean name="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;!--配置事务通知--&gt; &lt;tx:advice id="txAdvice" transaction-manager="transactionManager"&gt; &lt;tx:attributes&gt; &lt;tx:method name="transfer" isolation="READ_COMMITTED" propagation="REQUIRED" read-only="false"/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!--配置织入--&gt; &lt;aop:config&gt; &lt;aop:pointcut id="txPc" expression="execution(* cn.itcast.service.impl.*ServiceImpl.*(..))"/&gt; &lt;aop:advisor advice-ref="txAdvice" pointcut-ref="txPc"/&gt; &lt;/aop:config&gt; 注解配置（aop） 123456&lt;!--事务核心管理器配置，封装了所有事务操作，依赖于连接池--&gt;&lt;bean name="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!--开启注解事务--&gt;&lt;tx:annotation-driven/&gt; 类上的注解配置： @Transactional(isolation = Isolation.REPEATABLE_READ,propagation = Propagation.REQUIRED,readOnly = false) 如果想要一个类中所有方法都使用该注解配置，则将其放在类名上，如果其中有个别方法需要额外配置，则另填加注释再该方法上。 SSH 框架整合WEB 层：struts2 + jsp Service 层：javaBean JavaBeans 是Java中一种特殊的类，可以将多个对象封装到一个对象（bean）中。 特点是可序列化，提供无参构造器，提供getter方法和setter方法访问对象的属性。 Dao 层：hibernate struts2 与 spring 整合：将 Action 对象交给 spring 容器来创建 hibernate 与 spring 整合：将 sessionFactory 交给 spring 负责维护，并将 session 的维护以及 aop 事务都交给 spirng 导包： hibernate 包 \hibernate-release-5.0.7.Final\hibernate-release-5.0.7.Final\lib\required 下全部包 \hibernate-release-5.0.7.Final\hibernate-release-5.0.7.Final\lib\jpa\ hibernate-entitymanager-5.0.7.Final.jar mysql-connector-java-5.1.7-bin.jar struts2:包 \struts-2.3.24-all\struts-2.3.24\apps\struts2-blank\WEB-INF\lib 下全部包 \struts-2.3.24-all\struts-2.3.24\lib\ struts2-spring-plugin-2.3.24.jar struts2-spring-plugin-2.3.24.jar 这个包会让 struts2 在项目启动时会去寻找 spring 容器，如果找不到就会报错，单独使用 struts2 项目时不能导入 spring 包 4+2(核心包): \spring-framework-5.0.8.RELEASE-dist\spring-framework-5.0.8.RELEASE\libs 下4个核心包 beans、comtext、core、expression \spring-framework-3.0.2.RELEASE-dependencies\org.apache.log4j\com.springsource.org.apache.log4j\1.2.15 下的 com.springsource.org.apache.log4j-1.2.15.jar \spring-framework-3.0.2.RELEASE-dependencies\org.apache.commons\com.springsource.org.apache.commons.dbcp\1.2.2.osgi 下的 com.springsource.org.apache.commons.dbcp-1.2.2.osgi.jar 整合 web 的包(spring-web)： \spring-framework-5.0.8.RELEASE-dist\spring-framework-5.0.8.RELEASE\libs 下的 spring-web-5.0.8.RELEASE.jar 整合 aop （4个）(spring-aop|spring-aspect|aopalliance|aopweaving) \spring-framework-5.0.8.RELEASE-dist\spring-framework-5.0.8.RELEASE\libs 下的 spring-aop-5.0.8.RELEASE.jar spring-aspects-5.0.8.RELEASE.jar \spring-framework-3.0.2.RELEASE-dependencies\org.aopalliance\com.springsource.org.aopalliance\1.0.0 下的 com.springsource.org.aopalliance-1.0.0.jar \spring-framework-3.0.2.RELEASE-dependencies\org.aspectj\com.springsource.org.aspectj.weaver\1.6.8.RELEASE com.springsource.org.aspectj.weaver-1.6.8.RELEASE.jar 整合 hibernate 事务的（4个）（spring-jdbc|spring-tx|c3p0|spring-orm） \spring-framework-5.0.8.RELEASE-dist\spring-framework-5.0.8.RELEASE\libs 下的 spring-jdbc-5.0.8.RELEASE.jar spring-orm-5.0.8.RELEASE.jar spring-tx-5.0.8.RELEASE.jar \spring-framework-3.0.2.RELEASE-dependencies\com.mchange.c3p0\com.springsource.com.mchange.v2.c3p0\0.9.1.2 下的 com.springsource.com.mchange.v2.c3p0-0.9.1.2.jar junit4 测试包 \SSH\spring-framework-5.0.8.RELEASE-dist\spring-framework-5.0.8.RELEASE\libs 下的 spring-test-5.0.8.RELEASE.jar 单独配置 springweb.xml 123456789&lt;!--让 spring 随 web 启动而创建的监听器--&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!--配置 spring 配置文件位置参数--&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt; 单独配置 struts2struts.xml（sturts2 主配置文件） 1234567891011121314&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE struts PUBLIC "-//Apache Software Foundation//DTD Struts Configuration 2.3//EN" "http://struts.apache.org/dtds/struts-2.3.dtd"&gt;&lt;struts&gt; &lt;constant name="struts.objectFactory" value="spring"&gt;&lt;/constant&gt; &lt;package name="crm" namespace="/" extends="struts-default" &gt; &lt;action name="UserAction_*" class="cn.itcast.web.action.UserAction" method="&#123;1&#125;"&gt; &lt;result name="success"&gt;/success.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; 将 action 的创建（obj 工厂 ）交给 spring 管理struts.objectFactory = spring spring 负责装配 Action 的依赖属性（将 action 中需要创建的 servie 交给 spring 管理）struts.objectFactory.spring.autoWire = name method={1} 代表该方法代表 name 中第几个通配符（*） struts2 核心过滤器 123456789&lt;!--struts2 核心过滤器--&gt; &lt;filter&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;filter-class&gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 整合方案1（不推荐）1234567&lt;!--方案1：class 属性仍然配置 action 完整类名，--&gt; &lt;!--struts2仍然修饰 action ，由 spring 负责组装 Action 中依赖关系--&gt; &lt;package name="crm" namespace="/" extends="struts-default" &gt; &lt;action name="UserAction_*" class="cn.itcast.web.action.UserAction" method="&#123;1&#125;"&gt; &lt;result name="success"&gt;/success.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt; 整合方案2：spring 负责创建 action 及组装applicationContext.xml 123456&lt;!--Action 作用对象一定是多例的--&gt; &lt;bean name="userAction" class="cn.itcast.web.action.UserAction" scope="prototype"&gt; &lt;property name="us" ref="userService"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean name="userService" class="cn.itcast.service.impl.UserServiceImpl"&gt;&lt;/bean&gt; struts.xml 12345&lt;package name="crm" namespace="/" extends="struts-default" &gt; &lt;action name="UserAction_*" class="userAction" method="&#123;1&#125;"&gt; &lt;result name="success"&gt;/success.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt; 单独配置 hibernate导入orm元数据 与 实体类 配置文件 12345678910111213141516171819202122232425262728293031323334&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE hibernate-configuration PUBLIC "-//Hibernate/Hibernate Configuration DTD 3.0//EN" "http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd"&gt;&lt;hibernate-configuration&gt; &lt;session-factory&gt; &lt;!-- 数据库驱动 --&gt; &lt;property name="hibernate.connection.driver_class"&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;!-- 数据库url --&gt; &lt;property name="hibernate.connection.url"&gt;jdbc:mysql:///crm_32&lt;/property&gt; &lt;!-- 数据库连接用户名 --&gt; &lt;property name="hibernate.connection.username"&gt;root&lt;/property&gt; &lt;!-- 数据库连接密码 --&gt; &lt;property name="hibernate.connection.password"&gt;dfwhj43815&lt;/property&gt; &lt;!-- 数据库方言--&gt; &lt;property name="hibernate.dialect"&gt;org.hibernate.dialect.MySQLDialect&lt;/property&gt; &lt;!-- 将hibernate生成的sql语句打印到控制台 --&gt; &lt;property name="hibernate.show_sql"&gt;true&lt;/property&gt; &lt;!-- 将hibernate生成的sql语句格式化(语法缩进) --&gt; &lt;!-- auto schema export 自动导出表结构. 自动建表--&gt; &lt;property name="hibernate.hbm2ddl.auto"&gt;update&lt;/property&gt; &lt;!-- 引入orm元数据 路径书写: 填写src下的路径 --&gt; &lt;mapping resource="cn/itcast/domain/Customer.hbm.xml" /&gt; &lt;mapping resource="cn/itcast/domain/LinkMan.hbm.xml" /&gt; &lt;mapping resource="cn/itcast/domain/User.hbm.xml" /&gt; &lt;/session-factory&gt;&lt;/hibernate-configuration&gt; spring 整合 hibernate方案一：spring 中配置 sessionFactory（不重要） applicationContext.xml 12345&lt;!--将 SessionFactory 配置到 spring 容器中--&gt; &lt;bean name="sessionFactory" class="org.springframework.orm.hibernate5.LocalSessionFactoryBean"&gt; &lt;!--加载配置方案1：仍然使用外部 hibernate.cfg.xml 配置信息--&gt; &lt;property name="configLocation" value="hibernate.cfg.xml"&gt;&lt;/property&gt; &lt;/bean&gt; 方案二：将 hibernate 配置文件放到 spring 的配置文件中（使用该方法） 123456789101112131415161718192021&lt;bean name="sessionFactory" class="org.springframework.orm.hibernate5.LocalSessionFactoryBean"&gt; &lt;!--加载配置方案2：在 spring 配置中放置 hibernate 配置信息--&gt; &lt;!--配置 hibernate 基本信息--&gt; &lt;property name="hibernateProperties"&gt; &lt;props&gt; &lt;!--必选配置--&gt; &lt;prop key="hibernate.connection.driver_class"&gt;com.mysql.jdbc.Driver&lt;/prop&gt; &lt;prop key="hibernate.connection.url"&gt;jdbc:mysql:///crm_32&lt;/prop&gt; &lt;prop key="hibernate.connection.username"&gt;root&lt;/prop&gt; &lt;prop key="hibernate.connection.password"&gt;dfwhj43815&lt;/prop&gt; &lt;prop key="hibernate.dialect"&gt;org.hibernate.dialect.MySQLDialect&lt;/prop&gt; &lt;!--可选配置--&gt; &lt;prop key="hibernate.show_sql"&gt;true&lt;/prop&gt; &lt;prop key="hibernate.format_sql"&gt;true&lt;/prop&gt; &lt;prop key="hibernate.hbm2ddl.auto"&gt;update&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;!--引入元数据--&gt; &lt;property name="mappingDirectoryLocations" value="cn/itcast/domain"&gt;&lt;/property&gt; &lt;/bean&gt; spring 整合 c3p0 连接池 配置 db.properties ，放入用户密码等键值对 引入连接池到 spring 123456789&lt;!--开启 session 连接池--&gt; &lt;context:property-placeholder location="classpath:db.properties"/&gt; &lt;!--将 dataSource 放入 spring 容器--&gt; &lt;bean name="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;property name="jdbcUrl" value="$&#123;jdbc.jdbcUrl&#125;"&gt;&lt;/property&gt; &lt;property name="driverClass" value="$&#123;jdbc.driver&#125;"&gt;&lt;/property&gt; &lt;property name="user" value="$&#123;jdbc.user&#125;"&gt;&lt;/property&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt; 将连接池注入到 sessionFactory,hibernate 会通过连接池获得连接 spring 整合 hibernate 操作数据库dao 类创建继承 HibernateDaoSupport 模板操作 ：execute / findByCriteria 1234567891011121314151617181920212223242526272829303132//hibernateDaoSupport 使用 需要为 dao 注入 sessionFactorypublic class UserDaoImpl extends HibernateDaoSupport implements UserDao &#123; @Override //匿名内部类引用外部变量必须设置为 final public User getByUserCode(final String usercode) &#123; //HQL// return getHibernateTemplate().execute(new HibernateCallback&lt;User&gt;() &#123;// @Override// public User doInHibernate(Session session) throws HibernateException &#123;// String hql = " from User where user_code=? ";// Query query = session.createQuery(hql);// query.setParameter(0,usercode);// User user = (User) query.uniqueResult();// return user;// &#125;// &#125;); //Criteria DetachedCriteria dc = DetachedCriteria.forClass(User.class); dc.add(Restrictions.eq("user_code",usercode)); List&lt;User&gt; list = (List&lt;User&gt;) getHibernateTemplate().findByCriteria(dc); if(list!=null &amp;&amp; list.size()&gt;0)&#123; return list.get(0); &#125;else&#123; return null; &#125; &#125;&#125; applicationContext.xml 注入 sessioFactory 1234&lt;bean name="userDao" class="cn.itcast.dao.impl.UserDaoImpl"&gt; &lt;!--模板操作需要注入 sessionFactory--&gt; &lt;property name="sessionFactory" ref="sessionFactory"&gt;&lt;/property&gt; &lt;/bean&gt; spring AOP 事务配置核心事务管理器 1234&lt;!--核心事务管理器--&gt;&lt;bean name="transactionManager" class="org.springframework.orm.hibernate5.HibernateTransactionManager"&gt; &lt;property name="sessionFactory" ref="sessionFactory"&gt;&lt;/property&gt;&lt;/bean&gt; xml 配置 aop 事务 配置通知 12345678910111213&lt;!--配置通知--&gt; &lt;tx:advice id="txAdvice" transaction-manager="transactionManager"&gt; &lt;tx:attributes&gt; &lt;tx:method name="save*" isolation="REPEATABLE_READ" propagation="REQUIRED" read-only="false" /&gt; &lt;tx:method name="persist*" isolation="REPEATABLE_READ" propagation="REQUIRED" read-only="false" /&gt; &lt;tx:method name="update*" isolation="REPEATABLE_READ" propagation="REQUIRED" read-only="false" /&gt; &lt;tx:method name="modify*" isolation="REPEATABLE_READ" propagation="REQUIRED" read-only="false" /&gt; &lt;tx:method name="delete*" isolation="REPEATABLE_READ" propagation="REQUIRED" read-only="false" /&gt; &lt;tx:method name="remove*" isolation="REPEATABLE_READ" propagation="REQUIRED" read-only="false" /&gt; &lt;tx:method name="get*" isolation="REPEATABLE_READ" propagation="REQUIRED" read-only="true" /&gt; &lt;tx:method name="find*" isolation="REPEATABLE_READ" propagation="REQUIRED" read-only="true" /&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; 配置织入 1234567&lt;!--配置将通知织入目标对象--&gt; &lt;aop:config&gt; &lt;!--配置切点--&gt; &lt;aop:pointcut id="txPc" expression="execution(* cn.itcast.service.impl.*ServiceImpl.*(..))"/&gt; &lt;!--配置切面--&gt; &lt;aop:advisor advice-ref="txAdvice" pointcut-ref="txPc"/&gt; &lt;/aop:config&gt; 注解事务开启注解事务 &lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;&gt;&lt;/tx:annotation-driven&gt; 在类或方法上添加注释（类上加的话，类中方法全部使用该注释，特例的方法上可以单独加注释覆盖类注释） @Transactional(isolation= Isolation.REPEATABLE_READ,propagation = Propagation.REQUIRED,readOnly = true) 扩大 session 作用域避免使用懒加载时出现 no-session 问题（session 在到达 jsp 前已经关闭），需要扩大 session 作用域 123456789101112&lt;!--扩大 session 作用范围 该 filter 一定要在 struts 的 filter 之前 struts 过滤器没有 放行代码，所有过滤器都要在 struts 前--&gt; &lt;filter&gt; &lt;!--在视图 jsp 中 session 还是打开的--&gt; &lt;filter-name&gt;openSessionInView&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.orm.hibernate5.support.OpenSessionInViewFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;openSessionInView&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; maven 的使用maven 的用途 maven 能统一管理依赖（管理项目的 jar 包），从而节省项目空间 能一键构建项目：mvn tomcat:run 能不依靠 tomcat 直接运行项目 可以跨平台（因为是 java 开发的，专门用于 java 项目的，而 java 是跨平台的） 用于大型开发项目，可以提高开发效率（将一个项目分成多个小项目，分模块开发）（按业务分或按层分：dao、web、service） maven 仓库它有三种仓库： 本地仓库：自己维护，需要修改 C:\Users\用户名.m2 下 setting.xml 文件的 属性&lt;localRepository&gt;C:\repository&lt;/localRepository&gt; 远程仓库：公司维护，本地仓库没有 jar 包时去这里下载 中央仓库：maven 团队维护，2亿 jar 包，如果远程仓库没有会去这里下载，也可以直接下载到本地仓库。 maven 项目目录结构maven-helloworld src main：主目录 java：放置 java 代码 resource：放置 xml 以及 properties 等原来 src 目录下的配置文件 webapp test：测试目录 java：java 代码，junit 测试调用 resources：junit 测试用到的配置文件，如果内部没有测试文件，默认从 main 中找 meven 常用命令 mvn tomcat:run 一键启动运行 mvn clean 删除编译的文件（target 文件夹） mvn compile 编译主目录文件 mvn test 编译并运行 测试目录的文件（test 目录） mvn package 打包项目成 war 包（包名，后缀名都是在 pom.xml 中配置的） mvn install 将项目发布到配置的本地仓库 三种生命周期clean 生命周期：clean Default 生命周期：Compile、test、package、install、deploy（按顺序） Set 生命周期：site（用来生成项目的站点文档，用来描述项目） 同一生命周期的顺序靠后的命令执行时会同时顺序执行在前的命令 不同生命周期的命令可以同时执行（mvn clean package，这样会执行 clean 后执行 package） Intellj IDEA 创建 maven 项目右键创建类没有 servlet 的话，在 maven 的 pom.xml 下 dependencies 中配置 servlet 即可，如果还是没有就刷新 maven 的 pom 文件 idea 配置 maven 项目入门 创建 maven 项目无 src 目录 jar 包依赖范围：Compile：编译时需要，测试时需要，运行时需要(struts2-core) Provided：编译时需要，测试时需要，打包时不需要（jsp-api.jar，servlet-api.jar） Runtime：编译时不需要，运行时不需要，打包时需要（数据库驱动包） Test：编译时不需要，测试时需要，打包时不需要（junit.jar） pom.xml1234567891011121314151617181920212223242526272829303132333435&lt;!--约束的版本信息--&gt;&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;&lt;!--坐标 GAV--&gt;&lt;groupId&gt;cn.itcast&lt;/groupId&gt;&lt;artifactId&gt;ssh&lt;/artifactId&gt;&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&lt;!--打包方式 jar war pom--&gt;&lt;packaging&gt;war&lt;/packaging&gt;&lt;name&gt;ssh Maven Webapp&lt;/name&gt;&lt;!-- FIXME change it to the project's website --&gt;&lt;url&gt;http://www.example.com&lt;/url&gt;&lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.7&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.7&lt;/maven.compiler.target&gt;&lt;/properties&gt;&lt;!--jar 包依赖--&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.struts&lt;/groupId&gt; &lt;artifactId&gt;struts2-core&lt;/artifactId&gt; &lt;version&gt;2.3.24&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;!--内部配置了多个插件--&gt;&lt;build&gt;&lt;plugins&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-clean-plugin&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;/plugin&gt;&lt;/plugins&gt;&lt;/build&gt; 依赖版本冲突解决调节原则： 路径近者优先原则 第一申明者优先原则 排除原则 版本锁定 idea 使用 maven 分模块开发[使用IDEA创建maven项目整合SSH(多模块聚合) 使用IDEA创建maven项目 依赖传递在 scope 为 test 时会无法传递到下一个模块，可以在下一个模块中再添加一个同样 scope 为 test 的依赖 聚合运行：在 parent 项目上 tomcat：run，最终打的 package 中是 web 中的 jar 包，所以不会出现 jar 包冲突 pom 文件中配置的路径为 网页访问路径 123456789101112&lt;!-- maven内置 的tomcat6插件 --&gt;&lt;plugin&gt; &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt; &lt;artifactId&gt;tomcat-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.1&lt;/version&gt; &lt;configuration&gt; &lt;!-- 可以灵活配置工程路径 --&gt; &lt;path&gt;/ssh&lt;/path&gt; &lt;!-- 可以灵活配置端口号 --&gt; &lt;port&gt;8080&lt;/port&gt; &lt;/configuration&gt;&lt;/plugin&gt; 分模块测试 junit 123456789101112131415161718192021222324package cn.itcast.crm.service.impl;import cn.itcast.crm.entity.Customer;import cn.itcast.crm.service.CustomerService;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;//@ContextConfiguration(locations=&#123;"classpath:applicationContext-service.xml","classpath:applicationContext-dao.xml"&#125;)//表示 从jar包中获得 xml 时需要加上 classpath*，applicationContext-* 表示任何后缀都获取（service/dao....）@ContextConfiguration(locations=&#123;"classpath*:applicationContext-*.xml"&#125;)@RunWith(SpringJUnit4ClassRunner.class)public class CustomerServiceImplTest &#123; @Autowired private CustomerService customerService; @Test public void findById() &#123; Customer customer = customerService.findById(1l); System.out.println(customer.getCustName()); &#125;&#125; 私服 nexus登录 用户名：admin 密码：admin123 Virtual：虚拟仓库 central M1 shadow ：影子仓库，没实际用处 Proxy：代理仓库 Apache Snapshots （阿帕奇 快照）：作为一个非正式仓库，代理跳转到 阿帕奇 的一个仓库 Central ：代理跳转到 阿帕奇中央仓库 Hosted：宿主仓库，本地仓库 3rd party：其他公司自己开发的工程 Releases：自己做的工程是 Release 会提交到此处 Snapshots：自己做的工程属性 是 Snapshots 时，提交到私服时会自动放到此处 group public Respositories：不知道是 release 还是 snaphots 则从此处下载工程 Q&amp;AQ:Field ‘id’ doesn’t have a default value 错误提示。A:删除原本的数据库，让其自动创建 Q:java.lang.NoClassDefFoundError: Could not initialize class com.itheima.utils.HibernateUtilsA：参考：https://www.cnblogs.com/chenjfblog/p/7904024.html 配置了 xml 与 注释，删掉其中一个就好了 Q:修改 jsp 内容后页面标签属性 href 不变化因为删除了原先的 menu.htm 页面，没有将标签的 src 属性 变成新的 menu.jsp，修改 href 无效，重启 idea ，再发布网页会显示 网页 menu 部分 404 异常： HTTP Status 404 – Not Found Q:org.hibernate.HibernateException: No CurrentSessionContext configured!解决的办法就是根据需求在hibernate.cfg.xml文件中加上 &lt;property name=&quot;hibernate.current_session_context_class&quot;&gt;thread&lt;/property&gt; 或 &lt;property name=&quot;hibernate.current_session_context_class&quot;&gt;jta&lt;/property&gt; 添加第一种报错： 1org.hibernate.HibernateException: createCriteria is not valid without active transaction 将 thread 改为 jta 参考：https://blog.csdn.net/yinjian520/article/details/8666695 修改后出现问题： 1org.hibernate.HibernateException: No TransactionManagerLookup specified 将 service 中的 openSession 改为 getCurrentSession 参考：https://blog.csdn.net/xlgen157387/article/details/39801967 出错原因：需要把两个方法中用的sesiion一致，因为混用了所以报错， 要么同时写session=HibernateSessionFactory.getSession()来获取session 然后hibernate中配置为 jta 要不就是用session=HibernateSessionFactory.getSessionFactory().getCurrentSession();来获取session 然后hibernate中的配置为：thread 出处：https://blog.csdn.net/tarataotao/article/details/9376693 Q:配置文件报错：不允许有匹配 “[xX][mM][lL]” 的处理指令目标。A: 规范 XML格式 &lt;?xml version=”1.0” encoding=”UTF-8”?&gt; 必须是XML文件的第一个元素且前面不能空格。 参考：https://blog.csdn.net/niubaofeng2011/article/details/39007693 Q:IDEA DTD 文件引入报错错误信息：URI is not registered (Settings | Languages &amp; Frameworks | Schemas and DTD IDEA解决URI is not registered (Settings | Languages &amp; Frameworks | Schemas and DTD Q:idea 的 tomcat 不能正常关闭问题报错： org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [ROOT] appears to have started a thread named [pool-2-thread-1] but has failed to stop it. This is very likely to create a memory leak. Stack trace of thread: sun.misc.Unsafe.park A: https://stackoverflow.com/questions/28105803/tomcat8-memory-leak Q:Error:(2, 17) java: 程序包org.junit不存在A:导入 com.springsource.org.junit-4.7.0.jar 的 junit jar 包即可 Q: bean 重复配置org.springframework.beans.factory.parsing.BeanDefinitionParsingException: Configuration problem: Bean name ‘user’ is already used in this elementOffending resource: class path resource [applicationContext.xml] A: 在 Spring 配置文件重复配置相同 name 属性的 bean 会产生错误 Q:NullPointerExceptionjava.lang.NullPointerException at cn.itheima.service.impl.UserServiceImpl.login(UserServiceImpl.java:19) at cn.itheima.web.action.UserAction.login(UserAction.java:16) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source) at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source) at java.lang.reflect.Method.invoke(Unknown Source) at spring 容器注入，需要由 spring 创建 UserService 对象，自己创建就会为空 Q:Spring Junit4 @RunWith 为红色A: 在 Module 中 Libraries 中，点击左侧 + 号，选择 java 添加 idea lib 包下的 junit 添加到该项目 Q:程序包org.junit.runner不存在idea 使用 springJunit4 出现问题 : 程序包org.junit.runner不存在 12@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(&quot;classpath:applicationContext.xml&quot;) 程序包org.junit.runner不存在 File -&gt; Project Struct… -&gt; Libraies -&gt; 点击绿色的加号 -&gt; Java -&gt; 找到 IDEA 安装路径下的 Lib 中的junit-4.12 -&gt; 确定就行了，点击OK就出去了 Q:Spring 整合的 Junit4 错误java.lang.NoSuchMethodError: org.springframework.test.context.junit4.SpringJUnit4ClassRunner.runLeaf (Lorg/junit/runners/model/Statement;Lorg/junit/runner/Description;Lorg/junit/runner/notification/RunNotifier;) A:Junit4 包冲突了，删除自己导入 lib 下的 com.springsource.org.junit-4.7.0.jar，在红色的 @Test 上选择第一个修复方法 Q:unnamed spring confirguration files found A:shift + ctrl + alt + s 进入 Project Structure–&gt; modules–&gt;选择未配置 Spring Configuration 的项目–&gt;（如果没有 相应的 spring ,点击左侧 + 号,选择 spring）–&gt;选中需要添加的spring 项目 –&gt; 点击右侧 + 号–&gt; 选择需要的 Spring Application Context xml 文件，点击确认 Facets 表示这个module有什么特征，比如 Web，Spring和Hibernate等； Artifact：项目产生物，主要有jar, war, maven插件 idea facet 及 artifact 理解 Q: Spring 配置 jdbc c3p0 异常org.springframework.jdbc.CannotGetJdbcConnectionException: Could not get JDBC Connection; nested exception is java.sql.SQLException: Connections could not be acquired from the underlying database! A: class 与 url 填反了 参考：以上问题可能有以下原因造成： 1，驱动配置有误：driver=com.mysql.jdbc.Driver2，数据库连接地址有误：url=jdbc:mysql://localhost:3306/test?3useUnicode=true&amp;characterEncoding=utf83，密码或帐号有误：username=root， password=root 4，数据库未启动或无权访问 5，项目未引入对应的驱动jar包mysql-connector-java-5.1.6-bin.jar 6,mysql root没有远程访问的权限，需要增加权限，增加权限的步骤如下：进入mysql数据库：grant all privileges on . to ‘root‘@’%’ identified by ‘root’ with grant option;flush privileges; A:Spring 异常 Junit4，.NoClassDefFoundError: org/hamcrest/SelfDescribingException in thread “main” java.lang.NoClassDefFoundError: org/hamcrest/SelfDescribing Caused by: java.lang.ClassNotFoundException: org.hamcrest.SelfDescribing A: 删除Mudle 里的 Junit4 lib 包，在 @Test 上 alt+enter 选择添加 junit4，再选择第一个选项即可，idea 会自动添加 junit4 与 hamcrest-core 的 jar 包 A: java.lang.IllegalStateException: Failed to load ApplicationContext缺少包 com.springsource.org.aopalliance-1.0.0.jar Caused by: org.springframework.beans.factory.BeanDefinitionStoreException: Unexpected exception parsing XML document from class path resource [applicationContext.xml]; nested exception is java.lang.NoClassDefFoundError: org/aopalliance/intercept/MethodInterceptor Caused by: java.lang.NoClassDefFoundError: org/aopalliance/intercept/MethodInterceptor Caused by: java.lang.ClassNotFoundException: org.aopalliance.intercept.MethodInterceptor Q: 启动 tomcat 报错 xml 错误Error creating bean with name ‘transactionManager’ defined in class path resource [applicationContext.xml]: Cannot resolve reference to bean ‘sessionFactory’ while setting bean property ‘sessionFactory’ A：proerties 文件下参数配置错误，导致无法获得 dataSource,后续无法将 dataSource 注入 sessionFactory， 致使 sessionFactory 无法注入到 transactionManager 核心事务管理器，出现错误 1234567891011121314151617&lt;!--将 dataSource 放入 spring 容器--&gt; &lt;bean name="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;property name="jdbcUrl" value="$&#123;jdbc.jdbcUrl&#125;"&gt;&lt;/property&gt; &lt;property name="driverClass" value="$&#123;jdbc.driverClass&#125;"&gt;&lt;/property&gt; &lt;property name="user" value="$&#123;jdbc.user&#125;"&gt;&lt;/property&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;!--将 SessionFactory 配置到 spring 容器中--&gt; &lt;bean name="sessionFactory" class="org.springframework.orm.hibernate5.LocalSessionFactoryBean"&gt; &lt;!--核心事务管理器--&gt; &lt;bean name="transactionManager" class="org.springframework.orm.hibernate5.HibernateTransactionManager"&gt; &lt;property name="sessionFactory" ref="sessionFactory"&gt;&lt;/property&gt; &lt;/bean&gt; Q:idea 项目配置文件 class 都为红色A: 在 module 中设置项目的 src 路径 Q:配置 MAVEN 运行后出现异常[ERROR] Failed to execute goal org.codehaus.mojo:tomcat-maven-plugin:1.1:run (default-cli): Goal requires a project to execute but there is no POM in this directory (). Please verify you invoked Maven from the correct directory A: 需要在运行文件的 src 同级目录放有 pom.xml 文件，并且内部有相应的配置信息。 需要在 C:\Users\用户名.m2 中放置 配置 maven 的 settings.xml 而不是在 maven 解压目录的 conf 目录下 参考：https://stackoverflow.com/questions/16230666/failed-to-execute-goal-org-codehaus-mojotomcat-maven-plugin1-1deploy-default Q:intellj IDEA 创建 maven 项目无 src 目录问题在自己的 maven 主配置文件 mirrors 下加入 国内阿里云的镜像网站 12345678910111213141516 &lt;mirrors&gt; &lt;!-- 阿里云仓库 --&gt; &lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/repositories/central/&lt;/url&gt; &lt;/mirror&gt; &lt;!-- 中央仓库 --&gt; &lt;mirror&gt; &lt;id&gt;repo&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;Human Readable Name for this Mirror.&lt;/name&gt; &lt;url&gt;http://repo1.maven.org/maven2/&lt;/url&gt; &lt;/mirror&gt;&lt;/mirrors&gt; 参考：https://blog.csdn.net/xiaoke815/article/details/72810976 Q:maven idea 项目 xml 文件中 junit 版本红色A:将版本从 4.11 改成 4.10 或者 4.9 Q:maven jar 包冲突A: maven 的 jsp 与 servlet api 与 tomcat 中的冲突了，在这两个 dependency 中添加 provided` 属性，修改其依赖范围 参考：https://stackoverflow.com/questions/5735957/maven-loads-servlet-api-twice Q: intellj idea 的 jsp 页面无法使用 el 表达式A:在 page 属性中加上 isELIgnored=”false” 属性，使其不要忽略 EL 表达式 1&lt;%@ page contentType="text/html;charset=UTF-8" language="java" isELIgnored="false" %&gt; 参考：https://blog.csdn.net/qq_36921440/article/details/83785588 Q:intellj idea meven install 错误The packaging for this project did not assign a file to the build artifact A:不要使用自带右侧 maven 的 install ，自己在 EditConfiguration 中配置 install Q:分模块运行 web 错误 404HTTP Status 404 - There is no Action mapped for namespace [/] and action name [findById] associated with context path [/ssh].type Status report message There is no Action mapped for namespace [/] and action name [findById] associated with context path [/ssh]. description The requested resource (There is no Action mapped for namespace [/] and action name [findById] associated with context path [/ssh].) is not available. A: 经过查看 target 的输出文件夹，发现 applicationContext.xml 与 struts.xml 文件 都不在 class 目录下 于是查看后发现把 ssh-web 模块的 resources 文件夹放到了src 目录下，需要将其放入 src/main 中 Q: idea 上传到私服错误idea Failed to execute goal org.apache.maven.plugins:maven-deploy-plugin:2.7:deploy Return code is: 401, ReasonPhrase: Unauthorized A:401 是用户密码错误，没有设置好用户名和密码，400是没有访问权限 需要在你的 idea 的配置 xml 下配置 server 属性（C:\Users\用户名\.m2），而不是 maven conf 下的xml https://huangyunbin.iteye.com/blog/1740426 Q:idea 不会自动从私服下载项目模块 jar 包因为 idea 默认的 maven 是自带的，需要在 setting Build，Execution，Deployment/Build Tools/Maven 的Maven Home Directory 中选择自己安装的 maven 目录 https://blog.csdn.net/suah01/article/details/64906323]]></content>
      <categories>
        <category>SSH</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
        <tag>SSH</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Listener_Filter]]></title>
    <url>%2F2018%2F12%2F25%2FListener_Filter%2F</url>
    <content type="text"><![CDATA[监听器 Listener监听器概念监听某个对象的状态变化的组件 事件源：被监听的对象 – 三个域对象 request、session、servletContext 监听器：监听事件源对象 – 事件源对象的状态变化都会触发监听器 – 6+2 注册监听器：将监听器与事件源进行绑定 相应行为：监听器监听到事件源的状态变化时所涉及的功能代码 – 需要编写 监听器分类第一维度：按照被监听对象划分：ServletRequest 域、 HttpSession 域、servletContext 域 第二维度：安装监听的内容分：监听域对象的创建与销毁 监听域对象的属性变化 监听三大域对象的创建与销毁的监听器监听 ServletContext 域的创建与销毁的监听器 ServletContextListener servlet 与的生命周期 何时创建：服务器启动创建 何时销毁：服务器关闭销毁 监听器编写步骤（重点） 编写一个监听器类去实现监听器接口 （6+2 中选） 覆盖监听器的方法 在 web.xml 中进行配置 监听方法 6个监听器 ：ServletContext、HttpSession、ServletRequest 域 + Listener / AttributeListener ServletContextListener 的主要作用 初始化的工作：初始化数据 – 加载数据库驱动、连接池的初始化 加载一些初始化的配置文件 – spring 配置文件 12345//配置 spring 的核心监听器 //ContextLoaderListener implements ServletContextListener 实现了 监听器接口&lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;listener-class&gt;&lt;/listener&gt; 以上配置监听器用来在服务器开启时加载 spring 配置文件 applicationContext.xml 任务调度 – 定时器 Timer、TimerTask httpSession 域的 创建与销毁 监听器，在一个客户端访问时会创建一个 session jsp 页面默认被转换成 sevlet 会自动添加 pageContext.getSession 方法 一般只用来记录页面访问人数 2个监听器：与 session 中的绑定对象相关的监听器（对象感知监听器） 4个状态都是针对 存放到 session 中的对象的 即将绑定到 session 的对象状态： 绑定状态：一个对象被放到 session 中 解绑状态：一个对象被 session 移除 钝化状态：将 session 内存中的对象持久化（序列化）到磁盘 活化状态 绑定与解绑监听器： HttpSessionbindingListener ：是给对象用的，对象自己知道自己被绑或解绑 感知监听器不用配置 xml 面试题：当用户很多时，怎么对服务器进行优化？ 答：把待机很久不动的用户 session （服务器内存）中的内容存到磁盘中，如果用户回来了就将磁盘中的内容返回给用户 钝化与活化监听器：HttpSessionActivationListener 钝化（服务器关闭后）tomcat 文件夹下会有一个 SESSIONS.ser 文件 ，对象需要 实现 Serializable 接口才能真正钝化（序列化）到磁盘，不然会无法活化 服务器正常关闭或启动 实现钝化活化 使用钝化与活化监听器需要在 webContent/META-INF 下配置 context.xml 过滤器 Filter过滤器概念 filter 是对客户端访问资源的过滤，符合要求的放行不符合的不放行，并且可以对目标访问资源前后进行逻辑处理 编写一个过滤器的类实现 Filter 接口 实现接口中尚未实现的方法（着重实现 doFilter 方法） 在 web.xml 中进行配置（主要对过滤哪些资源配置进行配置） 作用：权限控制、公共代码的提取、对 request 和 response 中的方法进行增强（装饰者模式/动态代理） 增强方法：在 filter 中获得 request 与 response 时进行增强再发送给客户端 核心过滤方法 ：doFilter 放行请求：doFilter(resqust,response); doFilter(ServletRequest,ServletResponse){ } doFilter 内部请求是 ServletRequest，所以无法使用一些 HttpServletRequest 的 Api 如 request.getSession()，需要把它强转成子类，servlet 内部的 doGet doPost 方法都是底层源码自动强转过的 HttpServletRequest FilterChian 对象 内部有所有 Filter 的索引与顺序 过滤器的执行顺序看 web.xml 中 配置的先后顺序 异常报错 HTTP Status 500 – Internal Server ErrorTypeException ReportMessage An exception occurred processing JSP page [/index.jsp] at line [27]Description The server encountered an unexpected condition that prevented it from fulfilling the request.Exceptionorg.apache.jasper.JasperException: An exception occurred processing JSP page [/index.jsp] at line [27]24: 鑼冨洿浠庡皬鍒板ぇ page鍩�(pageContext 瀵硅薄)–&gt;request鍩�–&gt;session鍩�–&gt;application鍩�(servletContext)–%&gt;25: &lt;%–&lt;%=pageContext.findAttribute(“name”)%&gt;–%&gt;26: 27: &lt;jsp:include page=”/header.jsp”&gt;&lt;/jsp:include&gt;28:29: 30: Stacktrace:org.apache.jasper.servlet.JspServletWrapper.handleJspException(JspServletWrapper.java:584) org.apache.jasper.servlet.JspServletWrapper.service(JspServletWrapper.java:466) org.apache.jasper.servlet.JspServlet.serviceJspFile(JspServlet.java:386) org.apache.jasper.servlet.JspServlet.service(JspServlet.java:330) javax.servlet.http.HttpServlet.service(HttpServlet.java:742) org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52) Root Causeorg.apache.jasper.JasperException: An exception occurred processing JSP page [/header.jsp] at line [20]17: 娉ㄥ唽18: &lt;/c:if&gt;19: &lt;c:if test=”${user != null}”&gt;20: 娆㈣繋鎮�,${user.username }21: &lt;/c:if&gt;22: 璐墿杞�23: 鎴戠殑璁㈠崟Stacktrace:org.apache.jasper.servlet.JspServletWrapper.handleJspException(JspServletWrapper.java:584) org.apache.jasper.servlet.JspServletWrapper.service(JspServletWrapper.java:481) org.apache.jasper.servlet.JspServlet.serviceJspFile(JspServlet.java:386) org.apache.jasper.servlet.JspServlet.service(JspServlet.java:330) javax.servlet.http.HttpServlet.service(HttpServlet.java:742) org.apache.jasper.runtime.JspRuntimeLibrary.include(JspRuntimeLibrary.java:894) org.apache.jsp.index_jsp._jspService(index_jsp.java:144) org.apache.jasper.runtime.HttpJspBase.service(HttpJspBase.java:70) javax.servlet.http.HttpServlet.service(HttpServlet.java:742) org.apache.jasper.servlet.JspServletWrapper.service(JspServletWrapper.java:443) org.apache.jasper.servlet.JspServlet.serviceJspFile(JspServlet.java:386) org.apache.jasper.servlet.JspServlet.service(JspServlet.java:330) javax.servlet.http.HttpServlet.service(HttpServlet.java:742) org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52) Root Causejavax.el.PropertyNotFoundException: Property [username] not found on type [com.itheima.domain.User] javax.el.BeanELResolver$BeanProperties.get(BeanELResolver.java:260) javax.el.BeanELResolver$BeanProperties.access$300(BeanELResolver.java:212) javax.el.BeanELResolver.property(BeanELResolver.java:347) javax.el.BeanELResolver.getValue(BeanELResolver.java:92) org.apache.jasper.el.JasperELResolver.getValue(JasperELResolver.java:110) org.apache.el.parser.AstValue.getValue(AstValue.java:169) org.apache.el.ValueExpressionImpl.getValue(ValueExpressionImpl.java:184)org.apache.jasper.runtime.PageContextImpl.proprietaryEvaluate(PageContextImpl.java:944) org.apache.jsp.header_jsp._jspx_meth_c_005fif_005f1(header_jsp.java:301) org.apache.jsp.header_jsp._jspService(header_jsp.java:137) org.apache.jasper.runtime.HttpJspBase.service(HttpJspBase.java:70) javax.servlet.http.HttpServlet.service(HttpServlet.java:742) org.apache.jasper.servlet.JspServletWrapper.service(JspServletWrapper.java:443) org.apache.jasper.servlet.JspServlet.serviceJspFile(JspServlet.java:386) org.apache.jasper.servlet.JspServlet.service(JspServlet.java:330) javax.servlet.http.HttpServlet.service(HttpServlet.java:742) org.apache.jasper.runtime.JspRuntimeLibrary.include(JspRuntimeLibrary.java:894) org.apache.jsp.index_jsp._jspService(index_jsp.java:144) org.apache.jasper.runtime.HttpJspBase.service(HttpJspBase.java:70) javax.servlet.http.HttpServlet.service(HttpServlet.java:742) org.apache.jasper.servlet.JspServletWrapper.service(JspServletWrapper.java:443) org.apache.jasper.servlet.JspServlet.serviceJspFile(JspServlet.java:386) org.apache.jasper.servlet.JspServlet.service(JspServlet.java:330) javax.servlet.http.HttpServlet.service(HttpServlet.java:742) org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52) Note The full stack trace of the root cause is available in the server logs. 在 jstl 语句中使用了 javaBean 不存在的属性 过滤器解决 post get 乱码问题在传递 request 之前对 request 的 getParameter 方法进行增强 装饰者模式（包装） 增强类与被增强类实现统一接口 在增强类中传入被增强的类 需要增强的方法重写，不需要增强的方法调用被增强类的 filter 1234567//前处理打开session 事务chain.dofilter(req,resp);//放行-&gt;去处理 servlet，service，dao，jsp//后处理关闭 session 事务 此方式可以让 全部范围内的程序 session 处于打开状态]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaweb core]]></title>
    <url>%2F2018%2F12%2F14%2Fweb20%2F</url>
    <content type="text"><![CDATA[xml&amp;反射DTD 文件 document type definition ：文档类型定义 用于约束（约定/规定）xml 文档的格式 Scheme 文件，后缀名 .xsd 是 DTD 文件的升级类型，功能比 DTD 文件更多 DOM:将文档一次加载到内存形成树形结构，进行解析，解析成一个 Document 对象 SAX：Simple API for XML ：事件驱动的方式，边读边解析 反射JAVA 反射机制指在运行过程中，对于任意一个类，都能知道这个类的所有属性和方法；对于任意一个对象，都能调用它的任意一个方法和属性 使用反射可以在运行时 (在内存中操作代码) 对 .class 类文件中的字节码（机器代码）进行修改。在运行时对类 Class 、构造方法 Constructor、普通方法 Method、字段 field 进行操作。 反射获得 xml 配置文件中的 Servlet 类，对其进行方法调用（点击详细） //1.创建解析器对象 SAXReader saxReader = new SAXReader(); //2.使用解析器加载web.xml文件得到document对象 Document document = saxReader.read(“src/cn/itheima/web/servlet1/web.xml”); //3.获取根元素节点 Element rootElement = document.getRootElement(); //4.根据元素名称获取子元素节点 Element servletElement = rootElement.element(“servlet”); //5.根据元素名称获取servlet-class的文本节点 String servletClass = servletElement.element(“servlet-class”).getText(); //System.out.println(servletClass); //6.通过类全名获取字节码文件 Class clazz = Class.forName(servletClass); //7.创建实例对象 MyServlet1 my = (MyServlet1) clazz.newInstance(); //8.调用实例对象里面的方法 my.init(); my.service(); my.destory(); 读取 src 下文件比较好的方式是用类加载器： bean.xml 在 src 下时 String path = BeanFactory.class.getLorder().getResource(“”).getPath(“xxx.xml”); 读取 web 应用下最好的方式是用 this.getServletContext.getPath(“xxx”); MySql &amp; JDBC注册驱动： 用类加载器加载字符串描述的驱动类，将其加载到内存，该静态代码会自动执行 Class.forName(“com.mysql.jdbc.Driver”); Driver 底层有着方法，静态代码块在类一加载就运行：static{java.sql.DriverManager.registerDriver(new Driver());} 会自动对自己进行注册 获取连接： DriverManeger.getConnection(url,username,password); limit 关键词查询 （limit 2，2） 第一个参数表示查询起始位置（要查第几页-1）*第二个参数 第二个参数表示每页显示的查询个数 例如一共 11条记录，每页3条记录，要查询第四页的内容 limit（（4-1）*3，3）–&gt;limit（9，3） 最后显示10与11两条记录 limit 是左不包含的 Mysql 语句 左连接（LEFT JOIN ） SELECT M.columnname……,N.* columnname….. FROM left_table M LEFT JOIN right_table N ON M.columnname_join=N.columnname_join AND N.columnname=XXX WHERE M.columnname=XXX….. 左连接表示需要查询的数据条件即使不满足左边的表也可以查出左表的所有内容 右连接 SELECT M.columnname……,N.* columnname….. FROM left_table M RIGHT JOIN right_table N ON M. columnname_join=N. columnname_join AND M. columnname=XXX WHERE M.columnname=XXX….. 右连接与左连接相反，就算右表中有不符合查询条件的字段，也会出现在查询结果中。 内连接 只是嵌套的查询语句 Mysql 左连接 右连接 等值连接 JDBC连接池&amp;DBUtils创建连接池时移除、增加操作多使用 LinkList，查询时使用 ArrayList 1private static DataSource dataSource = new ComboPooledDataSource(); 创建连接池时会自动去寻找 c3p0-config.xml DBUtil 是 JDBC 开发简化工具包，封装了 JDBC 操作，可以很多代码 DBUtils 三个核心功能 QueryRunner：提供对 SQL 语句可操作 API QueryRunner(DataSource ds) 提供数据源（连接池），DBUtils 底层自动维护连接 connection update（String sql，Object … param），执行更新程序,参数可以多个 query（String sql，ResultSetHandlerrsh,Object … param)，执行查询（sql语句，处理结果，obj）参数可以多个 ResultSetHandler 结果处理类： BeanHandler ：将结果集中第一条记录封装到指定 javaBean BeanListHandler : 将结果集中每一条记录封装到指定 javaBean，将这些 javaBean 封装到一个 List 集合 ScalarHandler : 用于单数据，例如 select count(*) from 表 的操作（返回表中某一条件的记录数） 会话技术 Cookie&amp;SessionHttp 协议是无状态的，每个客户端访问服务器资源时，服务器并不知道客户端是谁，所以需要会话技术识别客户端 把无状态客户数据存储到服务器就是 session ，存到客户端本地就是 cookie session 域是服务器端为每个客户端创建的私有的内存空间，而 servletContext 服务端只有一个，是公有的 从打开一个浏览器访问一个站点，到关闭这个浏览器的过程称为一次会话（需要把标签页全部关闭才算关闭浏览器）（面试） 域中可以存任何东西，包括对象。 cookie 中不能存对象，只能存字符串，而且不能为中文 设置 Cookie 持久化时间cookie.setMaxAge(int seconds) – 秒 如果不设置 cookie 的持久化时间，cookie 存储在浏览器内存中，浏览器关闭 cookie 信息销毁(会话级别 cookie) 如果设置持久化时间，cookie 会持久化到浏览器的磁盘文件中 设置 Cookie 路径cookie.setPath(“/“); 如果不设置携带路径，则该 cookie 信息会在访问 设置该 cookie 的同级目录文件时携带该 cookie 信息（产生该 cookie 的 web 资源所在的路径） 删除Cookie如果要 删除 Cookie ，则在同路径下设置一个同名 Cookie（只要 key 相同，value 无所谓） 并设置持久化时间为 0 获得Cookie1234567891011Cookie[] cookies = req.getCookies(); for(Cookie cookie : cookies)&#123; //获得 cookie 名称 String cookieName = cookie.getName(); if(cookie!=null)&#123; if(cookieName.equals("name")) &#123;// 如果名称(key)等于 name 则获取其 value 值（zhangsan） String cookieValue = cookie.getValue(); System.out.println(cookieValue); &#125; &#125; 获取上次登陆时间出现网页报错 错误信息 500 HTTP Status 500 – Internal Server ErrorType Exception Report Message An invalid character [32] was present in the Cookie valueDescription The server encountered an unexpected condition that prevented it from fulfilling the request.Exception java.lang.IllegalArgumentException: An invalid character [32] was present in the Cookie value org.apache.tomcat.util.http.Rfc6265CookieProcessor.validateCookieValue(Rfc6265CookieProcessor.java:182)org.apache.tomcat.util.http.Rfc6265CookieProcessor.generateHeader(Rfc6265CookieProcessor.java:115) org.apache.catalina.connector.Response.generateCookieString(Response.java:1019) org.apache.catalina.connector.Response.addCookie(Response.java:967) org.apache.catalina.connector.ResponseFacade.addCookie(ResponseFacade.java:386)com.itheima.cookie.ShowLastAccessTimeServlet.doGet(ShowLastAccessTimeServlet.java:60) javax.servlet.http.HttpServlet.service(HttpServlet.java:635) javax.servlet.http.HttpServlet.service(HttpServlet.java:742) org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52) Note The full stack trace of the root cause is available in the server logs. ​ 错误原因：传入 cookie 的日期设置中出现了空格，An invalid character [32] was present in the Cookie value 32 就是空格的编码 解决：格式化日期时别加入空格 参考：https://blog.csdn.net/allan_liu_/article/details/74990162 Session 技术session 技术是基于 cookie 技术的，session 有一个存储 session 编号的 JSESSIONID，servlet1 得到这个 JSESSIONID 把它返回给客户端，客户端根据这个编号去访问 servlet2 时传递这个编号，从而服务器可以知道这两个 servlet 访问来自一个客户端。coolkie 可以帮助 session 存储 JSESSIONID 此方法根据客户端在服务器有无 session，如果没有则创建一个 session，如有则返回该 session 的引用 HttpSession session = request.getSession(); Session 对象生命周期（面试题）创建：第一次运行 request.getSession() 时 销毁： 服务器（非正常）关闭（如果正常关闭服务器，session 会被监听器从内存钝化到磁盘上，但是这个 session值仍然存在） session 过期/失效（默认30分钟） 在 tomcat web.xml 中配置全局（一般在自己项目的 web.xml 配置，只有自己项目没配才会用 tomcat 的全局设置） 123&lt;session-config&gt; &lt;session-timeout&gt;30&lt;/session-timeout&gt;&lt;/session-config&gt; 问：从何时开始的 30 分钟 session 算过期？ 从不操作服务器端资源开始 30 分钟 手动销毁 session ，session.invalidate(); 面试题：浏览器关闭，session 就销毁了吗？ 不对，session 的销毁方式只有 服务器关闭 跟 客户端一段时间不操作过期 才会销毁，跟客户端关闭与否无关 session 作用范围：默认一次会话中（访问服务器到关闭客户端），如果设置了 session 持久化，则在关闭浏览器后再次打开浏览器访问，还是能根据 JSESESSIONID 访问到原来的 session session 一般不建议存放一些一次性信息，如错误提醒等，使用 request 这种销毁快的存放 登陆后 el 表达式无法获得 session 中的 name 值，页面后台无报错 解决：数据库查询名 跟 UserBean 的 name 不一致，导致查询后返回的 User username 属性值为空，无法再页面显示；并且 el 表达式获取某个值时，若为空，则显示为空，不会报错。 Servlet&amp;JSPServletServlet: Service + let: 运行在服务端的 java 小程序，sun 公司提供的一套接口规范（接口），用来处理客户端请求响应给浏览器动态资源，实质就是 java 代码，放在服务器端，别人可以通过 http 协议访问此代码，通过 java API 动态向客户端输出内容。 servlet 规范三大组件： servlet 技术 filter 技术 – 过滤器 listener 技术 – 监听器 实现步骤： 创建类实现 Servlet 接口 覆盖尚未实现的方法 – 主要是 service 方法 在 web.xml 配置 servlet Serlvet 的 API(生命周期) Servlet 接口中的方法 init （ServletConfig config) 何时执行：servlet 对象创建时执行 ServletConfig ：代表该 Servlet 对象的配置信息 ServletConfig 可以获得 servlet 的 name 、servlet 的初始化参数、servletContext 对象 service（ServletRequest request，ServletResponse response） 何时执行：每次请求都会执行 ServletRequest:代表请求，内部封装的是 http 请求信息 ServletResponse 代表响应，认为内部要封装的是响应的信息 destory() 何时执行：servlet 销毁时执行 Servlet 的生命周期（面试题） Servlet 何时创建 默认第一次访问 Servlet 时创建（Tomcat 等容器自动创建） 为什么说默认？ 可以在 中配置 1-5 数字表优先级，servlet 对象可以在服务器启动时创建 Servlet 何时销毁 因为 Servlet 、request、response 等存在服务器内部（内存），服务器关闭 Servlet 就销毁了 每次访问必然执行的方法 service（ServletRequest req，ServletResponse resp） 方法 问题：对 xxxServlet 进行了10次访问，init(),destory(),service(),doGet(),doPost() 一共执行几次？ request 、response 对象创建几个 url 配置错误会出现 404 异常，servlet-class 配置错误会出现 500 异常 其中的为 servlet 类的配置 其中为 serlvet 虚拟路径配置 配置方式 完全匹配 访问资源与配置资源完全相同才能访问到 /xxx 目录匹配 /虚拟的目录../ 代表任意 扩展名匹配 *.xxxx 目录匹配与扩展名匹配不能混用 缺省的 Servlet 当服务器所有 servlet 与 访问的资源地址不匹配时，缺省的 servlet 负责处理 web 应用中所有的资源响应都是 servlet 提供的，包括静态资源 tomcat 下有一个默认的 缺省 Servlet，当访问静态资源时找不到动态资源，从而去你的 WEB-INF 目录下找静态资源 .html .jsp 等，然后用 wirte（）方法输出页面，如果在自己的 web.xml 配置了缺省 Servlet 则会覆盖 tomcat 的 缺省 Servlet 从而访问不到静态页面，404 异常 欢迎页面：tomcat 配置默认 index.html index.htm index.jsp ServletContext 对象ServletContext 对象代表一个 web 应用的环境（上下文）对象，ServletContext 对象内部封装的是 web 的应用信息 一个 web 应用有几个 servlet / ServletContext 对象：多个 Servlet，一个 ServletContext ServletContext 对象的生命周期？ 创建：该 web 应用被加载（服务器启动 或 服务器启动状态发布 web 引用） 销毁：web 应用被卸载（服务器关闭，移除该 web 应用） 怎么获得 Servlet 对象 Servletconfig.getServletContext(); this.getServletContext(); ServletContext 的作用 获得 web 应用全局的 初始化参数 在 web.xml 中配置初始化参数后，用 context.getInitParameter(“name”) 获得 1234567&lt;context-param&gt; &lt;param-name&gt;name&lt;/param-name&gt; &lt;param-value&gt;com.xxx.xxx&lt;/param-value&gt;&lt;/context-param&gt; 获得 web 应用中任何资源的绝对路径（重点） WEB-INF 下的文件不能通过网址直接访问，可以通过代码访问 String 绝对路径 = ServletContext.getRealPath(“相对路径”); //此相对路径相对 WEB-INF 获取 src（classes）下的资源绝对路径时应使用 tomcat 部署后的 相对路径 String path = ServletContext.getRealPath(“WEB-INF/classes/c.txt”); 此外在读取src（classes）下的资源时可以使用类加载器方法 String path = ContextServlet.class.getClassLoader().getResource(“c.txt”).getPath();//此相对路径相对于 部署在 tomcat 服务器后的 classes 路径 idea 下 tomcat java 包 class 文件导出路径：${user.home}/.IntelliJIdea/system/tomcat 可以根据 idea 中配置 tomcat （Project Structure）Artifact 中路径一致， war 包专门用来传输服务器项目 war模式这种可以称之为是发布模式，看名字也知道，这是先打包war包，再发布； war exploded模式是直接把文件夹，jsp页面，classes等等移到Tomcat部署文件夹里面，进行加载部署。因此这种方式支持热部署，一般在开发的时候也是用这种方式。 参考：https://blog.csdn.net/qq_34328582/article/details/77932507 参考：https://blog.csdn.net/weixin_36210698/article/details/72585429 ServletContext 是一个域对象（重点） 什么是域对象？什么是域？ 域就是区域 存储数据的区域就是域对象 ServletContext 域对象的作用范围：整个 web 应用（所有 web 资源都可以随意向 servletContext 域中存取数据，数据可共享） 域对象的通用方法： setAttribute(String name,Object obj); getAttribute(String name); removeAttribute(String name); Linux 下的项目部署：idea 导出 war 包，将 war 包放到 linux 的 tomcat/web 目录下 Shift+Ctrl+Alt+S —&gt; 选择 Artifacts —&gt; 选择中间栏的绿色 + 号，选择 WebApplication:Archive /empty（empty 生成的是 war 包，exploded 生成的是 文件夹类型的热部署模式）—&gt; 点击右边的绿色 + 号，选择 Directory Content —&gt;上方可 Name 栏修改 war 包名称，OutPut Directory 修改 war包输出路径 —&gt; 现已完成除 classes 文件夹的 war 包配置 —&gt; 选中 war 包，点击上方黄色带红星的文件夹图标 创建 WEB-INF 和其 子目录 classes —&gt; 选中 classes 目录，点击上方（右侧）绿色 + 号，选择 Module Output —&gt; 全部确定后 在 build 中点击 BuildArtifacts，会将 war 包导出到刚才配置的路径下 参考： war 和 war exploded（热部署模式）的区别 解决 war 包没有 classes 文件问题 idea 导出 jar 包 mysql 导出对应的 SQL 到 linux 的数据库中 httpServletResponse通过 response 设置响应行：response.setStatus(int sc); 通过 response 设置响应头 add(set)Header(String name,String value); add(set)IntHeader(String name,int value); add(set)DateHeader(String name,Date value); add 表示添加，set 表示设置（相同 name 的新 value 会覆盖旧的） Response 重定向重定向状态码：302 重定向响应头：location 重定向指客户端向 Servlet1 请求一个资源，Servlet1 没有这个资源，便告诉客户端去访问 Servlet2 ，然后 Servlet2 返回资源给客户端（客户端地址会发生变化，第一次访问 Servlet1 是客户端主动访问，重定向则是 tomcat 等服务器端自动跳转的） 设置状态码302：response.setStatus(302); 设置响应头 location：response.setHeader(“location”,”url”); 以上 2 个方法可以封装成一个重定向方法 response.sendRedirect(“url”); 延时重定向方法：response.setHeader(“refleash”,”second;url”);response.setHeader(“名称”,”几秒后跳转;地址”)； 通过 response 设置响应体通过 response.getWriter().write(“xxx”); 将数据写入 response 的缓存区，然后 tomcat 的response 从缓存区获得数据，在引擎处将其拼接成 http 响应传给客户端 response 解决乱码问题 在数据写入 response 缓存区前设置，让其通过 response 查询 utf-8 的码表（设置 response 查询码表） response.setCharacterEncoding(“utf-8”); 告知客户端用 utf-8 解码（通过一个头 Context-type 告知客户端使用何种码表） “text/html”告知客户端文本是 html 类型，charset=utf-8 编码是 uft-8 response.setHeader(“Content-Type”,”text/html;charset=utf-8”); 以上方法可以封装为 response.setContentType(“text/html;charset=utf-8”); 文件下载文件下载就是服务器端到客户端的文件拷贝 什么情况下文件会下载？ 浏览器不能解析的文件会下载 什么情况下需要编写文件下载代码？ 理论上，浏览器可以解析的文件需要编写下载代码 实际开发中，只要是下载的文件都编写文件下载代码 response 获得的流不需要主动关，tomcat 容器会帮助我们关闭 getWriter() 与 getOutPutStream() 不能同时调用, 如果同时调用则会报 500 异常: getOutPutStream() / getWriter() has been called for this response window.onload 的匿名函数内部的函数属于局部私有函数，外部无法访问，所以 onclick 点击事件的函数不能放在 window.onload 内部 window.onload = function(){ ​ function(){} } HttpServletRequest只有 form 表单提交，并且提交方式为 post 时才是 post 提交，请求体中有数据，其他方式都是 get 提交，请求体为空，数据在请求行 通过 request 获得请求行request.getMethod(); – 获得请求方法 – get、post request.getRequestURI(); – 一般指所有路径 – /项目名/应用名 request.getRequestURL(); – 一般指 web 的路径 – http:localhost:8080/项目名/应用名 – 会带上网络协议,多个主机名和主机端口 request.getContextPath(); – 指上下文路径（web 应用名称） request.getQueryString(); – 获得请求行后的数据字符串，如果为 post 提交则为 null request 可以获得客户机（客户端） 的一些信息 request.getRemoteAddr() – 获得访问客户端的 ip 地址 通过 request 获得请求头request.getHeader(“”);– 获得指定的头 request.getHeader(“referer”); 获得请求来源，如 http://localhost:8080/web/xxx.html 再利用 startWith() 函数判断是否以自己的网站为开头，判断是否盗链 通过 request 获得请求体获得单个表单值 String request.getParameter(“”); 获得多个表单的值 String [] request.getParameterValues(); 获得所有请求参数名称(没用) Enmueration getParameterNames(); 获得所有参数 封装到一个 Map&lt;String,String[]&gt; Map&lt;String,String[]&gt; getParameterMap(); post、get 方式提交，以上方法通用 request 其他功能request 是一个域对象 请求重定向（response.sendRedirect(); 服务器外部行为，需要客户端二次请求访问不同 servlet，地址会变） 请求转发 服务器内部行为，只有一次请求，servlet1 没有资源自己找 servlet2 ,把请求（request）转发给servlet2要资源，servlet2 返回给 客户端，地址不会发生变化 获得请求转发器， path 是转发地址 RequestDispatcher getRequestDispatcher(String path) 请求转发是在一次请求中，总计访问服务器一次，所以地址还会带有 web 根目录，不需要再添加 request.getContextPath()，来补全地址，重定向则需要 通过转发器对象转发 requestDispatcher.forward(ServletRequest,ServletResponse)–转发的数据在不同 servlet 就取不到域中的值了 请求转发是服务器内部行为，整个请求在 web 工程内部，可以直接写 /servlet2 相对路径，不用加工程名（服务器端地址，服务器内部的叫服务器端地址，不用写 web 应用名称）请求转发等 客户端去访问的叫客户端地址，服务器外部的地址，需要加上 web 应用名称：重定向、直接输入地址等 request 的域范围在一次请求中，每次访问（请求）都会创建一个新的 request 跟 response dispatcher.forward(request,response); 转发 request 不论多少次都算一个请求（虽然都是不同对象，但是 request 内部的值是相同的） 转发性能优于重定向，重定向可以访问外部网站，转发只能访问内部的资源 request 在访问时创建，响应结束销毁，作用域一次请求 存在域中的数据都是 Object 类型的，getAttribute 获得的数据也是 Object，但若知道原来存进去的数据类型，取出来后可以进行强转 setAttribute(“string”,”object”); Object getAttribute(“string”); 解决 request 乱码问题获得页面数据乱码过程： 张三 —&gt; 页面进行 utf-8 编码 —&gt; request 获取数据进行 ios8859-1 解码（默认解码方式）—&gt; 乱码 解决乱码过程： 乱码 —&gt; 使用 ios8859 编码 —&gt; 使用 utf-8 解码 —&gt; 张三 编码方式：str.getByte(“ios8859-1”); 解码方式：new String(bytes,”utf-8”); 将编码和解码方式合并：new String(str.getByte(“iso8859-1”),”utf-8”); 以上方式可以解决 get 和 post 方式提交表单，但是需要对一个对象中每个字段进行编解码，如果在 Map 中的数据还需要在 for 循环中编解码。 但是 post 提交可以用更简便的 request.setCharacterEncoding(“utf-8”); 使用这种方式，只需要写一条，所有的字段都可以解决乱码 request.getParameter(); filter 配置 request 解决乱码问题参考：https://www.cnblogs.com/yyhl/p/9212301.html tomcat 8.5 等服务器 使用了过滤器配置 parameter = new String(parameter.getBytes(“iso8859-1”),”UTF-8”); 会乱码，因为 parmeter 获取到时已是中文，二次编解码会乱码 重定向是客户端重新访问一个 servlet ，属于客户端地址，所以重定向地址不应该固定,用 request 获得上下文路径（web 项目的路径） response.sendRedirect(request.getContextPath”/web/xxx.jsp”); BeanUtils 的方法Map&lt;String,String[]&gt; properties = request.getParameterMap(); User user = new User(); BeanUtils.populate(user,properties); 工作原理：将 map 中的数据根据 key 与实体的属性对应关系封装 只要 key 中的属性与实体的属性名字相同，就自动封装到实体 JSP JAVA Server Page：是在 html 页面写入 java 代码，本质是一个 servlet ，作为简化的 servlet 而发明，擅长写页面，不擅长写 java 代码 在 java 代码中写入 html 页面，擅长写 java 代码，但是写页面比较繁琐，从而诞生了 JSP JSP 运行原理jsp 在第一次访问时（或被修改后）会被 web 容器（tomcat）翻译成 servlet （helloServlet.jsp–&gt;helloServlet_jsp.java）然后编译运行 被翻译后的文件在 tomcat 目录的 work 文件夹下 JSP 的 page 指令12&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt; language=&quot;java&quot; 设置 JSP 插入语言，可以不写 contentType=&quot;text/html; charset=UTF-8&quot; JSP 页面上的 contentType 在编译为 servlet 后会变成 response.setContentType(“text/html”;charset=”UTF-8”); 跟 servlet 中解决网页乱码问题的方法一致，可以用来设置 response 中缓冲区的编码，并知道页面解析时的编码 可以被包含在 pageEncoding 内 pageEncoding=&quot;UTF-8&quot; JSP 文件本身的编码格式 isErrorPage/errorPage: 用来处理服务器端错误 （500错误），无法处理 400 找不到页面错误 404 错误用使用 web.xml 下配置应用的全局错误页面 1234&lt;error-page&gt; &lt;error-code&gt;404&lt;/error-code&gt; &lt;location&gt;/error.jsp&lt;/location&gt;&lt;/error-page&gt; JSP 的 include 指令 &lt;%@ include file=&quot;header.jsp&quot;%&gt; 可以引入其他的 JSP 页面 开发时可以先写页面头跟尾，在重复引用即可 JSP 的 taglib 指令 &lt;%@ taglib uri=&quot;&quot; prefix=&quot;c&quot;%&gt; &lt;c:if&gt; &lt;c:if&gt; prefix:用来标记一个标签库，使用该标签库时就使用该标记 一般用来引入 jstl 标签库/struts2 标签库 JSP 九大隐式对象4大域： page 域 ：pageContext：当前 JSP 页面范围可见（A页面转发到B页面也无法取到） request 域 ：一次请求（不包括返回） session 域 ：一次会话 application 域 ：servletContext 的域 （整个 web 应用） out：输出类型 JspWriter out 作用：向客户端输出内容，out.write(); 直接在 html 页面写数据、使用 &lt;%out.write()%&gt;以及&lt;%=&quot;xxx&quot;&gt;都会在servlet 转换成 out.write(“”); 并将数据放在 out 的缓冲区，out 缓冲区默认大小 8k 可以在&lt;%@ page buffer=&quot;0kb&quot;%&gt;设置关闭 out 缓冲区，从而使用 response 使用&lt;%response.getWriter.write()%&gt;则把数据放在 response 缓冲区，tomcat 默认从 response 获取数据，所以加载 response 数据会快一些，之后会将 out 缓冲区数据放到 response 缓冲区 pageContext：可以向不同域设置内容 1234567&lt;%request.setAttribute("name","zhangsan");pageContext.setAttribute("name","sunba");pageContext.setAttribute("name","lisi",pageContext.REQUEST_SCOPE);pageContext.setAttribute("name","wangwu",pageContext.SESSION_SCOPE);pageContext.setAttribute("name","tianqi",pageContext.APPLICATION_SCOPE);%&gt; 1234 &lt;%--findAttribute 从小到大搜索域范围中的 name 范围从小到大 page域(pageContext 对象)--&gt;request域--&gt;session域--&gt;application域(servletContext)--%&gt;&lt;%=pageContext.findAttribute("name")%&gt; JSP 标签（动作）include1.jsp 与 include2.jsp 静态包含&lt;%@include file=&quot;&quot;%&gt; 将 include2 的页面拷贝到 include1.jsp，再翻译成 include1_jsp.java 静态包含最终有一个文件 动态包含&lt;jsp:include page=&quot;&quot; 将 include1.jsp 翻译成 include1_jsp.java 编译运行后 发现其中的 include(request,response,”include2.jsp”,out,false); 再回去找 include2.jsp 将 include2.jsp 翻译成 include2_jsp.java 再编译运行 动态包含有两个文件 &lt;jsp:forward page=&quot;/forward2.jsp&quot;&gt;&lt;jsp:forward&gt; 请求转发，跟 request.getRequestDispatcher(“/forward2.jsp”).forward(request,response); 一致 将请求从 forward1.jsp 转发到 forward2.jsp 网址还是 forward1.jsp 内容显示 forward2.jsp el 表达式防止 jsp 中嵌入过多 java 代码，从而使用 el 表达式从域中取数据，逻辑判断用 JSTL 从而代替 java 代码 el 从域中取出数据（最重要的 el 功能） 全域查找： 各个域查找： ${requestScope.key }; ${sessionScope.key }; ${applicationScope.key }; 全域查找： ${key}; 底层是 application.findAttribute(); 方法，依次从 pageContext 域，request 域，session 域，application 域中获取属性，在某个域中获取到了则不再往后找 el 表达式没有内置 八大对象，需要用 pageContext 获取 pageContext 功能跟 jsp 类似，能获取八大对象 ${pageContext.request } ${pageContext.request.contextPath } 等于 request.getContextPath(); 常用于重定向 response.sendRedirect(request.getContextPath()+”/product/xxx.jsp”); 用来获取 web 应用名称，通常用于拼接重定向目录 防止 web 应用名称修改后项目无法使用 如： &lt; form action=”${pageContext.request.contextPath }/xxx/xxx.jsp” method=”post”&gt; 拼接的是访问地址 http://localhost:8080/admin/home.jsp 8080 后，/admin 前的这一段地址，在 ieda 修改这段地址的方法是在 tomcat 设置中 Deployment 栏 Application context 栏修改 客户端地址（一般 src 中获取外部链接，插入外来页、导入 css 包、获取图片等都是客户端地址）需要加上 web 应用名称，这样就是绝对地址 JSTL 技术1&lt;%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c"%&gt; &lt;c:if test=&quot;${1=1} &quot;&gt;&lt;c:if&gt; 当 test 中返回为 true 才会进入体内 模拟普通 for 循环 for(i=0;i&lt;5;i++){ } &lt;c:forEach begin=&quot;0&quot; end=&quot;5&quot; var=&quot;i&quot;&gt;&lt;c:forEach&gt; 从 0 开始到 5 ，把每次循环的值赋给 i 模拟增强 for 循环 for(Product product : productList){ } 往 items 中放集合需要借助 el 表达式 &lt;c:forEach items=&quot;${productList }&quot; var=&quot;product&quot;&gt;${product.pname}&lt;c:forEach&gt; 循环取出 productList 集合中每项的 product 的 pname 属性 var 中的每一个数据都是临时存放在在 page 域中，循环过程中被下一个数据所覆盖 el 表达式中可以有空格，但表达式与冒号间不能有空格 “${productList} “(错误) forEach 中的 varStatus count 是从 1 开始循环计数的 index 从 0 开始 如果 items 中没有加 ${} 直接取值会报 Caused by: javax.el.PropertyNotFoundException: Property [oid] not found on type [java.lang.String] 异常 123&lt;c:forEach items=&quot;$&#123;orderList &#125;&quot; var=&quot;order&quot; varStatus=&quot;vs&quot;&gt;$&#123;vs.count&#125;$&#123;vs.index&#125; javaee 开发模式1.模式是开发过程中总结出的“套路”，约定俗成的设计模式 2.javaEE 的模式 model1：jsp+javaBean：随着业务繁琐，导致 jsp 页面混乱 model2：jsp+servlet+javaBean：开发中使用各个技术擅长的方面 mvc：– web开发模式 M：model-模型：javaBean：封装数据 V： view-视图：Jsp：单纯页面显示 C：Controller-控制器：Servlet：获取数据-对数据封装-传递数据数据-指派显示页面 javaEE 的三层架构：–javaEE独有web层：与客户端交互：收集页面数据、封装数据、传递数据、指定响应 jsp 页面 service层：复杂业务处理：逻辑业务代码编写 dao层：与数据库交互：数据库访问代码 开发时体现在包结构 web 层的作用 接受客户端表单数据 封装散装数据成实体 bean，发送数据到 service 层 vo：value object 用来专门传递值，可以专门把 实体 bean 中不存在的判断条件封装一个新的 vo 对象 例如condition 条件对象 接受 service 层返回的数据，并指定跳转页面 service 层作用 接受 web 层传来的 bean 对象，并将其传给 dao 层 接受 dao 层返回的查询数据，将其返回给 web 层 dao 层作用 接受 service bean 对象，查询数据库数据 将查询到的数据返回给 service 层 事务一件事情有 n 个组成单元，要不这 n 个组成单元同时成功，要不就同时失败，就是将 n 个组成单元放到一个事务中 Mysql 事务mysql 有默认的事务：一条 sql 语句就是一个事务，默认开启事务并提交事务 手动 mysql 事务： 显示开启一个事务： start transaction ：开启事务后所有 sql 语句不修改数据库，但保存在一个日志中，可查询 事务提交：commit 表示开启事务到事务提交内所有 sql 语句有效，并更新数据库 事务的回滚：rollback 表示事务回滚，总事务开启到事务回滚，中间所有 sql 操作无效，不更新数据库 JDBC 事务默认自动事务，执行 SQL 语句：executeUpdate（），每执行一次 executeUpdate 代表事务自动提交 jdbc 开启手动事务： 开启事务：conn.setAutoCommit(false); 提交事务：conn.commit(); 回滚事务：conn.rollback(); 控制事务的 connection 必须是同一个，执行 sql 的 connection 与控制事务的 connection 必须是同一个，才能控制事务 DBUtil 事务操作DBUtil 事务控制也是通过 JDBC （进行了封装） QueryRunner runner = new QueryRunner(DataSource datasource); DateSource 会自动寻找 xml 中的数据库连接配置，从连接池中随机获取一个 Connection，随机的 conn 无法控制事务 有参构造将数据源（连接池）作为参数传入 QueryRunner，QueryRunner 会从连接池中获得一个数据库连接资源操作数据库，直接使用无 Connection 参数的方法即可操作数据库 如果要进行事务控制则使用无参 QueryRunner 构造,从而自己再方法体中获取一个 conn，利用确定的 conn 进行事务控制 12345678910QueryRunner runner = new QueryRunner(）&#123; //用 JDBC 的方式获得一个 conn Connection conn = DataSource.getConnection(); //用 conn 开启事务 conn.setAutoCommit(false); runner.update(conn,sql); //提交事务或回滚 conn.commit();&#125; 如果用 SQLException 无法 catch 到 1/0 异常，网页会产生如下异常，而且事务也无法控制住会丢失金额 错误信息： Type Exception Report（点击详细信息） Type Exception ReportMessage / by zero Description The server encountered an unexpected condition that prevented it from fulfilling the request.Exception java.lang.ArithmeticException: / by zero com.itheima.service.TransferService.transferMoney(TransferService.java:21) com.itheima.web.TransferServlet.doGet(TransferServlet.java:24) com.itheima.web.TransferServlet.doPost(TransferServlet.java:12) javax.servlet.http.HttpServlet.service(HttpServlet.java:661) javax.servlet.http.HttpServlet.service(HttpServlet.java:742) org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52) Note The full stack trace of the root cause is available in the server logs. 代码案例：DBUtilsDemo 公司接口：根据客户给出的参数从数据库查询出相关信息返回一个集合 ThreadLocal ：javaEE三层架构间都是一个线程执行方法，ThreadLocal 底层是一个 Map，key 都为 Thread-1，只存储 value，应用：通过线程绑定方式传递参数（Connection） 事务的特性 面试题 （概念问题）缩写（ACID） 原子性（Atomicity)原子性指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生 一致性（Consistency）一个事务中，事务前后的完整性必须保持一致 隔离性（Isolation）多个事务间的关系，隔离性指多用户并发访问数据库时，一个用户的事务不能被其他用户的事务所干扰，多个并发事务之间数据要相互隔离（多个用户访问时每个用户都会有一个独立的ThreadLocal，那么每个 ThreadLocal 中存放的 Connection 也是不同的，可以保证每个 conn 控制一个事务） 持久性（Durability）持久性指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即时数据库发生故障也不会对其有任何影响 事务并发访问问题（由事务的隔离性引起） 脏读：B 事务读取到了 A 事务尚未提交的数据 – 需要 B 事务读取 A 事务已提交的数据 例：A 向 B 转账，B 读到了 A 未提交的转账记录，然后 A 将事务回滚，钱仍在 A 处 不可重复读：一个事务中 两次读取的事务不一致 – 需求一个事务中多次读取时数据是一致的 –update 例：在你开启事务后，你读取了自己银行卡的金额，发现有 5000 余额，此时你老婆刷走了 5000 块，你在这个事务中读取金额仍然还是显示 5000 余额，只有你关闭了这个事务，再次开启一个事务查询时才知道你已经是个穷鬼了 幻读/虚读：一个事务中 两次读取数据的数量不一致 – 要求在一个事务多次读取数据的数量是一致的 – insert delete 例：与不可重复读类似，在一次事务中，你读取自己银行卡的交易记录，一共有 4 条，此时你老婆刷了 5000 那一笔钱，你在这个事务中再次查询也无法看到这次消费，需要再开一个事务才能查询到 事务的隔离级别 read uncommited：读取尚未提交的数据–无法解决任何问题 read commited：读取已提交的数据–可以解决脏读 – oracle 默认 repeatable read：重复读取–可以解决脏读和不可重复读–mysql 默认 serializable：串行化–可以解决 脏读 不可重复读 和 虚读–相当于锁表，性能过低不使用 注解@override 帮助开发人员检查覆盖父类方法是否正确–给编译器用 @SuppressWarning(“rawtype”) List list = new ArrayList(); 压制警告（忽略类型安全），压制警告括号内可以为数组，表示压制多个警告，也可以为 “all” 压制所有警告 @Deprecated 标注过时方法 元注解修饰注解的注解，在注解类上使用，用来限制定义的注解的特性 @Target({TYPE,METHOD…,PARAMETER}) 表示该注解可以用于哪些东西上 TYPE:可以用于类/接口上 METHOD：可以用于方法上 FIELD：字段上能用 java 代码运行过程： demo.java(源码级别) —&gt; 经过编译器 —&gt; demo.class(字节码级别) —&gt; 经过类加载器 —&gt;Class(字节码对象，运行时级别) @Retention(RetentionPolity.RUNTIME) 运行可见级别 SOURCE：源码级别可见 CLASS：字节码文件级别 RUNTIME：运行时级别 Junit4 idea 测试设置 动态代理1234567//反射获得方法Method method = clazz.getMethod(method,req,resp)xxx方法method.invoke()xxx方法 在方法执行前后进行一些操作，就是面向切面编程 获得动态代理对象(点击详细) //获得动态的代理对象—-在运行时 在内存中动态的为Target创建一个虚拟的代理对象 //objProxy是代理对象 根据参数确定到底是谁的代理对象TargetInterface objProxy = (TargetInterface) Proxy.newProxyInstance( Target.class.getClassLoader(), //与目标对象相同的类加载器 new Class[]{TargetInterface.class}, newInvocationHandler() { //invoke 代表的是执行代理对象的方法 @Override //method：代表目标对象的方法字节码对象 //args:代表目标对象的响应的方法的参数 public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { System.out.println(“目标方法前的逻辑”); //执行目标对象的方法 Object invoke = method.invoke(new Target(), args); System.out.println(“目标方法后的逻辑”); return invoke; } }); Q&amp;AQ: servlet 的转发页面空白无显示1request.getRequestDispatcher("admin/product/list.jsp").forward(request,response); A: 如把代码写在 doGet 中需要在 doPost 中进行 doGet 覆盖，或把代码写在 doPost 中，在 doGet 进行 doPost 覆盖 Q:在 servlet 设置断点无法进断点，后台、网页无报错A:如果无法进入断点说明问题在于 页面， 参数无法传递到后台 可能的错误有：json 参数传递语句错误、JQuery 的 ajax 语句 $.post(); 写成 $post.{}; 等 Q:java.lang.NoSuchMethodExceptionA: 如果在整合 servlet 时没有将内部方法的 protect 变成 public 则会出现此问题 Q:java.io.FileNotFoundException: .\xx\xx (拒绝访问。)A: 一般这种情况是访问的是一个文件目录而不是文件 参考：https://blog.csdn.net/w405722907/article/details/78610485 Q:Data truncation: Incorrect datetime value: ‘’A: 存入的 Date 与数据库 Date 格式不符，setDate() 前先进行 Date 格式化： 12345678910SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;); //SimpleDateFormat中的format方法可以 //把Date型的字符串转换成特定格式的String类型 String format = simpleDateFormat.format(new Date()); //SimpleDateFormat中的parse方法可以 //把String型的字符串转换成特定格式的date类型 Date parse = simpleDateFormat.parse(format); //将转换格式的 Date 存入 product product.setPdate(parse); Q:表单中 循环显示,只显示最后一组 tr 的内容，且标题 tr 项不显示 A: 标题 tr 项写错内容，与数据的 项不一致 Tips:一般没有 request 域数据传递使用 重定向 response.sendRedirect(request.getContextPath());（后台地址获取直接 request.getContextPath()） 有 request 域传递数据的使用 请求转发request.getRequestDispatcher(“admin/product/list.jsp”).forward(request,response+“/admin/product/list.jsp”); 如果在注解中配置了 urlPatterns 地址跟 重定向 response.sendRedrest(path); 的地址相同，则会出现死循环，网页提示重定向次数过多，如果提交了表单， 数据库会出现多个空白数据，需要进行空表单验证 12345//获取表单数据Map&lt;String, String[]&gt; properties = request.getParameterMap();//封装数据Product product = new Product（）；BeanUtils.populate(product,properties); 此方法会将表单提交的属性根据 name 值 与 Bean 的属性名 对应起来，然后将表单提交的属性封装成一个 Bean a 标签有自己内置的点击事件，如果 a 标签有 href 属性，在点击后会自动跳转到页面头 阻止事件传播： # 代表本页面 &lt;a href=&quot;#&quot; onclick=&quot;delProduct()&quot;&gt;&lt;a/&gt; 将 href 中内容改为 javascript:void(0); &lt;a href=&quot;javascript:void(0);&quot; onclick=&quot;delProduct()&quot;&gt;&lt;a/&gt; 可以防止点击 a 标签后默认样式的 href 无任何行为 123456789&lt;select name="cid"&gt; &lt;c:forEach items="$&#123;categoryList &#125;" var="category"&gt; &lt;option value="$&#123;category.cid &#125;"&gt; $&#123;category.cname &#125; &lt;/option&gt; &lt;/c:forEach&gt;&lt;/select&gt; items 的值与 servlet 中 setAttribute 的值名相同，var 为循环 items 的值后单个的值 不让用户看到，但是后台需要某个属性时，使用隐藏域传递数据 &lt;input type=&quot;hidden&quot; name=&quot;pid&quot; value=&quot;${product.pid}&quot;/&gt; 传递 pid 的值到 servlet Map&lt;String,String[] properties = request.getParameterMap(); 将前台的属性全部获取，以便之后进行对象的封装 1enctype=&quot;multipart/form-data 如果在 form 中有如上代码，页面能跳转，但是修改不回生效 当 form 使用 enctype=”multipart/form-data” 多表单提交时，getParameter 将无法获取到值，根据 getMethod（） 取值的 BaseServlet 方式抽取 Servlet 会获取不到 method， 需要重新创建继承 HttpServlet 的文件上传 从数据库查询多表或单表的数据时，可以直接封装 map 而不是对象，以 json 字符串返回前台 代码示例web核心内容 商城小demo]]></content>
      <tags>
        <tag>java</tag>
        <tag>web</tag>
        <tag>servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SomeProblem]]></title>
    <url>%2F2018%2F12%2F11%2FSomeProblems%2F</url>
    <content type="text"><![CDATA[serlvet 提交 post 乱码解决方法： request.setCharacterEncoding(“UTF-8”); 或者使用先编后解码方式解决 Jquery post 提交已经自动进行过编解码，不需要再写，如果二次编解码反而会乱码 get 提交乱码： 先编码再解码 JQuery get 中文提交乱码： 先编码后解码]]></content>
      <tags>
        <tag>java</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springMVC32]]></title>
    <url>%2F2018%2F10%2F30%2FspringMVC32%2F</url>
    <content type="text"><![CDATA[大致流程流程参考：IDEA整合SSM框架：Spring+SpringMVC+Mybatis 入门 Springmvc 流程 Web 工程 导入 jar 包 web.xml 中配置前端控制器（指定上下文路径 classpath：springmvc.xml） 拦截规则 拦截所有（包括 Jsp）：/* 拦截除了 JSP 以外部分 : / .action 或 .do springmvc.xml 配置扫描 @controller 注解 Action Controller Handler 处理器 需要写的部分：类上@Controller 方法上 @RequestMapping（Value=请求的路径）.action 可以省略 Public ModelAndView itemList(){ ​ new ModelAndView ​ 设置数据 ​ 设置 JSP 页面路径（跳转路径 /WEB-INF/jsp/xxx.jsp） } 架构分析一个中心 三个基本点 前端控制器（在 web.xml 中配置） 处理器映射器 处理器适配器 视图解释器 由 Springmvc 提供 Handler 处理器 JSP 视图（页面，即 html 标签） 由程序员书写 默认三大组件默认三大组件已废弃 现组件：RequestMappingHandlerMapping (处理器映射器) RequestMappingHandlerAdapter (处理器适配器) 可用 &lt;mvc:anonation-driver/&gt; 代替 处理器映射器 和 处理器适配器的配置 视图解释器 用来优化 JSP 页面的路径书写 /WEB-INF/jsp/xxx.jsp 可以拼接 xxx 的前后缀 整合 mybatis SqlMapConfig.xml 核心配置文件（别名） applicationContent.xml 数据源 druid （替代 JDBC）读取 db.properties Mybatis 的工厂以及 Mybaits Mapper 动态代理开发的扫描方式 扫描基本包 创建 db.properties 文件 事务、扫描@Service Spring+Mybatis 创建 Springmvc.xml 三大组件 扫描基本包（com.itheima 包下 controller 与 Service 全扫描） web.xml 文件中配置监听器读取 applicationContext.xml 上下文 配置前端控制器读取 Spingmvc.xml 配置 POST 提交乱码 Fittler 过滤器 参数绑定 默认参数绑定 Request Response Session Model 实现关系 ModelMap 简单类型参数绑定 方法的形参上（Integer id String Double double Boolean） POJO 类型 Items items input name = name name 与 items 对象中属性名一致 包装类型 QueryVo （内含 Items） Query Vo items.name （传参方式） 自定义参数格式 转换日期：在 Springmvc.xml 配置转换器的工厂 Converters list set array 创建自定义转换器类 实现 Converter&lt;S,T&gt; Strus2 与 Springmvc 区别 入口 Servlet 与 Fittler 单例 多例 值 Request域 controller 返回值 ModelAndView 万能的 带数据 返回视图路径后结束 String 只能返回视图路径 需要通过方法传参数 Model model，通过 model 带数据 request.setAttribute(),model.addAttribute(“itemsList”,list); 官方推荐 符合解耦合 数据 视图 分离 MVC void ajax 请求 适合返回 json 格式数据（response 异步请求使用，不用刷页面） 重定向与内部转发区别重定向的页面在提交后会跳转到 重定向的路径（网址） 内部转发的页面在提交后不会跳转 会在修改页面的路径（网址） SpringMVC 三大组件 处理器映射器（HandlerMapping）、视图解析器(ViewResolver) 、处理器适配器(HandlerAdapter) 三大组件的默认配置文件 /springmvc32/web/WEB-INF/lib/spring-webmvc-4.1.3.RELEASE.jar!/org/springframework/web/servlet/DispatcherServlet.properties 在 springmvc 的配置文件中修改默认配置 springmvc.xml 123456789101112131415161718&lt;!--扫描 @Controller @Service --&gt; &lt;context:component-scan base-package="com.itheima"&gt;&lt;/context:component-scan&gt; &lt;!-- 处理器映射器 --&gt; &lt;!--&lt;bean class="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping"/&gt;--&gt; &lt;!-- 处理器适配器 --&gt; &lt;!--&lt;bean class="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter"/&gt;--&gt; &lt;!-- 注解驱动:可以替代以上两个配置 --&gt; &lt;mvc:annotation-driven/&gt; &lt;!-- 视图解析器 --&gt; &lt;!-- 跟 ItemController 的 setViewName 中的内容拼接成完整地址 --&gt; &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix" value="/WEB-INF/jsp/"/&gt; &lt;property name="suffix" value=".jsp"/&gt; &lt;/bean&gt; ItemServiceImpl 中实现接口，并覆写实现方法 将方法放到接口 ItemService controller 控制层中 @RequestMapping(value=”/网页中的 form 中 action 相对地址”) jsp 中 input 的 name 属性中的内容与接受的 Items（bean）的 name 属性一致 jsp 页面上的 name 属性名的参数绑定与 Controller 中传入的 POJO 形参名无关，而是属性名与 POJO 对象中的成员变量名一致 ​ 但是如果将 POJO 进行了包装，将 Items 类封装到 Vo 类中，Vo 类中有着获取、修改 Items 类的方法，则在 jsp 页面的 name 属性名的参数绑定将变为 Items.（Items 类中的成员变量名） 例如：Items.name Q&amp;AQ1: idea 编译出现 “文档中根元素后面的标记必须格式正确” 字样错误提示A: 这个错误一般是元素未正确结束，或者出现未知元素造成的 . 提示这行不代表就是这行，提示是告诉你这个元素有问题，这个元素下面的任何子元素都可能存在问题 错误点：未将 等代码放入 栏 Q2: 运行后网页提示错误：​ org.xml.sax.SAXParseException; lineNumber: 10; columnNumber: 9; cvc-complex-type.2.3: 元素 ‘beans’ 必须不含字符 [子级], 因为该类型的内容类型为“仅元素”。 A: 在 标签中多了一个 、 Q3: debug 报错：​ org.apache.jasper.servlet.TldScanner.scanJars At least one JAR was scanned for TLDs yet contained no TLDs. Enable debug logging for this logger for a complete list of JARs that were scanned but no TLDs were found in them. Skipping unneeded JARs during scanning can improve startup time and JSP compilation time. A: 在apache-tomcat-8.5.29\conf目录下找到logging.properties文件，对文件进行编辑，在最后一行加入： 1234567891011121314151617181920212223242526272829303132333435这样就不再显示错误信息了。http://blog.51cto.com/lavasoft/2087440##### Q4: Tomcat 8报错 SEVERE: One or more listener failed to start​ 06-Nov-2018 17:26:46.429 信息 [RMI TCP Connection(3)-127.0.0.1] org.apache.jasper.servlet.TldScanner.scanJars At least one JAR was scanned for TLDs yet contained no TLDs. Enable debug logging for this logger for a complete list of JARs that were scanned but no TLDs were found in them. Skipping unneeded JARs during scanning can improve startup time and JSP compilation time.​ 06-Nov-2018 17:26:46.465 严重 [RMI TCP Connection(3)-127.0.0.1] org.apache.catalina.core.StandardContext.startInternal One or more listeners failed to start. Full details will be found in the appropriate container log file​ 06-Nov-2018 17:26:46.468 严重 [RMI TCP Connection(3)-127.0.0.1] org.apache.catalina.core.StandardContext.startInternal Context [] startup failed due to previous errorsA: &gt; Full details will be found in the appropriate container log file 意思是让我们在日志文件中查看详细报错信息，那日志文件在哪里呢？这里如果我们是使用idea调试，则日志文件存放在C:\Users\Administrator\.IntelliJIdea2017.1\system\tomcat\Unnamed_SpringMVCDemo\logs 详细问题在 logs 文件夹的几个日志文件中参考：https://blog.csdn.net/dkbnull/article/details/81605157 &gt; If you are using IntelliJ IDEA, and deploy application on Tomcat Server, it says: Under File menu -&gt; select project Structure -&gt; click artifact -&gt; select your jars and right click -&gt; put in WEB\lib -&gt; restart server参考：https://stackoverflow.com/questions/6210757/java-lang-classnotfoundexception-org-springframework-web-context-contextloaderl##### Q5: 启动服务后网页报错```javaorg.springframework.beans.factory.BeanCreationException: Error creating bean with name &apos;itemController&apos;: Injection of autowired dependencies failed; nested exception is org.springframework.beans.factory.BeanCreationException: Could not autowire field: private com.itheima.springmvc.service.ItemService com.itheima.springmvc.controller.ItemController.itemService; nested exception is org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of type [com.itheima.springmvc.service.ItemService] found for dependency: expected at least 1 bean which qualifies as autowire candidate for this dependency. Dependency annotations: &#123;@org.springframework.beans.factory.annotation.Autowired(required=true)&#125; A: spring在管理创建bean的时候发生了错误，一是检查注解是否正确@Service;二是看看web.xml中配置的 spring容器的 xml 文件是否错误 未添加 ItemServiceImpl 的 @Service 注释 参考：https://blog.csdn.net/zxz9325/article/details/79179444 Q6: HTTP Status 500 – Internal Server Error Type Exception Report Message Request processing failed; nested exception is java.lang.NumberFormatException: null Description The server encountered an unexpected condition that prevented it from fulfilling the request. Exception 1org.springframework.web.util.NestedServletException: Request processing failed; nested exception is java.lang.NumberFormatException: null A: 应该打开查询网页 http://localhost:8080/itemEdit.action 而非直接打开 http://localhost:8080/item/itemEdit.action，无法直接访问，而且没有传 id 导致为空 Q7: 运行后显示 404Type Status Report Description The origin server did not find a current representation for the target resource or is not willing to disclose that one exists. A: http://blog.csdn.net/DBC_121/article/details/79204340 @requestMapping(value=””) 中 value 地址书写错误 Q8:HTTP Status 400 – Bad RequestType Status Report Description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). A: jsp 页面上的 name 属性名的参数绑定与 Controller 中传入的 POJO 形参名无关，而是属性名与 POJO 对象中的成员变量名一致,如果不一致则在后台获取不到参数 Q9:jsp 页面 name 属性名应与 POJO 内部成员变量一致HTTP Status 500 – Internal Server Error Type Exception Report Message Request processing failed; nested exception is java.lang.NullPointerException Description The server encountered an unexpected condition that prevented it from fulfilling the request. A: 将 POJO 进行包装后没有在 jsp 页面进行 name 属性修改 如果将 POJO 进行了包装，将 Items 类封装到 Vo 类中，Vo 类中有着获取、修改 Items 类的方法，则在 jsp 页面的 name 属性名的参数绑定将变为 Items.（Items 类中的成员变量名） 例如：Items.name Q10:自定义异常错误HTTP Status 500 – Internal Server Error Type Exception Report Message Request processing failed; nested exception is java.lang.ClassCastException: java.lang.ArithmeticException cannot be cast to com.itheima.springmvc.exception.MessageException Description The server encountered an unexpected condition that prevented it from fulfilling the request. Exception 12345678910org.springframework.web.util.NestedServletException: Request processing failed; nested exception is java.lang.ClassCastException: java.lang.ArithmeticException cannot be cast to com.itheima.springmvc.exception.MessageException org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:978) org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:857) javax.servlet.http.HttpServlet.service(HttpServlet.java:635) org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:842) javax.servlet.http.HttpServlet.service(HttpServlet.java:742) org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52) org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:88) org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) org.apache.logging.log4j.core.web.Log4jServletFilter.doFilter(Log4jServletFilter.java:66) Root Cause 123456789101112131415java.lang.ClassCastException: java.lang.ArithmeticException cannot be cast to com.itheima.springmvc.exception.MessageException com.itheima.springmvc.exception.CustomExceptionResolver.resolveException(CustomExceptionResolver.java:19) org.springframework.web.servlet.DispatcherServlet.processHandlerException(DispatcherServlet.java:1167) org.springframework.web.servlet.DispatcherServlet.processDispatchResult(DispatcherServlet.java:1004) org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:955) org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:877) org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:966) org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:857) javax.servlet.http.HttpServlet.service(HttpServlet.java:635) org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:842) javax.servlet.http.HttpServlet.service(HttpServlet.java:742) org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52) org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:88) org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) org.apache.logging.log4j.core.web.Log4jServletFilter.doFilter(Log4jServletFilter.java:66) Note The full stack trace of the root cause is available in the server logs. A： 12345678910ModelAndView mav = new ModelAndView();if(e instanceof MessageException)&#123; MessageException me = (MessageException)e; mav.addObject("error",me.getMsg());&#125;else &#123; mav.addObject("error", "未知异常");&#125;mav.setViewName("error");return mav; Tips：intelj idea 添加本地 xsd 文件​ intellij idea配置外部dtd文件 ​ 打开file——Settings..(快捷键ctrl+alt+s); ​ 找到Languages&amp;Frameworks——Schemas and DTDs ​ 找到右侧的External Schemas and DTDs窗口中点击添加按钮 ​ 在 Explorer 栏找到下载好的外部 dtd 文件 ​ 在 URI 栏可以填入从 xml 文件头上找到的相对应约束 URI ​ intelj idea jar 包 导入​ 导入 jar 包 3种方法 intelj idea 中的 mybatis 逆向工程​ Mybatis在IDEA中使用generator逆向工程生成pojo,mapper ​ 12345// servlet 开发// String id = request.getParameter("id");// Items items = itemService.selectItemsById(Integer.parseInt(id));// Spring 底层还是使用 request 的 getParameter 方法获取 id 的值的，但是我们不需要自己去写，并且会自动帮我们转换 Int 类型 Items items = itemService.selectItemsById(id); Springmvc 与 Strus2 的区别参数绑定区别​ Strus2 绑定参数在类的属性（ Action 的成员变量上） ​ Springmvc 从客户端请求 key/value 数据，通过参数绑定，将其绑定在 controller 方法的形参上 ​ SpringMVC中的参数绑定总结 存储数据区别​ Springmvc 使用 ModelAndView.addObject(“”,””); ​ 底层是 request.setAttribute(“”,””); 存在 request 的域中，没有值栈概念 ​ Strus2 有值栈概念 入口区别​ Springmvc 入口是 servlet 前端控制器 ​ Strus2 是过滤器 filter 模式区别​ Springmvc 是单例模式（以方法为单位，每次请求复制一个方法副本） ​ Strus2 是多例模式（以类为单位，每个请求创建一个类） 代码实现简易 springmvc 代码 Springmvc-mybatis]]></content>
      <categories>
        <category>SpringMvc</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>springmvc</tag>
        <tag>mybatis Maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linuxInstall]]></title>
    <url>%2F2018%2F09%2F12%2FlinuxInstall%2F</url>
    <content type="text"><![CDATA[linux 无法使用 ifconfig https://www.cnblogs.com/dunitian/p/4974761.html ：使用新指令 ip 没有 ifcfg-eth0 ，可能为 ifcfg-ens33 或其他 https://hk.saowen.com/a/227c3c22a44418b6927076afcd72c05d41291f7d0e9dc7fa60031b591d9bedbc Centos 下安装与设置VIM编辑器 查找已安装的myslq 版本：​ #rpm -qa | grep mysql （注意大小写，如果mysql 不行就换MySQL） Linux 下 mysql 安装：遇到该错误哪个被需要 yum 哪个 12用yum命令安装依赖,多个依赖用空格隔开,命令如下: yum -y install libaio.so.1 libc.so.6 libcrypt.so.1 libdl.so.2 libm.so.6 net-tools 点击详细错误：依赖检测失败 libaio.so.1 被 MySQL-server-5.6.22-1.el6.i686 需要 libaio.so.1(LIBAIO_0.1) 被 MySQL-server-5.6.22-1.el6.i686 需要 libaio.so.1(LIBAIO_0.4) 被 MySQL-server-5.6.22-1.el6.i686 需要 libc.so.6 被 MySQL-server-5.6.22-1.el6.i686 需要 libc.so.6(GLIBC_2.0) 被 MySQL-server-5.6.22-1.el6.i686 需要 libc.so.6(GLIBC_2.1) 被 MySQL-server-5.6.22-1.el6.i686 需要 libc.so.6(GLIBC_2.1.2) 被 MySQL-server-5.6.22-1.el6.i686 需要 libc.so.6(GLIBC_2.1.3) 被 MySQL-server-5.6.22-1.el6.i686 需要 libc.so.6(GLIBC_2.10) 被 MySQL-server-5.6.22-1.el6.i686 需要 libc.so.6(GLIBC_2.2) 被 MySQL-server-5.6.22-1.el6.i686 需要 libc.so.6(GLIBC_2.2.3) 被 MySQL-server-5.6.22-1.el6.i686 需要 libc.so.6(GLIBC_2.3) 被 MySQL-server-5.6.22-1.el6.i686 需要 libc.so.6(GLIBC_2.3.3) 被 MySQL-server-5.6.22-1.el6.i686 需要 libc.so.6(GLIBC_2.3.4) 被 MySQL-server-5.6.22-1.el6.i686 需要 libc.so.6(GLIBC_2.4) 被 MySQL-server-5.6.22-1.el6.i686 需要 libc.so.6(GLIBC_2.7) 被 MySQL-server-5.6.22-1.el6.i686 需要 libc.so.6(GLIBC_2.8) 被 MySQL-server-5.6.22-1.el6.i686 需要 libcrypt.so.1 被 MySQL-server-5.6.22-1.el6.i686 需要 libcrypt.so.1(GLIBC_2.0) 被 MySQL-server-5.6.22-1.el6.i686 需要 libdl.so.2 被 MySQL-server-5.6.22-1.el6.i686 需要 libdl.so.2(GLIBC_2.0) 被 MySQL-server-5.6.22-1.el6.i686 需要 libdl.so.2(GLIBC_2.1) 被 MySQL-server-5.6.22-1.el6.i686 需要 libgcc_s.so.1 被 MySQL-server-5.6.22-1.el6.i686 需要 libgcc_s.so.1(GCC_3.0) 被 MySQL-server-5.6.22-1.el6.i686 需要 libgcc_s.so.1(GLIBC_2.0) 被 MySQL-server-5.6.22-1.el6.i686 需要 libm.so.6 被 MySQL-server-5.6.22-1.el6.i686 需要 libm.so.6(GLIBC_2.0) 被 MySQL-server-5.6.22-1.el6.i686 需要 libm.so.6(GLIBC_2.1) 被 MySQL-server-5.6.22-1.el6.i686 需要 libpthread.so.0 被 MySQL-server-5.6.22-1.el6.i686 需要 libpthread.so.0(GLIBC_2.0) 被 MySQL-server-5.6.22-1.el6.i686 需要 libpthread.so.0(GLIBC_2.1) 被 MySQL-server-5.6.22-1.el6.i686 需要 libpthread.so.0(GLIBC_2.2) 被 MySQL-server-5.6.22-1.el6.i686 需要 libpthread.so.0(GLIBC_2.3.2) 被 MySQL-server-5.6.22-1.el6.i686 需要 librt.so.1 被 MySQL-server-5.6.22-1.el6.i686 需要 librt.so.1(GLIBC_2.2) 被 MySQL-server-5.6.22-1.el6.i686 需要 libstdc++.so.6 被 MySQL-server-5.6.22-1.el6.i686 需要 libstdc++.so.6(CXXABI_1.3) 被 MySQL-server-5.6.22-1.el6.i686 需要 libstdc++.so.6(GLIBCXX_3.4) 被 MySQL-server-5.6.22-1.el6.i686 需要 libstdc++.so.6(GLIBCXX_3.4.11) 被 MySQL-server-5.6.22-1.el6.i686 需要 libstdc++.so.6(GLIBCXX_3.4.9) 被 MySQL-server-5.6.22-1.el6.i686 需要 net-tools 被 MySQL-server-5.6.22-1.el6.i686 需要[root@localhost mysql]# yum install libaio.so.1已加载插件：fastestmirrorLoading mirror speeds from cached hostfile- base: mirrors.njupt.edu.cn- extras: mirrors.163.com- updates: mirrors.163.com正在解决依赖关系–&gt; 正在检查事务—&gt; 软件包 libaio.i686.0.0.3.109-13.el7 将被 安装–&gt; 解决依赖关系完成依赖关系解决=============================================================================== Package 架构 版本 源 大小正在安装: libaio i686 0.3.109-13.el7 base 24 k事务概要安装 1 软件包总下载量：24 k安装大小：37 kIs this ok [y/d/N]: yDownloading packages:libaio-0.3.109-13.el7.i686.rpm | 24 kB 00:00Running transaction checkRunning transaction testTransaction test succeededRunning transaction警告：RPM 数据库已被非 yum 程序修改。** 发现 41 个已存在的 RPM 数据库问题， ‘yum check’ 输出如下：MySQL-server-5.6.22-1.el6.i686 有缺少的需求 libaio.so.1MySQL-server-5.6.22-1.el6.i686 有缺少的需求 libaio.so.1(LIBAIO_0.1)MySQL-server-5.6.22-1.el6.i686 有缺少的需求 libaio.so.1(LIBAIO_0.4)MySQL-server-5.6.22-1.el6.i686 有缺少的需求 libc.so.6MySQL-server-5.6.22-1.el6.i686 有缺少的需求 libc.so.6(GLIBC_2.0)MySQL-server-5.6.22-1.el6.i686 有缺少的需求 libc.so.6(GLIBC_2.1)MySQL-server-5.6.22-1.el6.i686 有缺少的需求 libc.so.6(GLIBC_2.1.2)MySQL-server-5.6.22-1.el6.i686 有缺少的需求 libc.so.6(GLIBC_2.1.3)MySQL-server-5.6.22-1.el6.i686 有缺少的需求 libc.so.6(GLIBC_2.10)MySQL-server-5.6.22-1.el6.i686 有缺少的需求 libc.so.6(GLIBC_2.2)MySQL-server-5.6.22-1.el6.i686 有缺少的需求 libc.so.6(GLIBC_2.2.3)MySQL-server-5.6.22-1.el6.i686 有缺少的需求 libc.so.6(GLIBC_2.3)MySQL-server-5.6.22-1.el6.i686 有缺少的需求 libc.so.6(GLIBC_2.3.3)MySQL-server-5.6.22-1.el6.i686 有缺少的需求 libc.so.6(GLIBC_2.3.4)MySQL-server-5.6.22-1.el6.i686 有缺少的需求 libc.so.6(GLIBC_2.4)MySQL-server-5.6.22-1.el6.i686 有缺少的需求 libc.so.6(GLIBC_2.7)MySQL-server-5.6.22-1.el6.i686 有缺少的需求 libc.so.6(GLIBC_2.8)MySQL-server-5.6.22-1.el6.i686 有缺少的需求 libcrypt.so.1MySQL-server-5.6.22-1.el6.i686 有缺少的需求 libcrypt.so.1(GLIBC_2.0)MySQL-server-5.6.22-1.el6.i686 有缺少的需求 libdl.so.2MySQL-server-5.6.22-1.el6.i686 有缺少的需求 libdl.so.2(GLIBC_2.0)MySQL-server-5.6.22-1.el6.i686 有缺少的需求 libdl.so.2(GLIBC_2.1)MySQL-server-5.6.22-1.el6.i686 有缺少的需求 libgcc_s.so.1MySQL-server-5.6.22-1.el6.i686 有缺少的需求 libgcc_s.so.1(GCC_3.0)MySQL-server-5.6.22-1.el6.i686 有缺少的需求 libgcc_s.so.1(GLIBC_2.0)MySQL-server-5.6.22-1.el6.i686 有缺少的需求 libm.so.6MySQL-server-5.6.22-1.el6.i686 有缺少的需求 libm.so.6(GLIBC_2.0)MySQL-server-5.6.22-1.el6.i686 有缺少的需求 libm.so.6(GLIBC_2.1)MySQL-server-5.6.22-1.el6.i686 有缺少的需求 libpthread.so.0MySQL-server-5.6.22-1.el6.i686 有缺少的需求 libpthread.so.0(GLIBC_2.0)MySQL-server-5.6.22-1.el6.i686 有缺少的需求 libpthread.so.0(GLIBC_2.1)MySQL-server-5.6.22-1.el6.i686 有缺少的需求 libpthread.so.0(GLIBC_2.2)MySQL-server-5.6.22-1.el6.i686 有缺少的需求 libpthread.so.0(GLIBC_2.3.2)MySQL-server-5.6.22-1.el6.i686 有缺少的需求 librt.so.1MySQL-server-5.6.22-1.el6.i686 有缺少的需求 librt.so.1(GLIBC_2.2)MySQL-server-5.6.22-1.el6.i686 有缺少的需求 libstdc++.so.6MySQL-server-5.6.22-1.el6.i686 有缺少的需求 libstdc++.so.6(CXXABI_1.3)MySQL-server-5.6.22-1.el6.i686 有缺少的需求 libstdc++.so.6(GLIBCXX_3.4)MySQL-server-5.6.22-1.el6.i686 有缺少的需求 libstdc++.so.6(GLIBCXX_3.4.11)MySQL-server-5.6.22-1.el6.i686 有缺少的需求 libstdc++.so.6(GLIBCXX_3.4.9)MySQL-server-5.6.22-1.el6.i686 有缺少的需求 net-tools 正在安装 : libaio-0.3.109-13.el7.i686 1/1 验证中 : libaio-0.3.109-13.el7.i686 1/1已安装: libaio.i686 0:0.3.109-13.el7完毕！ 然后 继续安装 mysql 包出现问题 12345678910[root@localhost mysql]# rpm -ivh MySQL-server-5.6.22-1.el6.i686.rpm错误：依赖检测失败： libgcc_s.so.1 被 MySQL-server-5.6.22-1.el6.i686 需要 libgcc_s.so.1(GCC_3.0) 被 MySQL-server-5.6.22-1.el6.i686 需要 libgcc_s.so.1(GLIBC_2.0) 被 MySQL-server-5.6.22-1.el6.i686 需要 libstdc++.so.6 被 MySQL-server-5.6.22-1.el6.i686 需要 libstdc++.so.6(CXXABI_1.3) 被 MySQL-server-5.6.22-1.el6.i686 需要 libstdc++.so.6(GLIBCXX_3.4) 被 MySQL-server-5.6.22-1.el6.i686 需要 libstdc++.so.6(GLIBCXX_3.4.11) 被 MySQL-server-5.6.22-1.el6.i686 需要 libstdc++.so.6(GLIBCXX_3.4.9) 被 MySQL-server-5.6.22-1.el6.i686 需要 选择 yum -y install libgcc_s.so.1 libstdc++.so.6出现新问题 点击显示详细错误：已加载插件… 已加载插件：fastestmirrorLoading mirror speeds from cached hostfile base: mirrors.njupt.edu.cn extras: mirrors.163.com * updates: mirrors.163.com正在解决依赖关系–&gt; 正在检查事务—&gt; 软件包 libgcc.i686.0.4.8.5-36.el7 将被 安装–&gt; 解决依赖关系完成错误： Multilib version problems found. This often means that the root cause is something else and multilib version checking is just pointing out that there is a problem. Eg.: 1. You have an upgrade for libgcc which is missing some dependency that another package requires. Yum is trying to solve this by installing an older version of libgcc of the different architecture. If you exclude the bad architecture yum will tell you what the root cause is (which package requires what). You can try redoing the upgrade with –exclude libgcc.otherarch … this should give you an error message showing the root cause of the problem. 2. You have multiple architectures of libgcc installed, but yum can only see an upgrade for one of those architectures. If you don’t want/need both architectures anymore then you can remove the one with the missing update and everything will work. 3. You have duplicate versions of libgcc installed already. You can use “yum check” to get yum show these errors. …you can also use –setopt=protected_multilib=false to remove this checking, however this is almost never the correct thing to do as something else is very likely to go wrong (often causing much more problems). 错误：保护多库版本：libgcc-4.8.5-36.el7.i686 != libgcc-4.8.5-28.el7.x86_64 此时哪个出现 ‘保护多版本库’ 升级哪个 yum update libstdc++-4.8.5-28.el7.x86_64 全部解决后即可安装 mysql 参考：https://blog.csdn.net/Wuhaotian1996/article/details/80689009 https://blog.csdn.net/qq_40208605/article/details/80679020 点击详情：安装mysql异常 [root@localhost mysql]# rpm -ivh MySQL-server-5.6.22-1.el6.i686.rpm准备中… ################################# [100%] file /usr/share/mysql/charsets/README from install of MySQL-server-5.6.22-1.el6.i686 conflicts with file from package mariadb-libs-1:5.5.56-2.el7.x86_64 file /usr/share/mysql/czech/errmsg.sys from install of MySQL-server-5.6.22-1.el6.i686 conflicts with file from package mariadb-libs-1:5.5.56-2.el7.x86_64 file /usr/share/mysql/danish/errmsg.sys from install of MySQL-server-5.6.22-1.el6.i686 conflicts with file from package mariadb-libs-1:5.5.56-2.el7.x86_64 file /usr/share/mysql/dutch/errmsg.sys from install of MySQL-server-5.6.22-1.el6.i686 conflicts with file from package mariadb-libs-1:5.5.56-2.el7.x86_64 file /usr/share/mysql/english/errmsg.sys from install of MySQL-server-5.6.22-1.el6.i686 conflicts with file from package mariadb-libs-1:5.5.56-2.el7.x86_64 file /usr/share/mysql/estonian/errmsg.sys from install of MySQL-server-5.6.22-1.el6.i686 conflicts with file from package mariadb-libs-1:5.5.56-2.el7.x86_64 file /usr/share/mysql/french/errmsg.sys from install of MySQL-server-5.6.22-1.el6.i686 conflicts with file from package mariadb-libs-1:5.5.56-2.el7.x86_64 file /usr/share/mysql/german/errmsg.sys from install of MySQL-server-5.6.22-1.el6.i686 conflicts with file from package mariadb-libs-1:5.5.56-2.el7.x86_64 file /usr/share/mysql/greek/errmsg.sys from install of MySQL-server-5.6.22-1.el6.i686 conflicts with file from package mariadb-libs-1:5.5.56-2.el7.x86_64 file /usr/share/mysql/hungarian/errmsg.sys from install of MySQL-server-5.6.22-1.el6.i686 conflicts with file from package mariadb-libs-1:5.5.56-2.el7.x86_64 file /usr/share/mysql/italian/errmsg.sys from install of MySQL-server-5.6.22-1.el6.i686 conflicts with file from package mariadb-libs-1:5.5.56-2.el7.x86_64 file /usr/share/mysql/japanese/errmsg.sys from install of MySQL-server-5.6.22-1.el6.i686 conflicts with file from package mariadb-libs-1:5.5.56-2.el7.x86_64 file /usr/share/mysql/korean/errmsg.sys from install of MySQL-server-5.6.22-1.el6.i686 conflicts with file from package mariadb-libs-1:5.5.56-2.el7.x86_64 file /usr/share/mysql/norwegian-ny/errmsg.sys from install of MySQL-server-5.6.22-1.el6.i686 conflicts with file from package mariadb-libs-1:5.5.56-2.el7.x86_64 file /usr/share/mysql/norwegian/errmsg.sys from install of MySQL-server-5.6.22-1.el6.i686 conflicts with file from package mariadb-libs-1:5.5.56-2.el7.x86_64 file /usr/share/mysql/polish/errmsg.sys from install of MySQL-server-5.6.22-1.el6.i686 conflicts with file from package mariadb-libs-1:5.5.56-2.el7.x86_64 file /usr/share/mysql/portuguese/errmsg.sys from install of MySQL-server-5.6.22-1.el6.i686 conflicts with file from package mariadb-libs-1:5.5.56-2.el7.x86_64 file /usr/share/mysql/romanian/errmsg.sys from install of MySQL-server-5.6.22-1.el6.i686 conflicts with file from package mariadb-libs-1:5.5.56-2.el7.x86_64 file /usr/share/mysql/russian/errmsg.sys from install of MySQL-server-5.6.22-1.el6.i686 conflicts with file from package mariadb-libs-1:5.5.56-2.el7.x86_64 file /usr/share/mysql/serbian/errmsg.sys from install of MySQL-server-5.6.22-1.el6.i686 conflicts with file from package mariadb-libs-1:5.5.56-2.el7.x86_64 file /usr/share/mysql/slovak/errmsg.sys from install of MySQL-server-5.6.22-1.el6.i686 conflicts with file from package mariadb-libs-1:5.5.56-2.el7.x86_64 file /usr/share/mysql/spanish/errmsg.sys from install of MySQL-server-5.6.22-1.el6.i686 conflicts with file from package mariadb-libs-1:5.5.56-2.el7.x86_64 file /usr/share/mysql/swedish/errmsg.sys from install of MySQL-server-5.6.22-1.el6.i686 conflicts with file from package mariadb-libs-1:5.5.56-2.el7.x86_64 file /usr/share/mysql/ukrainian/errmsg.sys from install of MySQL-server-5.6.22-1.el6.i686 conflicts with file from package mariadb-libs-1:5.5.56-2.el7.x86_64 file /usr/share/mysql/charsets/Index.xml from install of MySQL-server-5.6.22-1.el6.i686 conflicts with file from package mariadb-libs-1:5.5.56-2.el7.x86_64 file /usr/share/mysql/charsets/armscii8.xml from install of MySQL-server-5.6.22-1.el6.i686 conflicts with file from package mariadb-libs-1:5.5.56-2.el7.x86_64 file /usr/share/mysql/charsets/ascii.xml from install of MySQL-server-5.6.22-1.el6.i686 conflicts with file from package mariadb-libs-1:5.5.56-2.el7.x86_64 file /usr/share/mysql/charsets/cp1250.xml from install of MySQL-server-5.6.22-1.el6.i686 conflicts with file from package mariadb-libs-1:5.5.56-2.el7.x86_64 file /usr/share/mysql/charsets/cp1251.xml from install of MySQL-server-5.6.22-1.el6.i686 conflicts with file from package mariadb-libs-1:5.5.56-2.el7.x86_64 file /usr/share/mysql/charsets/cp1256.xml from install of MySQL-server-5.6.22-1.el6.i686 conflicts with file from package mariadb-libs-1:5.5.56-2.el7.x86_64 file /usr/share/mysql/charsets/cp1257.xml from install of MySQL-server-5.6.22-1.el6.i686 conflicts with file from package mariadb-libs-1:5.5.56-2.el7.x86_64 file /usr/share/mysql/charsets/cp850.xml from install of MySQL-server-5.6.22-1.el6.i686 conflicts with file from package mariadb-libs-1:5.5.56-2.el7.x86_64 file /usr/share/mysql/charsets/cp852.xml from install of MySQL-server-5.6.22-1.el6.i686 conflicts with file from package mariadb-libs-1:5.5.56-2.el7.x86_64 file /usr/share/mysql/charsets/cp866.xml from install of MySQL-server-5.6.22-1.el6.i686 conflicts with file from package mariadb-libs-1:5.5.56-2.el7.x86_64 file /usr/share/mysql/charsets/dec8.xml from install of MySQL-server-5.6.22-1.el6.i686 conflicts with file from package mariadb-libs-1:5.5.56-2.el7.x86_64 file /usr/share/mysql/charsets/geostd8.xml from install of MySQL-server-5.6.22-1.el6.i686 conflicts with file from package mariadb-libs-1:5.5.56-2.el7.x86_64 file /usr/share/mysql/charsets/greek.xml from install of MySQL-server-5.6.22-1.el6.i686 conflicts with file from package mariadb-libs-1:5.5.56-2.el7.x86_64 file /usr/share/mysql/charsets/hebrew.xml from install of MySQL-server-5.6.22-1.el6.i686 conflicts with file from package mariadb-libs-1:5.5.56-2.el7.x86_64 file /usr/share/mysql/charsets/hp8.xml from install of MySQL-server-5.6.22-1.el6.i686 conflicts with file from package mariadb-libs-1:5.5.56-2.el7.x86_64 file /usr/share/mysql/charsets/keybcs2.xml from install of MySQL-server-5.6.22-1.el6.i686 conflicts with file from package mariadb-libs-1:5.5.56-2.el7.x86_64 file /usr/share/mysql/charsets/koi8r.xml from install of MySQL-server-5.6.22-1.el6.i686 conflicts with file from package mariadb-libs-1:5.5.56-2.el7.x86_64 file /usr/share/mysql/charsets/koi8u.xml from install of MySQL-server-5.6.22-1.el6.i686 conflicts with file from package mariadb-libs-1:5.5.56-2.el7.x86_64 file /usr/share/mysql/charsets/latin1.xml from install of MySQL-server-5.6.22-1.el6.i686 conflicts with file from package mariadb-libs-1:5.5.56-2.el7.x86_64 file /usr/share/mysql/charsets/latin2.xml from install of MySQL-server-5.6.22-1.el6.i686 conflicts with file from package mariadb-libs-1:5.5.56-2.el7.x86_64 file /usr/share/mysql/charsets/latin5.xml from install of MySQL-server-5.6.22-1.el6.i686 conflicts with file from package mariadb-libs-1:5.5.56-2.el7.x86_64 file /usr/share/mysql/charsets/latin7.xml from install of MySQL-server-5.6.22-1.el6.i686 conflicts with file from package mariadb-libs-1:5.5.56-2.el7.x86_64 file /usr/share/mysql/charsets/macce.xml from install of MySQL-server-5.6.22-1.el6.i686 conflicts with file from package mariadb-libs-1:5.5.56-2.el7.x86_64 file /usr/share/mysql/charsets/macroman.xml from install of MySQL-server-5.6.22-1.el6.i686 conflicts with file from package mariadb-libs-1:5.5.56-2.el7.x86_64 file /usr/share/mysql/charsets/swe7.xml from install of MySQL-server-5.6.22-1.el6.i686 conflicts with file from package mariadb-libs-1:5.5.56-2.el7.x86_64 经网上查找是起了冲突 ‘conflicts’ 看到“conflicts”，是产生冲突了，文件“/usr/share/mysql/charsets/*”需要MySQL-server-5.6.22-1.el6.i686 版本的，而系统已经存在mariadb-libs-1:5.5.56-2.el7.x86_64版本的 删除冲突文件 mariadb-libs-1:5.5.56-2* yum -y remove mariadb-libs-1:5.5.56-2* 然后就可以安装自己的 mysql 了 参考：https://blog.csdn.net/testcs_dn/article/details/39026213 tomcat 安装后，启动找不到安装的 jdk解决方法：将jdk 目录手动配置到 catalina.sh 文件下 配置jdk环境变量，打开/etc/profile配置文件，将下面配置拷贝进去 123456789#set java environment JAVA_HOME=/usr/local/jdk1.8.0_191 CLASSPATH=.:$JAVA_HOME/lib.tools.jar PATH=$JAVA_HOME/bin:$PATH export JAVA_HOME CLASSPATH PATH 重新加载 /etc/profile 配置文件 source /etc/profile 永久写入防火墙配置因为是 CentOS Linux 7 的内核，不能直接用 6 内核的方法 先删除 7.0 系统自带防火墙，，安装旧版 开放 xxx 端口 /sbin/iptables -I INPUT -p tcp –dport 80 -j ACCEPT 永久保存 service iptables save 或 /usr/libexec/iptables/iptables.init save 参考：https://www.cnblogs.com/zhangzhibin/p/6231870.html https://blog.csdn.net/guoyf123321/article/details/52416328 mysql 安装后没有密码文件重设 mysql 密码 解决方案如下： #service mysqld stop#mysqld_safe –user=mysql –skip-grant-tables –skip-networking &amp; #mysql -u root mysql mysql&gt; UPDATE user SET Password=PASSWORD(‘newpassword’) where USER=’root’;mysql&gt; FLUSH PRIVILEGES;mysql&gt; quit service mysqld restart # mysql -uroot -pEnter password: &lt;输入新设的密码newpassword&gt; mysql&gt; UPDATE user SET Password=PASSWORD(‘newpassword’) where USER=’root’; 这句中的 newpassword 指需要新设置的密码 参考：https://onekeyes.iteye.com/blog/2316794 Linux tomcat 部署 war 文件后无法访问 tomcat 只显示 tomcat 主页可能是 idea 的 tomcat 和 jdk 版本跟 Linux 下的不同，将 linux 的 tomcat 和 jdk 升级成 idea 一样。 idea 使用 Junit 自动生成测试类https://www.cnblogs.com/libingbin/p/6007203.html]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[黑马 Spring]]></title>
    <url>%2F2018%2F09%2F03%2FHMSpring%2F</url>
    <content type="text"><![CDATA[maven dependency 机制 idea 无法导入 jdbcjdbcDaosupport 解决 Project Structure－&gt;Facets 配置。添加spring配置文件的模块 参考： https://blog.csdn.net/tiantiandjava/article/details/41204607 Caused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name ‘accountService’ defined in class path resource [applicationContext.xml]: Initialization of bean failed; nested exception is org.springframework.beans.ConversionNotSupportedException: Failed to convert property value of type ‘com.mchange.v2.c3p0.ComboPooledDataSource’ to required type ‘cn.itcast.dao.AccountDao’ for property ‘ad’; nested exception is java.lang.IllegalStateException: Cannot convert value of type ‘com.mchange.v2.c3p0.ComboPooledDataSource’ to required type ‘cn.itcast.dao.AccountDao’ for property ‘ad’: no matching editors or conversion strategy found xml 配置中需要将 accountDao 注入到 accountService ， 将 dataSource（连接池） 注入到 accountDao Caused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name ‘transactionManager’ defined in class path resource [applicationContext.xml]: BeanPostProcessor before instantiation of bean failed; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name ‘org.springframework.aop.support.DefaultBeanFactoryPointcutAdvisor#0’: Cannot resolve reference to bean ‘txPc’ while setting bean property ‘pointcut’; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name ‘txPc’: Lookup method resolution failed; nested exception is java.lang.IllegalStateException: Failed to introspect Class [org.springframework.aop.aspectj.AspectJExpressionPointcut] from ClassLoader [sun.misc.Launcher$AppClassLoader@b4aac2] Caused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name ‘org.springframework.aop.support.DefaultBeanFactoryPointcutAdvisor#0’: Cannot resolve reference to bean ‘txPc’ while setting bean property ‘pointcut’; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name ‘txPc’: Lookup method resolution failed; nested exception is java.lang.IllegalStateException: Failed to introspect Class [org.springframework.aop.aspectj.AspectJExpressionPointcut] from ClassLoader [sun.misc.Launcher$AppClassLoader@b4aac2] Caused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name ‘txPc’: Lookup method resolution failed; nested exception is java.lang.IllegalStateException: Failed to introspect Class [org.springframework.aop.aspectj.AspectJExpressionPointcut] from ClassLoader [sun.misc.Launcher$AppClassLoader@b4aac2] 加粗语句表示缺少 jar 包 aspectjweaver.jar 下载导入此 jar 包即可]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
        <tag>idea</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[idea_create_web]]></title>
    <url>%2F2018%2F08%2F31%2Fidea-create-web%2F</url>
    <content type="text"><![CDATA[流程参考：https://www.cnblogs.com/xuange306/p/7012341.html 遇见的小问题：没有 javax.servlet.* 的 jar 包 在 Project Structure 中选择 libraries 点击左侧加号选择 java 添加 tomcat 文件夹下 lib 文件夹中的 servlet-api.jar 同时也可添加常用 jar 包 tomcat-api 与 jsp-api 可以使用 ctrl+shift+alt+s 打开 Project Structure 选择 Modules 点击右侧 + 号，选择 libraries ，选择 Project Libraries 下的 tomcat 添加即可 普通 jar 包添加可选方法：在 WEB-INF 下创建 lib 目录，把 jar 包复制到 lib 目录下，ctrl+shift+alt+s 打开 Project Structure 选择左侧 libraries ，点击左侧加号 选择 java，选择 创建的 lib 目录添加，选择左侧 Modules 栏，勾选 lib https://my.oschina.net/fdblog/blog/161305 创建Web项目后没有WEB-INF文件夹及web.xml 最简单的方法：idea 创建 web 项目时用 xml 2.5 或： shift+ctrl+alt+s进入Project Structure打开Project Structure，在facets中选中次级的web或者在Modules中选中web，在deployment Descriptors面板里，点击 +号选择web.xml以及版本号。然后在弹出的对话框中修改xml默认的目录，加上web就可以了 Q: IntelliJ IDEA Tomcal启动报错： org.apache.catalina.core.AprLifecycleListener.init The APR based Apache Tomcat Native library failed to load. The error reported was [C:\tomcat\bin\tcnative-1.dll: Can’t load AMD 64-bit .dll on a IA 32-bit platform] java.lang.UnsatisfiedLinkError: C:\tomcat\bin\tcnative-1.dll: Can’t load AMD 64-bit .dll on a IA 32-bit platform A: 主要是在64位的系统下安装的虚拟机是64位的，而WTK的sublime.dll不能在64位的平台下加载64位的虚拟机，只能加载32位的。由于WTK在安装的时候加载的64虚拟机的地址，它找到的是64位的虚拟机，所以它提示不能加载32位的虚拟机（在目录下没有32的虚拟机） 解决办法下载 the 32bit from http://www.apache.org/dist/tomcat/tomcat-connectors/native/找到最近的版本，我的是 tomcat-native-1.2.16-win32-bin.zip下载后解压，找到tomcat-native-1.2.16-win32-bin.zip\bin\tcnative-1.dll (不是64X文件夹中的)替换到tomcat根目录下tomcat\bin idea tomcat警告参考：http://blog.51cto.com/13765598/2120489 Q: intellj idea启动tomcat服务器后无法访问localhost:8080（白屏）A: 原因：没有将tomcat主页的工程部署到intellj idea的虚拟tomcat路径，可在Run/Debug Configurations中Deployment选项中点击右边的绿色加号，选择External Source，然后添加Tomcat安装目录tomcat/webapps/Root目录即可；参考资料：https://blog.csdn.net/qq_22708467/article/details/79070973 tips：在部署 tomcat 服务器时，点击右上角 edit configurations 选择Deployment 添加了 Artifact 后，右边的Application context中的 / 代表项目部署的虚拟路径（网址访问主页面路径）: 若 index.jsp 在 aaa/web 目录下，虚拟路径为 /则访问 index.jsp 地址为 localhost/8080 或 localhost/8080/index.jsp . 若虚拟路径设为 /aaa 则访问 index.jsp 的地址为 localhost/8080/aaa/index.jsp 或 localhost/8080/aaa-request.getContextPath(); 得到的值为虚拟路径]]></content>
      <categories>
        <category>idea</category>
      </categories>
      <tags>
        <tag>idea</tag>
        <tag>intelj</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单例设计模式]]></title>
    <url>%2F2018%2F08%2F20%2FSingleDemo%2F</url>
    <content type="text"><![CDATA[单例设计模式：解决一个类中只存在一个对象单例设计模式特性：保证对象在内存中的唯一性： 为了避免其他程序创建过多对象，先禁止其他程序创建该类对象 为了让其他类访问到该对象，在本类中自定义一个对象 方便其他对象对自定义对象的访问，可以对外提供一些访问方式 用代码的方式实现对象在内存中唯一性： 将构造函数私有化 在类中创建一个本类对象 提供一个方法可以获取到该对象 单例模式使用方式：按平时的描述方式描述事物，加上 单例模式 的 3 步方式即可 单例设计模式饿汉式 java 代码实现：1234567891011121314151617181920class Single&#123; private Single()&#123;&#125;; //内置成员变化需要私有化 private static Single s = new Single(); /** 方法被调用的方法只有两种：对象、类名 因为该对象被私有化了，无法外部创建该方法，所以用类名调用 类名调用需要设置静态方法 静态方法只能访问静态成员，所以成员也需要静态 */ private Single getInstance()&#123; return s; &#125;&#125;class SingleDemo&#123; public static void main(String [] args)&#123; Single ss = Single.getInstance(); &#125;&#125; 栈中加载 main 函数 和 ss 方法区中有了 Single 的空间、静态的 s 变量、getInstance() 方法 堆中有了一个 new Single() 地址假设为 0x0015 方法区的 s 变量指向了 堆中 new Single() 的地址 0x0015 return s Single ss = Single.getInstance(); 使得 ss 也指向 0x0015 普通方式创建多个对象：1234567891011121314151617181920212223242526272829303132333435363738394041424344class Single&#123; private int num; public void setNum(int num)&#123; this.num = num; &#125; public int getNum()&#123; return num; &#125; //不设置私有化，可外部创建该对象 Single()&#123;&#125;; //单例模式下设置私有化，不可外部创建该对象 //private Single()&#123;&#125;; private static Single s = new Single(); private Single getInstance()&#123; return s; &#125;&#125;class SingleDemo&#123; public static void main(String [] args)&#123; //创建 2 个 Single 对象 Single s1 = new Single(); Single s2 = new Single(); //设置值为 30 s1.setNum(30); /**输出值为默认值 0 创建了两个对象，修改其中一个值跟另一个无关 */ System.out.println(s2.getNum()); /* ss2 的值为 23，表明 ss1 与 ss2 是同一个对象 单例模式内存中一个一个对象在执行，该对象有 3 个引用： SingleDemo 的 ss1、ss2 和 Single 中的 s */ //Single ss1 = Single.getInstance(); //Single ss2 = Single.getInstance(); //ss1.setNum(15); //System.out.println(ss2); &#125;&#125; 单例设计模式 懒汉式 java 代码123456789101112131415161718192021222324252627282930/*先初始化对象：称为 饿汉式Single 类一进内存，就已经创建好了对象class Single&#123; private Single()&#123;&#125;; private static Single s = new Single(); private Single getInstance()&#123; return s; &#125; &#125;*///对象在方法被调用时才初始化，也叫作对象的延时加载 称为 懒汉式//Single 类进内存，对象还没有存在，只有调用 getInstance() 方法时，才建立对象class Single&#123; private Single()&#123;&#125;; private static Single s = null; private Single getInstance()&#123; if(s==null)&#123; s = new Single(); &#125; return s; &#125; &#125;class SingleDemo&#123; public static void main(String [] args)&#123; Single ss = Single.getInstance(); &#125;&#125; 饿汉式：Single 类 加载进内存时，方法区就有 s，堆中就有对象，对象的地址值赋给 s 懒汉式：Single 类 加载进内存时，方法区 s 为空，当调用 getInstance() 方法时，才在内存中建立建立对象，将堆内存中的地址赋给 s，替换空值 懒汉式防止多个用户创建多个对象1234567891011121314151617class Single&#123; private Single()&#123;&#125;; private static Single s = null; //锁加载判断内部，提升效率 private Single getInstance()&#123; if(s==null)&#123; //加锁，防止创建多个对象 synchronized(Single.class)&#123; if(s==null)&#123; s = new Single(); &#125; &#125; &#125; return s; &#125; &#125;]]></content>
      <categories>
        <category>Design Patterns</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>Singleton Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring4x_2]]></title>
    <url>%2F2018%2F08%2F14%2FSpring4x-2%2F</url>
    <content type="text"><![CDATA[Spring 名词参考POJO：POJO（Plain Ordinary Java Object）简单的Java对象，实际就是普通JavaBeans，是为了避免和EJB混淆所创造的简称 使用POJO名称是为了避免和EJB混淆起来, 而且简称比较直接. 其中有一些属性及其getter setter方法的类,没有业务逻辑，有时可以作为VO(value -object)或dto(Data Transform Object)来使用.当然,如果你有一个简单的运算属性也是可以的,但不允许有业务方法,也不能携带有connection之类的方法。 教程参考 idea 创建 log4j 文件 Q&amp;AQ1:application context not configured for this file A: application context not configured for this file于spring框架使用中的原因 Q2: cvc-complex-type.2.4.c: 通配符的匹配很全面, 但无法找到元素 ‘tx:Advisor’ 的声明。 A: 在 smart-context.xml 中加入 Spring 引用 Q3:1Caused by: java.sql.SQLException: Access denied for user &apos;root&apos;@&apos;localhost&apos; (using password: YES) A: smart-context.xml 配置 数据库的用户密码错误 Q4:c:if 与 c:url 标签无效 A: accepted First add this to the top of your “.jsp” file: 1&lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot; prefix=&quot;c&quot; %&gt; It will still give syntax error but you can fix that by adding “javax.servlet:jstl:1.2” (without quotes) as a module dependency. To do that, follow these steps: Click your project name and press “F4” to bring up the module settings dialog. Then go to the “dependencies” tab in the “modules” section. Click the green “+” icon –&gt; library –&gt; new library –&gt; From Maven. Search for javax.servlet:jstl:1.2 in the search bar and press OK and it will download and add the above mentioned library as a module. Now you should not have any kind of syntax error. c:if标签 Cannot resolve symbol]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springAutoAssembly]]></title>
    <url>%2F2018%2F08%2F10%2FspringAutoAssembly%2F</url>
    <content type="text"><![CDATA[通过 Java 代码装配 bean通常组件扫描和自动化装配实现 Spring 的自动化配置，但是有时候例如要将第三方库中的组件装配到你的应用中，这种情况下没办法在它的类上添加 @Component 和 @Autowired 注解，就不能使用自动化配置了。 需要进行显示装配方式：java/XML java(javaConfig) 是比较好的方案，它更强大、类型安全、对重构友好，它是 java 代码，但是 JavaConfig 是配置代码，不应该包含任何业务逻辑，会将其放在单独的包中与其他应用程序逻辑分离开。 创建配置类如果去掉 CDPlayerConfig 的 @ComponentScan 注解，再次运行 CDPlayerTest 的话，测试会失败，出现异常。测试期望被注入CDPlayer 和 CompactDisc，但是这些 bean 没有被创建，组件扫描不会发现它们。 123456789package com.soundsystem;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;@Configuration//@ComponentScanpublic class CDPlayerConfig &#123;&#125; 声明简单的 bean在 JavaConfig 中声明 bean ，编写一个创建所需类型的实例的方法，给这个方法添加 @Bean 注解。 声明 CompactDisc bean : 1234@Beanpublic CompactDisc sgtPeppers()&#123; return new SgtPeppers();&#125; @Bean 注解告诉 Spring 这个方法返回一个对象，该对象要注册为 Spring 应用上下文中的 bean ，方法体中包含了最终产生 bean 实例的逻辑。 默认情况下，bean 的 id 跟带有@bean注解的方法名一样，本例中为 sgtPeppers，如果要重新设置可以通过name属性指定： 1234@Bean(name="lonelyHeartsClubBand")public CompactDisc sgtPeppers()&#123; return new SgtPeppers();&#125; 方法体返回了一个新的 SgtPeppers 实例，因为是java代码所以可以使用java提供的全部功能，只要最终能生成CompactDisc实例就行。 可以用 java的功能在一组 CD 中随机选择一个 CompactDisc 播放： 12345678910111213@Beanpublic CompactDisc randomBeatlesCD()&#123; int choice = (int)Math.floor(Math.random()*4); if(choice==0)&#123; return new WhiteAlbum(); &#125;else if(choice==1)&#123; return new SgtPeppers(); &#125;else if(choice==2)&#123; return new HardDaysNight(); &#125;else if(choice==3)&#123; return enw Revolver(); &#125;&#125; Spring中Bean及@Bean的理解 java 是面相对象，对象有方法和属性，需要对象实例来调用方法和属性（实例化），有方法或属性的类都需要实例化才能具象化地去使用这些方法和属性。bean 是类的代理，这样它就能代表类拥有该拥有的东西了。 注解： 使用 bean: 即是把已经在xml文件中配置好的Bean拿来用，完成属性、方法的组装；比如@Autowired , @Resource，可以通过byTYPE（@Autowired）、byNAME（@Resource）的方式获取Bean； 注册Bean: @Component , @Repository , @ Controller , @Service , @Configration这些注解都是把你要实例化的对象转化成一个Bean，放在IoC容器中，等你要用的时候，它会和上面的@Autowired , @Resource配合到一起，把对象、属性、方法完美组装。 @bean: 意思是@Bean明确地指示了一种方法，什么方法呢——产生一个bean的方法，并且交给Spring容器管理；从这我们就明白了为啥@Bean是放在方法的注释上了，因为它很明确地告诉被注释的方法，你给我产生一个Bean，然后交给Spring容器，剩下的你就别管了 Spring 注入： IOC 容器加载时会扫描 xml 文件中 bean 的配置，对这些 bean 进行实例化（初始化）。注入指在初始化一个实例的时候对这个实例的成员变量进行赋值。 借助 JavaConfig 实现注入当需要声明一个依赖于 CompactDisc 的 CDPlayer bean 时，可用如下方法在 JavaConfig 中进行装配： 引用创建 bean 的方法： 1234@Beanpublic CDPlayer cdPlayer()&#123; return new CDPlayer(sgtPeppers());&#125; 创建的 bean ID 为 cdPlayer，与方法名相同。cdPlayer() 方法没有使用默认的构造器构建实例，而是调用了需要传入 CompactDisc 对象的构造器来创建 CDPlayer 实例，但是它并不是通过调用 sgtPeppers() 方法得到的，sgtPeppers() 方法上添加了 @Bean 注解，所以 Spring 将会拦截所有对它的条用，会直接返回该方法所创建的 bean cdPlayer() 方法请求一个 CompactDisc 作为参数 1234@Beanpublic CDPlayer cdPlayer(CompactDisc compactDisc)&#123; return new CDPlayer(compactdisc);&#125; 不管 CompactDisc 使用什么方式创建出来的，Spring 都会将其传入到配置方法中，并用来创建 CDPlayer bean。以上构造器和下面的 Setter 方法只是 @Bean 的其中一些方法： 123456@Beanpublic CDPlayer cdPlayer(CompactDisc compactDisc)&#123; CDPlayer cdPlayer = new CDPlayer(compactDisc); cdPlayer.setCompactDisc(compactDisc) return cdPlayer;&#125; 声明一个简单的 属性注入（设值注入） 元素类似于 JavaConfig 的 @Bean 注解。 1234&lt;bean id="cdPlayer" class="soundsystem.CDPlayer"&gt; &lt;constructor-arg name="compactDisc" ref="compactDisc" /&gt;&lt;/bean&gt; 1234&lt;bean id="cdPlayer" class="soundsystem.CDPlayer"&gt; &lt;property name="compactDisc" ref="compactDisc" /&gt;&lt;/bean&gt; id 为 cdPlayer 的 CDPlayer 类，其中有一个名称为 compactDisc 的成员变量。 元素为属性的 Setter 方法所提供的功能与 元素为构造器所提供的功能相同。 通过 ref 属性，引用了 ID 为 compactDisc 的 bean，用 setCompactDisc() 方法将其注入到 compactDisc 属性中。所以 CDPlayer 中必须有 setCompactDisc() 的方法，由 IOC 容器自动调用方法进行赋值。]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>autoAssembly</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring 框架基础]]></title>
    <url>%2F2018%2F08%2F02%2Fspring%2F</url>
    <content type="text"><![CDATA[Spring 框架基础控制反转（Inversion of Control，缩写为IoC），是面向对象编程中的一种设计原则，可以用来减低计算机代码之间的耦合度。其中最常见的方式叫做依赖注入（Dependency Injection，简称DI），还有一种方式叫“依赖查找”（Dependency Lookup）。通过控制反转，对象在被创建的时候，由一个调控系统内所有对象的外界实体，将其所依赖的对象的引用传递给它。也可以说，依赖被注入到对象中。 IOC 是一种设计模式，原来创建对象的主动权和时间是由自己控制的，现在把需要使用的对象的创建，销毁的控制权交给别人（IOC容器），使用时直接获取，这种对象可以单例或多例。IOC 有利于降低耦合度。 依赖注入和控制反转的理解 AOP为Aspect Oriented Programming的缩写，意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。 idea 的简单 Spring 文件创建及测试 创建一个 project 勾选 Spring 及 web Application 创建 interface、实现接口类、配置类以及测试类 idea 创建测试类方法： 在 bean 同目录下创建一个 test 测试文件夹，同时按住 ctrl+shift+alt+s 调出 project structure 窗口，选择modules 栏中的 Sources 栏，选中创建 test 文件夹，在 Mark as 栏选择 Tests，将 Tests 文件夹作为 Test 文件创建的目录。 在 实现接口类的类名上 alt+enter 选择 create test，在 TestLibrary 选择 JUnit4， 如果出现 JUnit4 Library notfound in the module ，点击 fix 选择 Use ‘JUnit4’ from idea distribution 点 ok，在下方 Member 栏将方法选中，可创建该类方法的测试方法 在测试类文件中类的上方添加注释 @RunWith(SpringJUnit4ClassRunner.class) 以便在测试开始的时候自动创建 Spring 的应用上下文 添加注解 @ContextConfiguration(classes=CDPlayerConfig.class) 表示需要在 CDPlayerConfig 中加载配置，因为 CDPlayerConfig 类中包含了 @ComponentScan ，则最终引用上下文也会包含 CompactiDisc 的bean 在类中添加 注释 表示将 bean 注入到测试代码之中 12@Autowiredprivate CompactDisc cd; 一个简单的测试方法，断言测试 cd 属性不为 null ，表示 spring 能够发现 CompactDisc 类，能自动在 Spring 上下文中创建 bean 并将其注入到测试代码中 1234@Testpublic void cdShouldNotBeNull()&#123; assertNotNull(cd);&#125; 如果运行测试类报错 org.junit 不存在 导入com.springsource.org.junit-4.7.0.jar 包 如果不行则继续下面操作： ctrl + shift + alt + s 进入 project structure 窗口 ，在 Library 窗口 点击左边绿色的加号 -&gt; Java -&gt; 找到 IDEA 安装路径下的 Lib 中的junit-4.12 -&gt; 确定 ctrl + shift + t 在 测试 文件与 被测试 文件间切换 在类名上 alt + enter，选择 Create test，第一栏选择 Juint4 ，如果有提示 Juint 4 library not found in the module，点击右边的 fix ，选择默认的 Use ‘Juint4’ from Intellj IDEA distribution ，ok，下面选择需要创建的Before 或 After 测试方法，以及需要创建的自己的方法。 如果需要更换 test 测试类的文件存放位置，可以在 Project Structure（ctrl+alt+shift+s）中选择 module 中的 source ，选择一个文件夹作为 test 文件的存放位置。 idea 使用 Junit4 测试教程（需科学上网） idea 打开显示 Spring Configure check 解决方法 ​ 打开 Project Structure－&gt;Facets 配置。左侧 + 号，选择 Spring (添加 spring 配置文件的模块) ​ 右侧 + 号，勾选项目，会选中项目及其下的 xml 文件 (设置添加没有被映射的Spring配置文件)，点击应用即可 为组件扫描的 bean 命名Spring 应用上下文所有的 bean 一般都会根据类名指定一个 ID，将类名的第一个字母变为小写（SgtPeppers 设置为 sgtPeppers），如果要自己设置不同的 ID，则在 SgtPeppers 类注解 @Component 中配置 ID 名，如 1234@Component("lonelyHeartsClub")public class SgtPeppers implements CompactDisc&#123; ...&#125; 或者使用 @Named 注解也可以，但是通常使用 @Component 1234@Named("lonelyHeartsClub")public class SgtPeppers implements CompactDisc&#123; ...&#125; 设置组件扫描基础包如果没有为 @ComponentScan 设置任何属性，它会以配置类所在的包作为基础包（base package）来扫描组件（扫描）。如果想将装配类放在单独的包中跟其他的应用代码进行区分，那么默认基础包将不能满足要求。 为了指定不同的基础包，可以在 @ComponentScan 的 value 属性中指明包的名称： 1234@Configuration@ComponentScan("soundsystem)public class CDPlayerConfig &#123;&#125; 如果为了更清楚地表明设置的是基础包，可以通过 basePackages 属性进行配置： 1234@Configuration@ComponentScan(basePackages="soundsystem")public class CDPlayerConfig &#123;&#125; 若要设置多个基础包，可以将 basePackages 属性设置为需要扫描包的数组即可： 1234@Configuration@ComponentScan(basePackages="soundsystem","video")public class CDPlayerConfig &#123;&#125; 以上用 String 类型表示的基础包设置是类型不安全的(not type-safe)，如果重构代码的话，所指定的基础包可能会出错。 此时应用 @ComponentScan 指定包中所包含的类或接口,为 basePackageClasses 属性所设置的数组中包含了类，这些类所在的的包会作为组件扫描的基础包。 1234@Configuration@ComponentScan(basePackageClasses=(CDPlayer.class,DVDPlayer.class))public class CDPlayerConfig &#123;&#125; 为 bean 添加注解实现自动装配 CDPlayer 类中，给构造器添加 @Autowired 注解，表明当 Spring 创建 CDPlayer bean 时，会通过这个构造器来进行实例化，并且传入一个可设置给 CompactDisc 类型的 bean。 12345package com.soundsystem;public interface MediaPlayer &#123; void play();&#125; 1234567891011121314151617package com.soundsystem;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Component;@Componentpublic class CDPlayer implements MediaPlayer &#123; private CompactDisc cd; @Autowired public CDPlayer(CompactDisc cd)&#123; this.cd = cd; &#125; public void play()&#123; cd.play(); &#125;&#125; 该注解可用在构造器，也可用在属性的 Setter 方法上，CDPlayer 有一个 setCompactDisc() 方法，可以采用如下的注解装配： 1234@Autowired public void setCompactDisc(CompactDisc cd)&#123; this.cd = cd; &#125; 在 Spring 初始化 bean 后，它会尽可能满足 bean 的依赖，本例中的依赖是通过带有 @Autowired 注解声明的，@Autowired 能在构造器、Setter 方法，或者其他方法上发挥同样的作用，Spring 都会去满足方法参数上所声明的依赖。 如果有且只有一个 bean 匹配依赖需求的话，那么这个 bean 会被装配进来。但没有匹配 bean 的情况下，在应用上下文创建的时候，Spring 会抛出一个异常，为了避免异常出现可以将 @Autowired 的 required 属性设置为 false，同时代码中需进行 null 检查。 如果有多个 bean 满足依赖关系 Spring 会抛出一个异常。 Autowired 是 Spring 特有注解，可以选择 @Inject 注解（源自 Java 依赖注入规范）代替。 验证自动装配 System Rules 库 Java 单元测试如何断言(检查)控制台输出 注入 CompactDisc ，注入 CDPlayer bean 到测试代码的 player 成员变量之中（为更通用的 MediaPlayer 类型），在 play 测试方法中，可以调用 CDPlayer 的 player() 方法，断言其行为与你的预期一致 123456789101112131415161718192021222324252627282930313233343536package com.soundsystem;import static org.junit.Assert.*;import org.junit.Rule;import org.junit.Test;import org.junit.contrib.java.lang.system.StandardOutputStreamLog;import org.junit.contrib.java.lang.system.SystemOutRule;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import static org.junit.Assert.*;@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(classes=CDPlayerConfig.class)public class CDPlayerTest &#123; @Rule public final SystemOutRule log = new SystemOutRule(); @Autowired private MediaPlayer player; @Autowired private CompactDisc cd; @Test void cdShouldNotBeNull()&#123; assertNotNull(cd); &#125; @Test public void play() &#123; player.play(); assertEquals( "playing Sgt. Pepper's Lonely Hearts Club Band" + "by The Beatles\n", log.getLog(); ); &#125;&#125;]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
        <tag>IOC</tag>
        <tag>依赖</tag>
        <tag>注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis_Reply 微信自动回复]]></title>
    <url>%2F2018%2F07%2F30%2FMyBatis-Reply%2F</url>
    <content type="text"><![CDATA[实现输入关键字微信自动回复的功能添加一对多关系配置创建 command 与关联数据库 12create table command(id int primary key , name varchar(16) , description varchar(16));create table command_content (id int primary key , content varchar(2048) , command_id int, foreign key(command_id) references command(id) on delete cascade on update cascade); 查询主表的实体，将查询 sql 语句放在主表对应的 xml 文件中，将查询出的数据填充到主表对应的属性中，同时填充子表的列表 left join COMMAND_CONTENT 关联附表 COMMAND a COMMAND_CONTENT b 给表取别名，主表为 a ；附表为 b a.ID C_ID 给 a 表 ID 取别名为 C_ID 1select a.ID C_ID,a.NAME,a.DESCRIPTION,b.Id,b.CONTENT,b.COMMAND_ID from COMMAND a left join COMMAND_CONTENT b on a.ID=b.COMMAND_ID mybatis 取属性名时，用的是 ResultSet 的 getMetaData().getColumnName(column); 方法 不会取到 a.ID 的 a 前缀 如果创建了不存在的 主表 id 对应 command_id 则无法再创建新的 column 空语句可以产生提示，有了内容就无法发送 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253HTTP Status 500 – Internal Server ErrorType Exception ReportDescription The server encountered an unexpected condition that prevented it from fulfilling the request.Exceptionorg.apache.ibatis.exceptions.PersistenceException: ### Error querying database. Cause: java.lang.IllegalArgumentException: Result Maps collection does not contain value for CommandContent.Content### The error may exist in com/imooc/config/sqlxml/Command.xml### The error may involve Command.queryCommandList### The error occurred while handling results### SQL: select a.ID C_ID,a.NAME,a.DESCRIPTION,b.Id,b.CONTENT,b.COMMAND_ID from COMMAND a left join COMMAND_CONTENT b on a.ID=b.COMMAND_ID### Cause: java.lang.IllegalArgumentException: Result Maps collection does not contain value for CommandContent.Content org.apache.ibatis.exceptions.ExceptionFactory.wrapException(ExceptionFactory.java:30) org.apache.ibatis.session.defaults.DefaultSqlSession.selectList(DefaultSqlSession.java:150) org.apache.ibatis.session.defaults.DefaultSqlSession.selectList(DefaultSqlSession.java:141) com.imooc.dao.CommandDao.queryCommandList(CommandDao.java:34) com.imooc.service.QueryService.queryByCommand(QueryService.java:53) com.imooc.servlet.AutoReplyServlet.doGet(AutoReplyServlet.java:18) javax.servlet.http.HttpServlet.service(HttpServlet.java:635) javax.servlet.http.HttpServlet.service(HttpServlet.java:742) org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52)Root Causejava.lang.IllegalArgumentException: Result Maps collection does not contain value for CommandContent.Content org.apache.ibatis.session.Configuration$StrictMap.get(Configuration.java:888) org.apache.ibatis.session.Configuration.getResultMap(Configuration.java:640) org.apache.ibatis.executor.resultset.DefaultResultSetHandler.getNestedResultMap(DefaultResultSetHandler.java:1011) org.apache.ibatis.executor.resultset.DefaultResultSetHandler.applyNestedResultMappings(DefaultResultSetHandler.java:945) org.apache.ibatis.executor.resultset.DefaultResultSetHandler.getRowValue(DefaultResultSetHandler.java:918) org.apache.ibatis.executor.resultset.DefaultResultSetHandler.handleRowValuesForNestedResultMap(DefaultResultSetHandler.java:881) org.apache.ibatis.executor.resultset.DefaultResultSetHandler.handleRowValues(DefaultResultSetHandler.java:328) org.apache.ibatis.executor.resultset.DefaultResultSetHandler.handleResultSet(DefaultResultSetHandler.java:303) org.apache.ibatis.executor.resultset.DefaultResultSetHandler.handleResultSets(DefaultResultSetHandler.java:196) org.apache.ibatis.executor.statement.PreparedStatementHandler.query(PreparedStatementHandler.java:64) org.apache.ibatis.executor.statement.RoutingStatementHandler.query(RoutingStatementHandler.java:79) org.apache.ibatis.executor.SimpleExecutor.doQuery(SimpleExecutor.java:63) org.apache.ibatis.executor.BaseExecutor.queryFromDatabase(BaseExecutor.java:326) org.apache.ibatis.executor.BaseExecutor.query(BaseExecutor.java:156) org.apache.ibatis.executor.CachingExecutor.query(CachingExecutor.java:109) org.apache.ibatis.executor.CachingExecutor.query(CachingExecutor.java:83) org.apache.ibatis.session.defaults.DefaultSqlSession.selectList(DefaultSqlSession.java:148) org.apache.ibatis.session.defaults.DefaultSqlSession.selectList(DefaultSqlSession.java:141) com.imooc.dao.CommandDao.queryCommandList(CommandDao.java:34) com.imooc.service.QueryService.queryByCommand(QueryService.java:53) com.imooc.servlet.AutoReplyServlet.doGet(AutoReplyServlet.java:18) javax.servlet.http.HttpServlet.service(HttpServlet.java:635) javax.servlet.http.HttpServlet.service(HttpServlet.java:742) org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52)Note The full stack trace of the root cause is available in the server logs.Apache Tomcat/8.5.29 原因：在 Command.xml 中的 collention 属性的 ResultMap 引用 CommandContent.xml 下的 id ,引用名错误 方法：(CommandContent.ResultMap).id=”Content” (Command.Collection)ResultMap=”CommandContent.Content” 如果没有在 Configuration.xml 文件中引入 CommandContent.xml 与 Command.xml 也会产生该错误 mybatis 一对多关系的配置数据库子表内含“段子”关键词的多个内容，对应主表的“段子”的 id 。每次用户发送”段子“时，取出其中的所有内容，拼接进查询服务 QueryService 中创建的 (List)contentList 集合中，再创建随机数返回其中一条内容 12345678910111213&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;!--类似于 java package 的用法，用来区分不同项目,namespace 必须添加--&gt;&lt;!--作为子表包含具体多个内容对应主表的一个 id 然后被主表所引用--&gt;&lt;mapper namespace="CommandContent"&gt; &lt;resultMap type="com.imooc.bean.CommandContent" id="Content"&gt; &lt;id column="ID" jdbcType="INTEGER" property="id"/&gt; &lt;result column="CONTENT" jdbcType="VARCHAR" property="content"/&gt; &lt;result column="COMMAND_ID" jdbcType="VARCHAR" property="commandId"/&gt; &lt;/resultMap&gt;&lt;/mapper&gt; 1234567891011121314151617181920212223242526272829303132&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;!--类似于 java package 的用法，用来区分不同项目,namespace 必须添加--&gt;&lt;mapper namespace="Command"&gt;&lt;!--要反应一个一对多关系，需要用到在主表中引用子表列表的集合,引用CommandContent.xml 中的 Content 属性--&gt; &lt;resultMap type="com.imooc.bean.Command" id="Command"&gt; &lt;id column="C_ID" jdbcType="INTEGER" property="id"/&gt; &lt;result column="NAME" jdbcType="VARCHAR" property="name"/&gt; &lt;result column="DESCRIPTION" jdbcType="VARCHAR" property="description"/&gt; &lt;collection property="contentList" resultMap="CommandContent.Content"/&gt; &lt;/resultMap&gt; &lt;!--查询主表同时关联子表--&gt; &lt;select id="queryCommandList" parameterType="com.imooc.bean.Command" resultMap="Command"&gt; select a.ID C_ID,a.NAME,a.DESCRIPTION,b.Id,b.CONTENT,b.COMMAND_ID from COMMAND a left join COMMAND_CONTENT b on a.ID=b.COMMAND_ID &lt;!--where 关键字指，在其中的 if 语句都不满足条件则不输出 where 关键字，反之，有一个 if 满足则输出 where + if 中语句--&gt; &lt;!--where 还能将 if 拼接的 sql 语句最前端的 and 去掉，防止语句不准确--&gt; &lt;where&gt; &lt;if test="name != null &amp;amp;&amp;amp; !&amp;quot;&amp;quot;.equals(name.trim()) "&gt; and a.NAME=#&#123;name&#125; &lt;/if&gt; &lt;if test="description != null and !&amp;quot;&amp;quot;.equals(description.trim()) "&gt; and a.DESCRIPTION like '%' #&#123;description&#125; '%' &lt;/if&gt; &lt;/where&gt; &lt;/select&gt;&lt;/mapper&gt; 以上两个 xml 要引入到 Configuration.xml 中 将原来的单条信息查询改为一对多的数据查询1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package com.imooc.service;import com.imooc.bean.Command;import com.imooc.bean.CommandContent;import com.imooc.bean.Message;import com.imooc.dao.CommandDao;import com.imooc.dao.MessageDao;import com.imooc.util.Iconst;import java.util.List;import java.util.Random;public class QueryService &#123; //调用 MessageDao 进行数据操作，再由 ListServlet 调用。将值返回给 ListServlet public List&lt;Message&gt; queryMessageList(String command, String description)&#123; MessageDao messageDao = new MessageDao(); return messageDao.queryMessageList(command,description); &#125; /** * 通过指令查询自动回复内容 */ public String queryByCommand(String command)&#123;// MessageDao messageDao = new MessageDao(); CommandDao commandDao = new CommandDao();// List&lt;Message&gt; messageList; List&lt;Command&gt; commandList; if(Iconst.HELP_COMMAND.equals(command))&#123;// 如果指令是帮助，则将所有指令查出来并拼接；// messageList = messageDao.queryMessageList(null, null); commandList = commandDao.queryCommandList(null, null); StringBuilder result = new StringBuilder();// for(int i= 0;i &lt; messageList.size();i++)&#123; for(int i= 0;i &lt; commandList.size();i++)&#123; //如果不是第一行则添加换行 if(i !=0)&#123; result.append("&lt;br/&gt;"); &#125;// 拼接所有查询出来的指令及描述// result.append("回复[" + messageList.get(i).getCommand() + "]可以查看"// + messageList.get(i).getDescription()); result.append("回复[" + commandList.get(i).getName() + "]可以查看" + commandList.get(i).getDescription()); &#125; return result.toString(); &#125; //只需要通过指令，不需要描述来查询自动回复,如果为 null 则不进入 if 判断语句，不会添加 and sql 语句// messageList = messageDao.queryMessageList(command, null);// if(messageList.size() &gt; 0)&#123;// return messageList.get(0).getContent();// &#125; commandList = commandDao.queryCommandList(command, null); if(commandList.size() &gt; 0)&#123; //取得第一条查询语句的 子表集合内容/列表信息 List&lt;CommandContent&gt; contentList = commandList.get(0).getContentList(); //取得列表信息其中一条返回 //取 [0,size()) 的随机数 int i = new Random().nextInt(contentList.size());// 取得随机的 commandContent 的对象，然后从对象中取得内容 return contentList.get(i).getContent(); &#125; //当指令没有匹配的回复内容时，用此内容替代 return Iconst.NO_MATCHING_CONTENT; &#125;&#125; 自动回复 servlet 将跳转功能转换为 写查询返回语句的功能 123456789101112131415161718192021222324252627package com.imooc.servlet;import com.imooc.service.QueryService;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;public class AutoReplyServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; resp.setContentType("text/html;charset=utf-8"); PrintWriter out = resp.getWriter(); QueryService queryService = new QueryService(); out.write(queryService.queryByCommand(req.getParameter("content"))); out.flush(); out.close(); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; this.doGet(req,resp); &#125;&#125; 常用标签 where 标签 where标签 在其中的 if 语句都不满足条件则不输出 where 关键字，反之，有一个 if 满足则输出 where + if 中语句where 还能将 if 拼接的 sql 语句最前端的 and 去掉，防止语句不准确 123456select ID,COMMAND,DESCRIPTION,CONTENT from MESSAGE where 1=1 &lt;if test="command != null &amp;amp;&amp;amp; !&amp;quot;&amp;quot;.equals(command.trim()) "&gt; and COMMAND=#&#123;command&#125; &lt;/if&gt; &lt;if test="description != null and !&amp;quot;&amp;quot;.equals(description.trim()) "&gt; and DESCRIPTION like '%' #&#123;description&#125; '%' &lt;/if&gt; 去掉 where 1=1 ，但是加上 where 标签即可 1234567select ID,COMMAND,DESCRIPTION,CONTENT from MESSAGE&lt;where&gt; &lt;if test="command != null &amp;amp;&amp;amp; !&amp;quot;&amp;quot;.equals(command.trim()) "&gt; and COMMAND=#&#123;command&#125; &lt;/if&gt; &lt;if test="description != null and !&amp;quot;&amp;quot;.equals(description.trim()) "&gt; and DESCRIPTION like '%' #&#123;description&#125; '%' &lt;/if&gt;&lt;/where&gt; include 引用标签 1select ID,COMMAND,DESCRIPTION,CONTENT from MESSAGE 语句能用以下语法代替 12select &lt;include refid="columns"/&gt; from MESSAGE&lt;sql id="columns"&gt;ID,COMMAND,DESCRIPTION,CONTENT&lt;/sql&gt; set 标签 修改升级数据库的功能 1update MESSAGE set COMMAND=#&#123;command&#125;,DESCRIPTION=#&#123;description&#125; update 标签 为了使 sql 语句结尾的 ‘,’ 不多余加入了 set 标签，效果跟 where 去 and 类似，能去掉语句最后多余的 ‘,’ 123456789101112&lt;update id=""&gt; &lt;set&gt; update MESSAGE set &lt;if test="command != null &amp;amp;&amp;amp; !&amp;quot;&amp;quot;.equals(command.trim()) "&gt; COMMAND=#&#123;command&#125;, &lt;/if&gt; &lt;if test="description != null and !&amp;quot;&amp;quot;.equals(description.trim()) "&gt; and DESCRIPTION=#&#123;description&#125;, &lt;/if&gt; COMMAND=#&#123;command&#125;,DESCRIPTION=#&#123;description&#125; &lt;/set&gt;&lt;/update&gt; trim标签 trim 标签中的 prefix 属性，表示前缀，可以等于 where/set…（可自定义）如果各种判断结束有字符串输出就加入 where/set… trim 标签中的 suffix 属性，表示后面，可以加 test 或自定义 ，如果 if 中有内容输出就在最后加一个 test trim 标签的 prefixOverride 属性，表示删除前面内容，例如 prefixOverride=”and/or” 如果在前面出现了and 与 or 则切掉，同理 suffixOverride=”,” 可以去除结尾的 ‘,’ 12345当 prefix 值为 where 且能去掉首部的 and/or，该 trim 能替换 where 标签&lt;trim prefix="where" prefixOverride="and/or"&gt;&lt;/trim&gt;同理当 prefix 值为 set 且去掉尾部的 ','，该 trim 能替换 set 标签&lt;trim prefix="set" suffixOverride=","&gt;&lt;/trim&gt; choose 标签 chosse when 相当于 java 中的 else if，又或者是 switch case choose otherwise 相当于 else，或者是 default 123456789101112131415161718select ID,COMMAND,DESCRIPTION,CONTENT from MESSAGE&lt;where&gt; &lt;if test="command != null &amp;amp;&amp;amp; !&amp;quot;&amp;quot;.equals(command.trim()) "&gt; and COMMAND=#&#123;command&#125; &lt;/if&gt; &lt;if test="description != null and !&amp;quot;&amp;quot;.equals(description.trim()) "&gt; and DESCRIPTION like '%' #&#123;description&#125; '%' &lt;/if&gt; &lt;choose&gt; &lt;when test=""&gt; &lt;/when&gt; &lt;when test=""&gt; &lt;/when&gt; &lt;when test=""&gt; &lt;/when&gt; &lt;when test=""&gt; &lt;/when&gt; &lt;otherwise&gt;&lt;/otherwise&gt; &lt;/choose&gt;&lt;/where&gt; association 标签 需要根据子表内容查询相关联的主表内容，association 与 collection 标签相似 。 property 为 bean 中主表实体的引用，resultMap 指向主表的 nameSpace.(resultMap 的 id) 1&lt;association property="command" resultMap="Command.Command"/&gt; 标签总结 定义 sql 语句 insert，delete，update，select 配置 java 对象属性与查询结果集中列名的对应关系（列名不是数据库表中的列名，而是查询结果集的列名） resultMap 动态拼接 sql 语句 foreach，if，choose 格式化输出（动态拼接 sql 语句不符合 sql 语法，对该语法进行格式化） where，set，trim 配置关联关系（一对多，多对一） collention，association 常量标签（可在需要地方引用他） sql 引用标签（引用常量标签） include resultMap 使用标签配置对应关系，结果集列名与 java 类属性名可以不相同，有 typeHandler 可以配置字符集 resultType 不需要进行配置，但是结果集中的列名与 java 类中的属性名相同 parameterType 与 ognl 表达式相关联 #{} parameterMap 与 resultMap 相似，需要指向 ParameterMap 标签配置的映射关系的 id 。表示参数中的属性与数据库列的对应关系。 以 Map 结尾表示映射，需要配置映射关系 Type 结尾表示类型，resultType 与 parameterType 原名 resultClass 与 parameterClass，与 java 类类似 #{} 被 mybatis 解析为 ？，然后被 preparedStatement 赋值为 ‘段子’，有预编译效果，一半采用该方法 ${} 直接被 mybatis 拼接 字符串 （String）段子，没有引号，需要自己添加单引号 ‘${command}’ ${} 一般用于取直接从页面上传过来的列名进行操作 常见错误 sql 语法错误：使用 log4j 查看拼接后的 sql 语句，将其复制到 nativeMysql 中，将值赋给 ？的占位符，进行 sql 语句的判断 注解型 sql 比 配置型 sql 方便，但是有局限性 编码问题 ：文件本身编码、jsp 设置编码、servlet 接受页面传值，用来转换的编码、用 get 方式提交中文时，tomcat 也要配置编码 网页乱码 : 在talk.jsp上方加上 12&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt;&lt;%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c" %&gt; 若以上全部配置好，而与数据库交互出现乱码，则在 Configuration.xml 写连接数据库的 url 时，就需要加上编码方式、建立数据库与建表时的编码也需要注意获取自增主键值： useGeneratedKeys : 表示插入到这张表时采用生成的主键,而不是自己指定一个主键，Command 这个类的其他属性值来自于页面，而 id 是自增的，所以页面中没有 id 值 keyProperty : mybatis 会取到新增数据的主键，keyProperty 用来告诉 mybatis 将主键存到 Command 对象的哪一个属性中，这里的主键应该是 id. 在 Command 对象传入 xml 时，id 是没有值的，在 sqlSession 调用配置中 sql 语句执行完后，id 就有值了 在talk.jsp上方加上 12&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt;&lt;%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c" %&gt; 123&lt;insert id="insert" userGeneratedKeys="ture" property="id" parameterType="com.imooc.bran.Command"&gt; insert into COMMAND(NAME,DESCRIPTION) value(#&#123;name&#125;,#&#123;description&#125;)&lt;/insert&gt; 向 js 文件中传地址： 添加一个隐藏块，通过 id 与 value 向 js 中传入 basePath 的值 idea rename 一个类： 在一个类上右键 refactor → rename → 修改类名 → 取消 Search in Comments and strings (在评论和字符串中搜索) 跟 Search for textoccurrences (搜索文本事件) → 选择 variable name 点击 ok 即可 如果不取消 2 个勾选，rename 会无效。 选择 variable name 会使得子类重命名在调用该类对象的对象名]]></content>
      <categories>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>MyBatis</tag>
        <tag>autoReply</tag>
        <tag>weChat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jdbcToMyBatis]]></title>
    <url>%2F2018%2F07%2F25%2FjdbcToMyBatis%2F</url>
    <content type="text"><![CDATA[css 设置不显示问题： 将 resources 放入了 WEB-INF 文件夹中（这文件夹中的内容只能根据内部跳转或重定向等网页操作才能访问，不能直接访问） request.getContextPath() 获取的是上下文路径。是你的web项目的根路径，就是 webContent (MyEclipse中是webRoot) 或者 idea 中的 web 路径 拼装当前网页相对路径 url-pattern 配置 此文为 jdbc 版，如已了解直接转至 mybatis版 第一版大体框架 123456789101112131415161718192021222324package com.imooc.servlet;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;/** * 列表页面初始化控制 */@WebServlet(name="ListServlet" ,urlPatterns = "/List.action")public class ListServlet extends HttpServlet&#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; req.getRequestDispatcher("/WEB-INF/jsp/back/list.jsp").forward(req,resp); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; this.doGet(req, resp); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;&lt;%--拼接当前网页相对路径--%&gt;&lt;% String path = request.getContextPath(); String basePath = request.getScheme()+"://"+request.getServerName()+":"+request.getServerPort()+path;%&gt;&lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /&gt;&lt;meta http-equiv="X-UA-Compatible"content="IE=9; IE=8; IE=7; IE=EDGE" /&gt;&lt;title&gt;内容列表页面&lt;/title&gt;&lt;%--css 文件的相对路径--%&gt;&lt;link href="resources/css/all.css" rel="stylesheet" type="text/css" /&gt;&lt;/head&gt;&lt;body style="background: #e1e9eb;"&gt; &lt;form action="" id="mainForm" method="post"&gt; &lt;div class="right"&gt; &lt;div class="current"&gt;当前位置：&lt;br/&gt; &lt;a href="javascript:void(0)" style="color:#6E6E6E;"&gt; 内容管理 &lt;/a&gt; &amp;gt; 内容列表 &lt;/div&gt; &lt;div class="rightCont"&gt; &lt;p class="g_title fix"&gt;内容列表 &lt;a class="btn03" href="#"&gt;新 增&lt;/a&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;a class="btn03" href="#"&gt;删 除&lt;/a&gt; &lt;/p&gt; &lt;table class="tab1"&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td width="90" align="right"&gt;演示字段1：&lt;/td&gt; &lt;td&gt; &lt;input type="text" class="allInput" value=""/&gt; &lt;/td&gt; &lt;td width="90" align="right"&gt;演示字段2：&lt;/td&gt; &lt;td&gt; &lt;input type="text" class="allInput" value=""/&gt; &lt;/td&gt; &lt;td width="85" align="right"&gt; &lt;input type="submit" class="tabSub" value="查 询" /&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;div class="zixun fix"&gt; &lt;table class="tab2" width="100%"&gt; &lt;tbody&gt; &lt;tr&gt; &lt;th&gt;&lt;input type="checkbox" id="all" onclick="#"/&gt;&lt;/th&gt; &lt;th&gt;序号&lt;/th&gt; &lt;th&gt;演示字段1&lt;/th&gt; &lt;th&gt;演示字段2&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;input type="checkbox" /&gt;&lt;/td&gt; &lt;td&gt;1&lt;/td&gt; &lt;td&gt;演示值1&lt;/td&gt; &lt;td&gt;演示值2&lt;/td&gt; &lt;td&gt; &lt;a href="#"&gt;修改&lt;/a&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;a href="#"&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr style="background-color:#ECF6EE;"&gt; &lt;td&gt;&lt;input type="checkbox" /&gt;&lt;/td&gt; &lt;td&gt;2&lt;/td&gt; &lt;td&gt;演示值1&lt;/td&gt; &lt;td&gt;演示值2&lt;/td&gt; &lt;td&gt; &lt;a href="#"&gt;修改&lt;/a&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;a href="#"&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;input type="checkbox" /&gt;&lt;/td&gt; &lt;td&gt;3&lt;/td&gt; &lt;td&gt;演示值1&lt;/td&gt; &lt;td&gt;演示值2&lt;/td&gt; &lt;td&gt; &lt;a href="#"&gt;修改&lt;/a&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;a href="#"&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr style="background-color:#ECF6EE;"&gt; &lt;td&gt;&lt;input type="checkbox" /&gt;&lt;/td&gt; &lt;td&gt;4&lt;/td&gt; &lt;td&gt;演示值1&lt;/td&gt; &lt;td&gt;演示值2&lt;/td&gt; &lt;td&gt; &lt;a href="#"&gt;修改&lt;/a&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;a href="#"&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;div class='page fix'&gt; 共 &lt;b&gt;4&lt;/b&gt; 条 &lt;a href='###' class='first'&gt;首页&lt;/a&gt; &lt;a href='###' class='pre'&gt;上一页&lt;/a&gt; 当前第&lt;span&gt;1/1&lt;/span&gt;页 &lt;a href='###' class='next'&gt;下一页&lt;/a&gt; &lt;a href='###' class='last'&gt;末页&lt;/a&gt; 跳至&amp;nbsp;&lt;input type='text' value='1' class='allInput w28' /&gt;&amp;nbsp;页&amp;nbsp; &lt;a href='###' class='go'&gt;GO&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011121314151617181920212223&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd" version="3.1"&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt;/*此处可用 servlet 中的注释代替*/ &lt;!--&lt;servlet&gt;--&gt; &lt;!--&lt;servlet-name&gt;ListServlet&lt;/servlet-name&gt;--&gt; &lt;!--&lt;servlet-class&gt;com.imooc.servlet.ListServlet&lt;/servlet-class&gt;--&gt; &lt;!--&lt;/servlet&gt;--&gt; &lt;!--&lt;servlet-mapping&gt;--&gt; &lt;!--&lt;servlet-name&gt;ListServlet&lt;/servlet-name&gt;--&gt; &lt;!--访问 http://localhost:8080/List.action 后跳转到 list.jsp 页面--&gt; &lt;!--&lt;url-pattern&gt;/List.action&lt;/url-pattern&gt;--&gt; &lt;!--&lt;/servlet-mapping&gt;--&gt;&lt;/web-app&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package com.imooc.bean;public class Message &#123; /** * 主键 */ private String id; /** * 指令名称 */ private String command; /** * 描述 */ private String description; /** * 内容 */ private String content; public String getId() &#123; return id; &#125; public void setId(String id) &#123; this.id = id; &#125; public String getCommand() &#123; return command; &#125; public void setCommand(String command) &#123; this.command = command; &#125; public String getDescription() &#123; return description; &#125; public void setDescription(String description) &#123; this.description = description; &#125; public String getContent() &#123; return content; &#125; public void setContent(String content) &#123; this.content = content; &#125;&#125; 第一版完善 完善 list.jsp 及 ListSerlvet.java 的相关部分 sql 语句 1234567891011//sql preparedstatement 语句// ? 占位符// 用缺省值的方式，使用 List 在后面遍历填充字段信息比较方便stringsql = "select * from people p where p.id = ? and p.name = ?";preparedstatement ps = connection.preparestatement(sql);//设置缺省值的值//index 的值从 1 开始ps.setint(1,id);ps.setstring(2,name);//执行 sql 语句resultset rs = ps.executequery(); list.jsp 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;&lt;%--使用 jstl--%&gt;&lt;%@taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %&gt;&lt;%--拼接当前网页相对路径--%&gt;&lt;% String path = request.getContextPath(); String basePath = request.getScheme()+"://"+request.getServerName()+":"+request.getServerPort()+path;%&gt;&lt;html xmlns="http://www.w3.org/1999/xhtml"&gt; &lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /&gt; &lt;meta http-equiv="X-UA-Compatible"content="IE=9; IE=8; IE=7; IE=EDGE" /&gt; &lt;title&gt;内容列表页面&lt;/title&gt; &lt;%--css 文件的相对路径--%&gt; &lt;link href="&lt;%=basePath%&gt;/resources/css/all.css" rel="stylesheet" type="text/css" /&gt; &lt;/head&gt; &lt;body style="background: #e1e9eb;"&gt; &lt;%--提交到 ListServlet 上进行初始化与查询--%&gt; &lt;form action="&lt;%=basePath%&gt;/List.action" id="mainForm" method="post"&gt; &lt;div class="right"&gt; &lt;div class="current"&gt;当前位置：&lt;a href="javascript:void(0)" style="color:#6E6E6E;"&gt;内容管理&lt;/a&gt; &amp;gt; 内容列表&lt;/div&gt; &lt;div class="rightCont"&gt; &lt;p class="g_title fix"&gt;内容列表 &lt;a class="btn03" href="#"&gt;新 增&lt;/a&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;a class="btn03" href="#"&gt;删 除&lt;/a&gt;&lt;/p&gt; &lt;table class="tab1"&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td width="90" align="right"&gt;指令名称：&lt;/td&gt; &lt;td&gt; &lt;input name="command" type="text" class="allInput" value="$&#123;command&#125;"/&gt; &lt;/td&gt; &lt;td width="90" align="right"&gt;描述：&lt;/td&gt; &lt;td&gt; &lt;input name="description" type="text" class="allInput" value="$&#123;description&#125;"/&gt; &lt;/td&gt; &lt;td width="85" align="right"&gt;&lt;input type="submit" class="tabSub" value="查 询" /&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;div class="zixun fix"&gt; &lt;table class="tab2" width="100%"&gt; &lt;tbody&gt; &lt;tr&gt; &lt;th&gt;&lt;input type="checkbox" id="all" onclick="#"/&gt;&lt;/th&gt; &lt;th&gt;序号&lt;/th&gt; &lt;th&gt;演示字段1&lt;/th&gt; &lt;th&gt;演示字段2&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;c:forEach items="$&#123;messageList&#125;" var="message" varStatus="status"&gt; &lt;tr &lt;c:if test="$&#123;status.index % 2 != 0&#125;"&gt;style='background-color:#ECF6EE;'&lt;/c:if&gt;&gt; &lt;td&gt;&lt;input type="checkbox" /&gt;&lt;/td&gt; &lt;td&gt;$&#123;status.index + 1&#125;&lt;/td&gt; &lt;td&gt;$&#123;message.command&#125;&lt;/td&gt; &lt;td&gt;$&#123;message.description&#125;&lt;/td&gt; &lt;td&gt; &lt;a href="#"&gt;修改&lt;/a&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;a href="#"&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;div class='page fix'&gt; 共 &lt;b&gt;4&lt;/b&gt; 条 &lt;a href='###' class='first'&gt;首页&lt;/a&gt; &lt;a href='###' class='pre'&gt;上一页&lt;/a&gt; 当前第&lt;span&gt;1/1&lt;/span&gt;页 &lt;a href='###' class='next'&gt;下一页&lt;/a&gt; &lt;a href='###' class='last'&gt;末页&lt;/a&gt; 跳至&amp;nbsp;&lt;input type='text' value='1' class='allInput w28' /&gt;&amp;nbsp;页&amp;nbsp; &lt;a href='###' class='go'&gt;GO&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; ListServlet 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081package com.imooc.servlet;import com.imooc.bean.Message;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.sql.*;import java.util.ArrayList;import java.util.List;/** * 列表页面初始化控制 */@WebServlet(name="ListServlet" ,urlPatterns = "/List.action")public class ListServlet extends HttpServlet&#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; try &#123; //得到表单文本框提交的数据 req.setCharacterEncoding("utf-8"); String command = req.getParameter("command"); String description = req.getParameter("description"); //将查询完的值保留在查询栏中 req.setAttribute("command",command); req.setAttribute("description",description); Class.forName("com.mysql.jdbc.Driver"); Connection conn = DriverManager.getConnection("jdbc:mysql://127.0.0.1:3306/micro_message", "root","dfwhj43815"); StringBuilder sql = new StringBuilder("select ID,COMMAND,DESCRIPTION,CONTENT from MESSAGE where 1=1"); //创建一个 List 将需要拼接的 sql 语句查询内容装进去，最后用 for 循环取出，set 到 PreparedStatement 后执行 List&lt;String&gt; paramList = new ArrayList&lt;String&gt;(); //.trim() 方法返回一个 String 的副本，用来去除首尾的空格 if(command != null &amp;&amp; !"".equals(command.trim()))&#123; //查询sql语句拼接不用sql.append(" and command = '"+command+"'") 因为容易被SQL注入攻击 sql.append(" and COMMAND=?"); paramList.add(command); &#125; if(description != null &amp;&amp; !"".equals(description.trim()))&#123; sql.append(" and DESCRIPTION like '%' ? '%'"); paramList.add(description); &#125; PreparedStatement ps = conn.prepareStatement(sql.toString()); //在 sql 语句执行前，将参数加进去 for (int i = 0; i &lt; paramList.size(); i++) &#123; ps.setString(i + 1,paramList.get(i)); &#125; ResultSet rs = ps.executeQuery(); List&lt;Message&gt;messageList = new ArrayList&lt;Message&gt;(); while(rs.next())&#123; Message message = new Message(); //添加到容器中的不是对象本身，此时操作对象仍可以改变在容器中的内容。 //也可以将对象在最后添加到容器 message.setId(rs.getString("ID")); message.setCommand(rs.getString("COMMAND")); message.setDescription(rs.getString("DESCRIPTION")); message.setContent(rs.getString("CONTENT")); messageList.add(message); &#125; //将容器添加到 request 的 attribute 可以在页面上显示出来 req.setAttribute("messageList",messageList); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; req.getRequestDispatcher("/WEB-INF/jsp/back/list.jsp").forward(req,resp); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; this.doGet(req, resp); &#125;&#125; idea 引入 c 标签 网页有框架没有数据，提示找不到 jdbc，没有正确导入 Driver 包； You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ‘message’ at line 1 ​ at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method) at sun.reflect.NativeConstructorAccessorImpl.newInstance(Unknown Source) at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(Unknown Source) at java.lang.reflect.Constructor.newInstance(Unknown Source) Sql 语句有语法错误：from 写成了 form 第一版代码重构 将原来 servlet 的功能分出去 servlet 的功能 设置编码 接受页面的值 向页面传值 dao 层的功能 根据查询条件查询消息列表，跟表 Message 相关的所有操作都在这层 service 层的功能 调用 MessageDao 进行数据操作，再由 ListServlet 调用。将值返回给 ListServlet ListSerlvet 123456789101112131415161718192021222324252627282930313233343536373839404142package com.imooc.servlet;import com.imooc.bean.Message;import com.imooc.service.ListService;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.sql.*;import java.util.ArrayList;import java.util.List;/** * 列表页面初始化控制 */@WebServlet(name="ListServlet" ,urlPatterns = "/List.action")public class ListServlet extends HttpServlet&#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //设置编码 req.setCharacterEncoding("utf-8"); //接受页面的值 String command = req.getParameter("command"); String description = req.getParameter("description"); //向页面传值 req.setAttribute("command",command); req.setAttribute("description",description); //查询消息列表并传给页面。调用 ListService 的函数，将查询的结果放到 req 中 ListService listService = new ListService(); req.setAttribute("messageList",listService.queryMessageList(command,description)); //向页面跳转 req.getRequestDispatcher("/WEB-INF/jsp/back/list.jsp").forward(req,resp); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; this.doGet(req, resp); &#125;&#125; MessageDao 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package com.imooc.dao;import com.imooc.bean.Message;import java.sql.*;import java.util.ArrayList;import java.util.List;//Dao 层跟表相关，此 dao 包含跟 message 表相关的操作public class MessageDao &#123; /** * 根据查询条件查询消息列表 */ public List&lt;Message&gt; queryMessageList(String command,String description)&#123; List&lt;Message&gt;messageList = new ArrayList&lt;Message&gt;(); try &#123; Class.forName("com.mysql.jdbc.Driver"); Connection conn = DriverManager.getConnection("jdbc:mysql://127.0.0.1:3306/micro_message", "root","dfwhj43815"); StringBuilder sql = new StringBuilder("select ID,COMMAND,DESCRIPTION,CONTENT from MESSAGE where 1=1"); //创建一个 List 将需要拼接的 sql 语句查询内容装进去，最后用 for 循环取出，set 到 PreparedStatement 后执行 List&lt;String&gt; paramList = new ArrayList&lt;String&gt;(); //.trim() 方法返回一个 String 的副本，用来去除首尾的空格 if(command != null &amp;&amp; !"".equals(command.trim()))&#123; //查询sql语句拼接不用sql.append(" and command = '"+command+"'") 因为容易被SQL注入攻击 sql.append(" and COMMAND=?"); paramList.add(command); &#125; if(description != null &amp;&amp; !"".equals(description.trim()))&#123; sql.append(" and DESCRIPTION like '%' ? '%'"); paramList.add(description); &#125; PreparedStatement ps = conn.prepareStatement(sql.toString()); //在 sql 语句执行前，将参数加进去 for (int i = 0; i &lt; paramList.size(); i++) &#123; ps.setString(i + 1,paramList.get(i)); &#125; ResultSet rs = ps.executeQuery(); while(rs.next())&#123; Message message = new Message(); //添加到容器中的不是对象本身，此时操作对象仍可以改变在容器中的内容。 //也可以将对象在最后添加到容器 message.setId(rs.getString("ID")); message.setCommand(rs.getString("COMMAND")); message.setDescription(rs.getString("DESCRIPTION")); message.setContent(rs.getString("CONTENT")); messageList.add(message); &#125; &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return messageList; &#125;&#125; ListService 1234567891011121314package com.imooc.service;import com.imooc.bean.Message;import com.imooc.dao.MessageDao;import java.util.List;public class ListService &#123; //调用 MessageDao 进行数据操作，再由 ListServlet 调用。将值返回给 ListServlet public List&lt;Message&gt; queryMessageList(String command, String description)&#123; MessageDao messageDao = new MessageDao(); return messageDao.queryMessageList(command,description); &#125;&#125;]]></content>
      <categories>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>jdbc</tag>
        <tag>myBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis]]></title>
    <url>%2F2018%2F07%2F23%2FMyBatis%2F</url>
    <content type="text"><![CDATA[用 mybatis 替代 jdbcmybatis 下载地址 jdbc 版跳转此处 dao 层、mybatis 及 SqlSession 作用dao (data access objection 数据访问对象)层需求 ： 能与数据库交互 能执行 sql 语句 mybatis ：向 dao 层提供对象 SqlSession SqlSession 作用： 向 sql 语句传入参数 执行 sql 语句 获取执行 sql 语句的结果 事务的控制 如何得到 SqlSession： 通过配置文件获取数据库连接的相关信息 通过配置信息构建 SqlSessionFactory 通过 SqlSessionFactory 打开 数据库会话（SqlSession） 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package com.imooc.bean;public class Message &#123; /** * 主键 */ private String id; /** * 指令名称 */ private String command; /** * 描述 */ private String description; /** * 内容 */ private String content; public String getId() &#123; return id; &#125; public void setId(String id) &#123; this.id = id; &#125; public String getCommand() &#123; return command; &#125; public void setCommand(String command) &#123; this.command = command; &#125; public String getDescription() &#123; return description; &#125; public void setDescription(String description) &#123; this.description = description; &#125; public String getContent() &#123; return content; &#125; public void setContent(String content) &#123; this.content = content; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!-- Copyright 2009-2016 the original author or authors. Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.--&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;!--类似于 java package 的用法，用来区分不同项目,namespace 必须添加--&gt;&lt;mapper namespace="Message"&gt; &lt;!--对应 jdbc 的 message.setId(rs.getString("ID")); 等方法--&gt; &lt;!--type 表示的是数据库字段对应 java 中哪个类的对象；id 随意取名；--&gt; &lt;!--如果在数据库中为主键，则配 id colum,否则配 result colum 标签；--&gt; &lt;!--colum 对应数据库列的属性名；property 是数据库对应 java bean对象中的属性名--&gt; &lt;!--jdbcType 对应数据库中属性的类型 Int、varchar 等--&gt; &lt;resultMap type="com.imooc.bean.Message" id="MessageResult"&gt; &lt;id column="ID" jdbcType="INTEGER" property="id"/&gt; &lt;result column="COMMAND" jdbcType="VARCHAR" property="command"/&gt; &lt;result column="DESCRIPTION" jdbcType="VARCHAR" property="description"/&gt; &lt;result column="CONTENT" jdbcType="VARCHAR" property="content"/&gt; &lt;/resultMap&gt; &lt;!--select id 必须是唯一的，但与 resultMap 中的 id 可以重名--&gt; &lt;!--parameterType 是传入 sqlSession 的参数的属性--&gt; &lt;!--resultMap 指向 resultMap 标签的 id--&gt; &lt;!--OGNL 表达式 如果是自定义类型就直接写自定义属性的属性名（command）--&gt; &lt;!--可以从 java 对象中调用属性值 而且可以直接调用 java 对象的方法--&gt; &lt;!--但是 与符号 &amp;&amp; 需要转义成 &amp;amp;&amp;amp 或者用 OGNl 的 and 操作符--&gt; &lt;!--双引号 "" 需要转义成 &amp;quot;&amp;quot;--&gt; &lt;!--占位符 ? 需要用 #&#123;command&#125; 来替换，表示用 command 值来填充 ? 这是 mybatis 的解析规则--&gt; &lt;!--mybatis 配置中 sql 语句前后不需要留空格，会自动拼接--&gt; &lt;!--模糊查询 like 跟 '%' 保留，问号 ? 替换，问号两边依旧保留空格 --&gt; &lt;select id="queryMessageList" parameterType="com.imooc.bean.Message" resultMap="MessageResult"&gt; select ID,COMMAND,DESCRIPTION,CONTENT from MESSAGE where 1=1 &lt;if test="command != null &amp;amp;&amp;amp; !&amp;quot;&amp;quot;.equals(command.trim()) "&gt; and COMMAND=#&#123;command&#125; &lt;/if&gt; &lt;if test="description != null and !&amp;quot;&amp;quot;.equals(description.trim()) "&gt; and DESCRIPTION like '%' #&#123;description&#125; '%' &lt;/if&gt; &lt;/select&gt; &lt;!--单个删除--&gt; &lt;!--#&#123;&#125; 中的取值写法可以视为与 OGNL 相同：当参数为 String 与基本数据类型时，标签属性为 _parameter, 若为自定义类型则写自定义类型属性名--&gt; &lt;delete id="deleteOne" parameterType="int"&gt; delete from MESSAGE where ID = #&#123;_parameter&#125; &lt;/delete&gt; &lt;!--批量删除--&gt; &lt;delete id="deleteBatch" parameterType="java.util.List"&gt; delete from MESSAGE where ID in ( &lt;foreach collection="list" item="item" separator=","&gt; #&#123;item&#125; &lt;/foreach&gt; ) &lt;/delete&gt;&lt;/mapper&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!-- Copyright 2009-2016 the original author or authors. Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.--&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;!-- &lt;settings&gt; &lt;setting name="useGeneratedKeys" value="false"/&gt; &lt;setting name="useColumnLabel" value="true"/&gt; &lt;/settings&gt; &lt;typeAliases&gt; &lt;typeAlias alias="UserAlias" type="org.apache.ibatis.submitted.complex_property.User"/&gt; &lt;/typeAliases&gt; --&gt; &lt;environments default="development"&gt; &lt;environment id="development"&gt; &lt;transactionManager type="JDBC"&gt; &lt;property name="" value=""/&gt; &lt;/transactionManager&gt; &lt;dataSource type="UNPOOLED"&gt; &lt;property name="driver" value="com.mysql.jdbc.Driver"/&gt; &lt;property name="url" value="jdbc:mysql://127.0.0.1:3306/micro_message"/&gt; &lt;property name="username" value="root"/&gt; &lt;property name="password" value="dfwhj43815"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!--用来引入 sqlxml 配置文件的内容--&gt; &lt;mappers&gt; &lt;!--mapper 可以多个--&gt; &lt;mapper resource="com/imooc/config/sqlxml/Message.xml"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110package com.imooc.dao;import com.imooc.bean.Message;import com.imooc.db.DBAccess;import org.apache.ibatis.session.SqlSession;import java.io.IOException;import java.sql.*;import java.util.ArrayList;import java.util.List;//Dao 层跟表相关，此 dao 包含跟 message 表相关的操作public class MessageDao &#123; /** * mybytis 根据查询条件查询消息列表 */ public List&lt;Message&gt; queryMessageList(String command,String description)&#123; DBAccess dbAccess = new DBAccess(); //要在 final 中关闭此会话，所以放在外面 SqlSession sqlSession = null; //创建 List 将查询语句内容放进 List 中 List&lt;Message&gt;messageList = new ArrayList&lt;Message&gt;(); //捕获 DBAccess 抛出的异常 try &#123; sqlSession = dbAccess.getSqlSession(); //新建一个对象，将 command description 对象封装到对象中 Message message = new Message(); message.setCommand(command); message.setDescription(description); //通过 sqlSession 执行 查找sql 语句；值为 namespace.resultMap messageList = sqlSession.selectList("Message.queryMessageList",message); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally&#123; if(sqlSession!=null)&#123; sqlSession.close(); &#125; &#125; return messageList; &#125; /** * * 单条删除 */ public void deleteOne(int id)&#123; DBAccess dbAccess = new DBAccess(); //要在 final 中关闭此会话，所以放在外面 SqlSession sqlSession = null; //捕获 DBAccess 抛出的异常 try &#123; sqlSession = dbAccess.getSqlSession(); //通过 sqlSession 执行 删除sql 语句；值为 Message.mapper 的 namespace.resultMap sqlSession.delete("Message.deleteOne",id); //使用 mybatis 时对 commit 进行了封装，需要手动进行提交 /** * Connection conn; * 下面两条sql语句是自动提交互不影响的 * 但是将 conn.setAutoCommit(false) 设定后，下面的 sql 语句将处于一个事物中 * 需要进行 conn.commit(); 或 conn.roolback(); 才能一次性手动提交 * conn.prepareStatement("sql").execute(); * conn.prepareStetement("sql").execute(); * conn.commit(); * * * 如下的 sqlSession.commit()；实际上就是 conn.commmit(); */ sqlSession.commit(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally&#123; if(sqlSession!=null)&#123; sqlSession.close(); &#125; &#125; &#125; /** * 批量删除 */ public void deleteBatch(List&lt;Integer&gt; ids)&#123; DBAccess dbaccess = new DBAccess(); SqlSession sqlsession = null; try &#123; sqlsession = dbaccess.getSqlSession(); //执行删除语句 sqlsession.delete("Message.deleteBatch",ids); sqlsession.commit(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; // public static void main(String[] args) &#123;// MessageDao messageDao = new MessageDao();// messageDao.queryMessageList("","");//// &#125;&#125; 123456789101112131415161718192021222324package com.imooc.db;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import java.io.IOException;import java.io.Reader;/** * 访问数据库类 */public class DBAccess &#123; public SqlSession getSqlSession() throws IOException &#123; //通过配置文件获取数据库连接信息 Reader reader = Resources.getResourceAsReader("com/imooc/config/Configuration.xml"); //通过配置信息构建一个 SqlSessionFactory SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(reader); //通过 sqlSessionFactory 打开一个数据库会话 SqlSession sqlSession = sqlSessionFactory.openSession(); return sqlSession; &#125;&#125; 1234567891011121314package com.imooc.service;import com.imooc.bean.Message;import com.imooc.dao.MessageDao;import java.util.List;public class ListService &#123; //调用 MessageDao 进行数据操作，再由 ListServlet 调用。将值返回给 ListServlet public List&lt;Message&gt; queryMessageList(String command, String description)&#123; MessageDao messageDao = new MessageDao(); return messageDao.queryMessageList(command,description); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.imooc.service;import com.imooc.dao.MessageDao;import java.util.ArrayList;import java.util.List;/** * 维护 Service * 维护相关业务的功能 * 页面的一个动作对应了一个 Servlet ；而 Service 不应该同时增加 * 把相似的功能（修改，新增，删除，批量删除等）放在一个维护 Service 中 * 以后可以一直添加新功能 * * 将取值的转型及判断是否为空 都放在 Service 中进行 */public class MaintainService &#123; /** * 单条删除 */ public void deleteOne(String id)&#123; //判断 id 是否为空，或 空字符串 if(id != null &amp;&amp; !"".equals(id.trim())) &#123; MessageDao messageDao = new MessageDao(); //将 id 从 String 转型为 int 并作为参数传入 deleteOne 函数 messageDao.deleteOne(Integer.valueOf(id)); &#125; &#125; /** * 批量删除 */ public void deleteBatch(String [] ids)&#123; MessageDao messageDao = new MessageDao(); //创建 id 的 List List&lt;Integer&gt; idList = new ArrayList&lt;Integer&gt;(); for (String id : ids) &#123; //转型为 Integer 再传入 List if(id!=null &amp;&amp; !"".equals(id.trim())) &#123; idList.add(Integer.valueOf(id)); &#125; &#125; //调用 messageDao 的 deleteBatch 方法 messageDao.deleteBatch(idList); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142package com.imooc.servlet;import com.imooc.bean.Message;import com.imooc.service.ListService;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.sql.*;import java.util.ArrayList;import java.util.List;/** * 列表页面初始化控制 */@WebServlet(name="ListServlet" ,urlPatterns = "/List.action")public class ListServlet extends HttpServlet&#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //设置编码 req.setCharacterEncoding("utf-8"); //接受页面的值 String command = req.getParameter("command"); String description = req.getParameter("description"); //向页面传值 req.setAttribute("command",command); req.setAttribute("description",description); //查询消息列表并传给页面。调用 ListService 的函数，将查询的结果放到 req 中 ListService listService = new ListService(); req.setAttribute("messageList",listService.queryMessageList(command,description)); //向页面跳转 req.getRequestDispatcher("/WEB-INF/jsp/back/list.jsp").forward(req,resp); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; this.doGet(req, resp); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435package com.imooc.servlet;import com.imooc.service.ListService;import com.imooc.service.MaintainService;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;/** * 单条删除控制层 */public class DeleteOneServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //设置编码 req.setCharacterEncoding("utf-8"); //接受页面的值 String id = req.getParameter("id"); MaintainService maintainService = new MaintainService(); //需要接受的参数为 int 但是判断接受的值是否为空以及转型应该在 Service 中进行 maintainService.deleteOne(id); //向页面跳转 直接跳转到 list.jsp 会使得列表全部消失；列表初始化需要 listServlet 进行一些操作 //所以应该先跳到 listServlet// req.getRequestDispatcher("/WEB-INF/jsp/back/list.jsp").forward(req,resp); req.getRequestDispatcher("/List.action").forward(req,resp); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; this.doGet(req, resp); &#125;&#125; 1234567891011121314151617181920212223242526272829package com.imooc.servlet;import com.imooc.service.MaintainService;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;/** * 批量删除控制层 */public class DeleteBatchServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; req.setCharacterEncoding("utf-8"); MaintainService maintainService = new MaintainService(); String[] ids = req.getParameterValues("id"); maintainService.deleteBatch(ids); //页面跳转 req.getRequestDispatcher("/List.action").forward(req,resp); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; this.doGet(req,resp); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;&lt;%--使用 jstl--%&gt;&lt;%@taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %&gt;&lt;%--拼接当前网页相对路径--%&gt;&lt;% String path = request.getContextPath(); String basePath = request.getScheme()+"://"+request.getServerName()+":"+request.getServerPort()+path;%&gt;&lt;html xmlns="http://www.w3.org/1999/xhtml"&gt; &lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /&gt; &lt;meta http-equiv="X-UA-Compatible"content="IE=9; IE=8; IE=7; IE=EDGE" /&gt; &lt;title&gt;内容列表页面&lt;/title&gt; &lt;link href="&lt;%=basePath%&gt;/resources/css/all.css" rel="stylesheet" type="text/css" /&gt; &lt;script src="&lt;%=basePath %&gt;/resources/js/common/jquery-1.8.0.min.js"&gt;&lt;/script&gt; &lt;script src="&lt;%=basePath %&gt;/resources/js/back/list.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; function deleteOne(path,id)&#123; if(confirm("确定要删除吗？"))&#123; document.getElementById("id").value=id; document.getElementById("mainForm").action = path+"/DeleteOneServlet.action"; document.getElementById("mainForm").submit(); &#125; &#125; &lt;/script&gt; &lt;/head&gt; &lt;body style="background: #e1e9eb;"&gt; &lt;%--提交到 ListServlet 上进行初始化与查询--%&gt; &lt;form action="&lt;%=basePath%&gt;/List.action" id="mainForm" method="post" &gt; &lt;div class="right"&gt; &lt;div class="current"&gt;当前位置：&lt;a href="javascript:void(0)" style="color:#6E6E6E;"&gt;内容管理&lt;/a&gt; &amp;gt; 内容列表&lt;/div&gt; &lt;div class="rightCont"&gt; &lt;p class="g_title fix"&gt; 内容列表 &lt;a class="btn03" href="#"&gt; 新 增 &lt;/a&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;a class="btn03" href="javascript:deleteBatch('&lt;%=basePath%&gt;');"&gt; 删 除 &lt;/a&gt; &lt;/p&gt; &lt;table class="tab1"&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td width="90" align="right"&gt;指令名称：&lt;/td&gt; &lt;td&gt; &lt;input name="command" type="text" class="allInput" value="$&#123;command&#125;"/&gt; &lt;/td&gt; &lt;td width="90" align="right"&gt;描述：&lt;/td&gt; &lt;td&gt; &lt;input name="description" type="text" class="allInput" value="$&#123;description&#125;"/&gt; &lt;/td&gt; &lt;td width="85" align="right"&gt;&lt;input type="submit" class="tabSub" value="查 询" /&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;div class="zixun fix"&gt; &lt;table class="tab2" width="100%"&gt; &lt;tbody&gt; &lt;tr&gt; &lt;th&gt;&lt;input type="checkbox" id="all" onclick="#"/&gt;&lt;/th&gt; &lt;th&gt;序号&lt;/th&gt; &lt;th&gt;演示字段1&lt;/th&gt; &lt;th&gt;演示字段2&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;input type="hidden" id="id" name="id" /&gt; &lt;c:forEach items="$&#123;messageList&#125;" var="message" varStatus="status"&gt; &lt;tr &lt;c:if test="$&#123;status.index % 2 != 0&#125;"&gt;style='background-color:#ECF6EE;'&lt;/c:if&gt;&gt; &lt;%--value 值与下面的 id 表达式相同--%&gt; &lt;td&gt;&lt;input type="checkbox" name="id" value="$&#123;message.id&#125;"/&gt;&lt;/td&gt; &lt;td&gt;$&#123;status.index + 1&#125;&lt;/td&gt; &lt;td&gt;$&#123;message.command&#125;&lt;/td&gt; &lt;td&gt;$&#123;message.description&#125;&lt;/td&gt; &lt;td&gt; &lt;a href="#"&gt;修改&lt;/a&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;%--使用 get 方法提交，不适合隐私信息及中文信息提交--%&gt; &lt;%--&lt;a href="$&#123;basePath&#125;/DeleteOneServlet.action?id=$&#123;message.id&#125;"&gt;删除&lt;/a&gt;--%&gt; &lt;%--&lt;a href="$&#123;basePath&#125;/DeleteOneServlet.action?id=$&#123;message.id&#125;"--%&gt; &lt;%--onclick="return confirm('确定要删除这条信息吗？');"&gt;删除&lt;/a&gt;--%&gt; &lt;a href="#" onclick="deleteOne('$&#123;pageContext.request.contextPath&#125;',$&#123;message.id&#125;)"&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;div class='page fix'&gt; 共 &lt;b&gt;4&lt;/b&gt; 条 &lt;a href='###' class='first'&gt;首页&lt;/a&gt; &lt;a href='###' class='pre'&gt;上一页&lt;/a&gt; 当前第&lt;span&gt;1/1&lt;/span&gt;页 &lt;a href='###' class='next'&gt;下一页&lt;/a&gt; &lt;a href='###' class='last'&gt;末页&lt;/a&gt; 跳至&amp;nbsp;&lt;input type='text' value='1' class='allInput w28' /&gt;&amp;nbsp;页&amp;nbsp; &lt;a href='###' class='go'&gt;GO&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 123456789程序未报错，但 tomcat 连接后直接停止：Connected to the target VM, address: &apos;127.0.0.1:10605&apos;, transport: &apos;socket&apos;Disconnected from the target VM, address: &apos;127.0.0.1:10605&apos;, transport: &apos;socket&apos;解决方法：把 main 测试函数注释掉，通过 tomcat 发布文件 12345678910&lt;script type="text/javascript"&gt; function deleteOne(path,id)&#123; if(confirm("确定要删除吗？"))&#123; document.getElementById("id").value=id; //将路径首字母小写会使函数失效，这里对应的是web.xml 配置的 url //"/deleteOneServlet.action" document.getElementById("mainForm").action = path+"/DeleteOneServlet.action"; document.getElementById("mainForm").submit(); &#125; &#125; &lt;/script&gt; 123456789idea 未报错，点击删除，批量删除无效，网页前台控制台报错：Uncaught ReferenceError: deleteBatch is not defined at &lt;anonymous&gt;:1:1 解决：DeleteBatchServlet 后忘记加 .action 应将其提交到 web.xml 配置的 url 上$(&quot;#mainForm&quot;).attr(&quot;action&quot;,basePath+&quot;/DeleteBatchServlet.action&quot;);//此处 name = &quot;id&quot; 而不是 id = &quot;id&quot;,而且不加 value 时，checkbox 选中时返回的值是 on&lt;td&gt;&lt;input type=&quot;checkbox&quot; name=&quot;id&quot; value=&quot;$&#123;message.id&#125;&quot;/&gt;&lt;/td&gt; 12345678910111213141516171819202122232425262728网页报错：Type Exception ReportMessage For input string: &quot;&quot;Description The server encountered an unexpected condition that prevented it from fulfilling the request.Exceptionjava.lang.NumberFormatException: For input string: &quot;&quot; java.lang.NumberFormatException.forInputString(Unknown Source) java.lang.Integer.parseInt(Unknown Source) java.lang.Integer.valueOf(Unknown Source) com.imooc.service.MaintainService.deleteBatch(MaintainService.java:41) com.imooc.servlet.DeleteBatchServlet.doGet(DeleteBatchServlet.java:17) com.imooc.servlet.DeleteBatchServlet.doPost(DeleteBatchServlet.java:25) javax.servlet.http.HttpServlet.service(HttpServlet.java:661) javax.servlet.http.HttpServlet.service(HttpServlet.java:742) org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52)Note The full stack trace of the root cause is available in the server logs.问题：ids 在接受值时 String[] ids = req.getParameterValues(&quot;id&quot;);会多出一个 index[0] = &quot;&quot;;解决： 在 service 中判断是否为空 if(id!=null &amp;&amp; !&quot;&quot;.equals(id.trim())) &#123; idList.add(Integer.valueOf(id)); &#125; 123456789101112131415点击删除后，页面跳转到 http://localhost:8080/DeleteBatchServlet.action但是没有删除所选中的几条值日志：2018-07-27 12:54:52,186 [http-nio-8080-exec-3] DEBUG [Message.deleteBatch] - ==&gt; Preparing: delete from MESSAGE where ID in( ? , ? ) 2018-07-27 12:54:52,187 [http-nio-8080-exec-3] DEBUG [Message.deleteBatch] - ==&gt; Parameters: 5(Integer), 6(Integer)2018-07-27 12:54:52,188 [http-nio-8080-exec-3] DEBUG [Message.deleteBatch] - &lt;== Updates: 22018-07-27 12:54:52,226 [http-nio-8080-exec-3] DEBUG [Message.queryMessageList] - ==&gt; Preparing: select ID,COMMAND,DESCRIPTION,CONTENT from MESSAGE where 1=1 2018-07-27 12:54:52,227 [http-nio-8080-exec-3] DEBUG [Message.queryMessageList] - ==&gt; Parameters: 2018-07-27 12:54:52,229 [http-nio-8080-exec-3] DEBUG [Message.queryMessageList] - &lt;== Total: 3解决：messageDao 中传入的参数类型错误，应该为 List&lt;Integer&gt;idspublic void deleteBatch(List&lt;Integer&gt; ids) idea 导入本地 jar 包源码的方法idea 导入本地 jar 包源码 log4j 中的代码意义log4j.appender.Console.layout.ConversionPattern=%d [%t] %-5p [%c] - %m%n %d 日志生成的时间 %t 是产生日志所处的线程名称 %p 输出日志的级别，%-5p 将占5位字符，不足5位用空格填补，- 指的是在右边补空 %c 你输出日志的包以及类的全名 %m 是你附加的信息 %n 换行 代码实现demo 源码]]></content>
      <categories>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AnnTest java 注解]]></title>
    <url>%2F2018%2F07%2F18%2FAnnTest%2F</url>
    <content type="text"><![CDATA[运行机制划分注解 源码注解：只在源码中存在，编译成 .class 文件就不存在了。 编译时注解：注解在源码和 .class 文件中都存在 @Override @Deprecated @Suppvisewarning @Override ：表示覆写了某一个方法 @Deprecated ：表示一个方法已经过期，可用 @Suppvisewarning 忽略警告 运行时注解：在运行阶段还起作用，甚至会影响运行逻辑的注解。 @Autowired 1234567891011package com.ann.test;public class Test &#123; //忽略方法中的方法过期警告，也可以放在类外，忽略整个类的过期警告 @SuppressWarnings("deprecation") public void sing()&#123; Person p = new Child(); p.sing(); &#125;&#125; 123456789package com.ann.test;public interface Person &#123; public String name(); public int age(); //提示方法已过期 @Deprecated public void sing();&#125; 解析注解1234元注解RetentionPolicy，表明注解的生命周期：1、SOURCE：在原文件中有效，被编译器丢弃。 2、CLASS：在class文件有效，可能会被虚拟机忽略。 3、RUNTIME：在运行时有效。 @Inherited 元注解是一个标记注解，@Inherited阐述了某个被标注的类型是被继承的。 如果一个使用了@Inherited修饰的annotation类型被用于一个class，则这个annotation将被用于该class的子类。 注意：@Inherited annotation类型是被标注过的class的子类所继承。类并不从它所实现的接口继承annotation， 方法并不从它所重载的方法继承annotation。 @Inherited 对接口没作用，只会继承类 123456789101112package com.ann.test;import java.lang.annotation.*;import java.util.Map;//自定义注解，在 Child 中使用@Target(&#123;ElementType.METHOD,ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Inherited@Documentedpublic @interface Description &#123; String value();&#125; 12345678910111213141516171819package com.ann.test;@Description("i am class annotation")public class Child implements Person &#123; @Override @Description("i am method annotation") public String name() &#123; return null; &#125; @Override public int age() &#123; return 0; &#125; @Override public void sing() &#123; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.ann.test;import java.lang.annotation.Annotation;import java.lang.reflect.Method;//只能取到运行时加载public class PraseAnn &#123; public static void main(String[] args) &#123; try &#123; //使用类加载器加载类 Class c = Class.forName("com.ann.test.Child"); //找到类上的注解 boolean isExist = c.isAnnotationPresent(Description.class); if(isExist)&#123; //拿到注解实例 Description d = (Description) c.getAnnotation(Description.class); System.out.println(d.value()); &#125; //找到方法上的注解 Method[] ms = c.getMethods(); for (Method m : ms) &#123; boolean isMExist = m.isAnnotationPresent(Description.class); if(isMExist)&#123; Description d = m.getAnnotation(Description.class); System.out.println(d.value()); &#125; &#125; //另一种解析方法 for (Method m : ms) &#123; Annotation[]as = m.getAnnotations(); for (Annotation a : as) &#123; if(a instanceof Description)&#123; Description d = (Description) a; System.out.println(d.value()); &#125; &#125; &#125; &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 运行 PraseAnn 输出结果 i am class annotationi am method annotationi am method annotation java 注解 Element 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192package com.imooc.test;@Table("user")public class Filter &#123; /** Column column = field.getAnnotation(Column.class);得到的是字段上注解内容，然后通过 String columnName = column.value();得到就是此注解下的字段名， @Column("id") （好比上面的 column，不过只是比如column是一个注解对象） private int id; （columnName 就得到的是 id ） @Table("数据库中的表名") @Column("数据库中的列名/字段名:id/user_name...") */ @Column("id") private int id; @Column("user_name") private String userName; @Column("nick_name") private String nickName; @Column("age") private int age; @Column("city") private String city; @Column("email") private String email; @Column("mobile") private String mobile; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getUserName() &#123; return userName; &#125; public void setUserName(String userName) &#123; this.userName = userName; &#125; public String getNickName() &#123; return nickName; &#125; public void setNickName(String nickName) &#123; this.nickName = nickName; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getCity() &#123; return city; &#125; public void setCity(String city) &#123; this.city = city; &#125; public String getEmail() &#123; return email; &#125; public void setEmail(String email) &#123; this.email = email; &#125; public String getMobile() &#123; return mobile; &#125; public void setMobile(String mobile) &#123; this.mobile = mobile; &#125;&#125; 123456789101112131415package com.imooc.test;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;//作用域：类或接口@Target(&#123;ElementType.TYPE&#125;)//生命周期：运行时@Retention(RetentionPolicy.RUNTIME)public @interface Table &#123; //使用值只有一个：表名 user String value();&#125; 1234567891011121314package com.imooc.test;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;//作用域：字段、枚举的常量@Target(&#123;ElementType.FIELD&#125;)//生命周期：运行时有效@Retention(RetentionPolicy.RUNTIME)public @interface Column &#123; String value();&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485package com.imooc.test;import java.io.ObjectInputStream;import java.lang.reflect.Field;import java.lang.reflect.Method;public class Test &#123; public static void main(String[] args) &#123; Filter f1 = new Filter(); f1.setId(10);//查询 id 为 10 的用户 Filter f2 = new Filter(); f2.setUserName("lucy");//查询用户名为 lucy 的用户 Filter f3 = new Filter(); f3.setEmail("liu@sina.com,zh@163.com,77777@qq.com");//查询邮箱为其中任意一个用户 String sql1 = query(f1); String sql2 = query(f2); String sql3 = query(f3); System.out.println(sql1); System.out.println(sql2); System.out.println(sql3); &#125; private static String query(Filter f)&#123; StringBuilder sb = new StringBuilder(); //获取 class Class c = f.getClass(); //获取 table 的名字 boolean exists = c.isAnnotationPresent(Table.class); if(!exists)&#123; return null; &#125; Table t = (Table) c.getAnnotation(Table.class); String tableName = t.value(); /** * 例如为不定数量的查询条件，我们在后台写查询的时候， 类似于这样的语句 string sql ="select * from table where" 为了使语句通顺不报错，加上 where 1=1 */ sb.append("select * form").append(tableName).append("where 1=1"); //遍历所有的字段 Field[] fArray = c.getDeclaredFields(); for (Field field : fArray) &#123; //处理每个字段对应的 sql //拿到字段名 boolean fExists = field.isAnnotationPresent(Column.class); if(!fExists)&#123; continue; &#125; Column column = field.getAnnotation(Column.class); String columnName = column.value(); //拿到字段值 String filedName = field.getName(); String getMethodName = "get" + filedName.substring(0,1).toUpperCase()+filedName.substring(1); //通过反射取得 method System.out.println(getMethodName); Object fieldValue = null; try &#123; Method getMethod = c.getMethod(getMethodName); fieldValue = getMethod.invoke(f); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; //拼装 sql if(fieldValue==null ||(fieldValue instanceof Integer &amp;&amp; (Integer)fieldValue==0))&#123; continue; &#125; sb.append(" and ").append(filedName); if(fieldValue instanceof String)&#123; sb.append("=").append("'").append(columnName).append("'"); &#125;else if(fieldValue instanceof Integer) &#123; sb.append("=").append(columnName); &#125; &#125; return sb.toString(); &#125;&#125;]]></content>
      <categories>
        <category>Annotation</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>注解</tag>
        <tag>imooc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Reflection 反射]]></title>
    <url>%2F2018%2F07%2F17%2Factive-class%2F</url>
    <content type="text"><![CDATA[反射指的是可以于运行时加载,探知和使用编译期间完全未知的类. 程序在运行状态中, 可以动态加载一个只有名称的类, 对于任意一个已经加载的类,都能够知道这个类的所有属性和方法; 对于任意一个对象,都能调用他的任意一个方法和属性; 加载完类之后, 在堆内存中会产生一个Class类型的对象(一个类只有一个Class对象), 这个对象包含了完整的类的结构信息,而且这个Class对象就像一面镜子,透过这个镜子看到类的结构,所以被称之为:反射。 不是所有的实例化都是 new ，new 时必须知道这个类是什么，而很多时候做不到预先知道类名，很多框架如 Spring 应用了反射的原理。 new 创建的对象是 静态加载类，在编译时就需要加载所有可能用到的类，若在编译时找不到类直接报错。一个功能有问题，其他功能都无法使用。 class 为类类型/字节码（编译后的类） OfficeBetter.java 1234567891011121314151617181920212223class OfficeBetter&#123; public static void main(String args [])&#123; try&#123; //动态加载类，在运行时加载 Class c = Class.forName(args[0]); OfficeAble oa = (OfficeAble)c.newInstance(); oa.start(); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; &#125;&#125; OfficeAble.java 1234567interface OfficeAble&#123; //创建接口，由使用者来实现该接口,重写 start 方法 public void start();&#125; Word.java 123456789class Word implements OfficeAble&#123; public void start()&#123; System.out.println("word--starts"); &#125;&#125; 编译 javac *.java 运行 java OfficeBetter Word (main 类 + 实现接口类) 输出结果 word–starts 获取类的信息首先要获取类的类类型 Class c1 = int.class; //int 的类类型 String c2 = String.class //String 的类类型 void c3 = void.class System.out.println(c1.getName()); //打印包含包名的类的名称 System.out.println(c2.getSimpleName()); //打印不包含包名的类的名称 System.out.println(c3.getName()); //打印结果：void 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package com.imooc.reflect;public class ClassUtil &#123; public static void PrintClassMessage(Object obj) &#123; //传递的是哪个子类的对象，c 就是该子类的类类型 Class c = obj.getClass(); //getMethods() 获取所有 public 的函数，包括父类继承而来的 //getDeclaredMethods() 获取的是该类自己声明的方法，不问访问权限； Method [] ms = c.getMethods(); for(int i = 0; i &lt; ms.length; i++)&#123; //得到方法返回值类型的类类型 Class returnType = ms[i].getReturnType(); System.out.print(returnType.getName()+""); //得到方法的名称 System.out.print(ms[i].getName()+"("); //获取参数类型，得到的是参数列表的类型的类类型 Class [] paramTypes = ms[i].getParameterTypes(); for(Class class1:paramTypes)&#123; System.out.print(class1.getName()+","); &#125; System.out.println(")"); &#125; public static void printFieldMessage(Object obj) &#123; Class c = obj.getClass(); //成员变量也是对象； Field[] fs = c.getDeclaredFields(); for (Field field : fs) &#123; Class fieldType = field.getType(); String typeName = fieldType.getName(); //得到成员变量名称 String fieldName = field.getName(); System.out.println(typeName + " " + fieldName); &#125; &#125; //打印对象的构造函数信息 public static void printConMessage(Object obj)&#123; Class c = obj.getClass(); /*构造函数也是对象 java.lang.Constructor 封装了构造函数的信息 getConstructors 获取所有的 public 的构造函数 Constructor []cs = c.getConstructors(); */ Constructor [] cs = c.getDeclaredConstructors(); for (Constructor constructor : cs) &#123; System.out.print(constructor.getName()+"("); //获取构造函数的参数列表--&gt;得到的是参数列表的类类型 Class[] parameterTypes = constructor.getParameterTypes(); for (Class class1 : parameterTypes) &#123; System.out.print(class1.getName()+","); &#125; System.out.println(")"); &#125; &#125;&#125; 1234567891011package com.imooc.reflect;//PrintClassMessage 方法测试类public class ClassDemo3 &#123; public static void main(String[] args) &#123; String s = &quot;hello&quot;; ClassUtil.PrintClassMessage(s); Integer n1 = 1; ClassUtil.PrintClassMessage(n1); &#125;&#125; 123456789package com.imooc.reflect;//printieldMessage() 方法测试类public class ClassDemo4 &#123; public static void main(String[] args) &#123; ClassUtil.printFieldMessage(&quot;hello&quot;); System.out.println(&quot;==========&quot;); ClassUtil.printFieldMessage(new Integer(1)); &#125;&#125; 12345678package com.imooc.reflect;//printConMessage() 方法测试类public class ClassDemo5 &#123; public static void main(String[] args) &#123; ClassUtil.printConMessage(&quot;hello&quot;); ClassUtil.printConMessage(new Integer(1)); &#125;&#125; 方法的反射操作method.invoke(对象，参数列表) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package com.imooc.reflect;import java.lang.reflect.Method;public class MethodDemo1 &#123; public static void main(String[] args) &#123; //获取print(int a,int b)方法，获取一个方法就是获取类的信息，获取类的信息就要获得类的类类型 A a1 = new A(); Class c = a1.getClass(); /** * 获取方法 名称和参数决定 * getMethod 获取的是 public 的方法 * getDelcaredMethod 自己声明的方法 */ try &#123; Method m = c.getMethod("print", int.class, int.class);// 或 Method m = c.getMethod("pirnt", new Class[]&#123;int.class, int.class&#125;); /** * 方法的反射操作 * a1.print(10,20); 方法的反射操作是用 m 对象来进行方法的调用 和 a1.print 调用效果完全相同 * 方法没有返回值，则返回 null ，有返回值则返回具体的返回值 */ Object o = m.invoke(a1, new Object[]&#123;10, 20&#125;); System.out.println("==========="); //获取方法对象 Method m1 = c.getMethod("print", String.class, String.class); //用方法进行反射操作 o = m1.invoke(a1, "Hello", "Word"); System.out.println("==========="); Method m2 = c.getMethod("print"); //或 Method m1 = c.getMethod("print", new Class[]&#123;&#125;); m2.invoke(a1); // 或m2.invoke(a1,new Object[]&#123;&#125;); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125;class A&#123; public void print(int a,int b)&#123; System.out.println(a+b); &#125; public void print(String a,String b)&#123; System.out.println(a.toUpperCase() + "," + b.toLowerCase()); &#125; public void print()&#123; System.out.println("hello Word"); &#125;&#125; 通过反射了解泛型本质class 为类类型/字节码（编译后的类） class/method 等反射操作都是绕过编译的操作 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.imooc.reflect;import java.lang.reflect.Method;import java.util.ArrayList;public class MethodDemo4 &#123; public static void main(String[] args) &#123; ArrayList list = new ArrayList(); //泛型，只能放 String 类型； //防止加入 list1.add(10); 这种操作 ArrayList&lt;String&gt;list1 = new ArrayList&lt;&gt;(); list1.add("hello"); Class c1 = list.getClass(); Class c2 = list1.getClass(); System.out.println(c1 == c2); /** * 反射的操作都是编译之后的操作（跳过编译阶段） * c1 == c2 返回 true 说明编译之后的集合泛型是去泛型化的 * java 中集合的泛型是防止错误输入，只在编译阶段有效，绕过编译就无效 * 验证：通过方法反射操作，绕过编译 */ Method m = null; try &#123; m = c2.getMethod("add", Object.class); m.invoke(list1,10);//绕过编译操作就绕过了泛型 System.out.println(list1.size()); /** * for (String string : list1) &#123; System.out.println(string); &#125; 此时遍历会发生错误异常，提示不能将 int 转换成 String * java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String */ &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>imooc</tag>
        <tag>reflection</tag>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo next 搭建博客]]></title>
    <url>%2F2018%2F07%2F11%2Fblog-create%2F</url>
    <content type="text"><![CDATA[hexo 安装插入图片： node_modules：是依赖包public：存放的是生成的页面scaffolds：命令生成文章等的模板source：用命令创建的各种文章themes：主题_config.yml：整个博客的配置db.json：source解析所得到的package.json：项目所需模块项目的配置信息 接下来依次在命令行输入hexo ghexo s 在浏览器中打开http://localhost:4000/，看到网页则配置结束 将Hexo与github page 联系起来 设置Git的user name和email：(如果是第一次的话) git config --global user.name &quot;crow-song&quot;git config --global user.email &quot;crowsong.end@gmail.com&quot; 设置 ssh 密钥参考：https://blog.csdn.net/love_fdu_llp/article/details/38752365 https://jingyan.baidu.com/article/a65957f4e91ccf24e77f9b11.html 检查本机是否有ssh key设置 $ cd ~/.ssh 或cd .ssh 如果没有则提示： No such file or directory 如果有则进入~/.ssh路径下（ls查看当前路径文件，rm * 删除所有文件) ssh-keygen -t rsa -C &quot;crowsong.end@gmail.com&quot; 生成密钥对 之后全部 enter 就行 秘钥存放路径为：c:/Users/xxxx_000/.ssh/下 查看你生成的公钥：$ cat ~/.ssh/id_rsa.pub 复制公钥到 github 账户的 AccountSettings → SSHKeys → 点击 new SSH Key title 随意填写，公钥复制进文本域内 点击确定 确认设置 验证下这个key是不是正常工作。 $ ssh -T git@github.com # Attempts to ssh to github 键入 yes 看到： Hi username! You’ve successfully authenticated, but GitHub does not # provide shell access. 就表示设置成功。 接下来使用 hexo d 不再需要输入用户和密码了 配置Deployment同样在_config.yml文件中，找到Deployment，然后按照如下修改：repo 中是仓库地址（自己的 git 发布网址） deploy: type:git repo:https://crow-song.github.io/ branch:master 写博客新建一篇博客，执行下面的命令： hexo new post “article title” 这时候在我的 电脑的目录下 ..\hexo\source\ _posts 将会看到 article title.md 文件 用MarDown编辑器打开就可以编辑文章了。文章编辑好之后，运行生成、部署命令： hexo g hexo d 参考：https://blog.csdn.net/gdutxiaoxu/article/details/53576018 hexo的next主题个性化教程 Typora md文档多标签样式： tags: 博客创建 hexo 修改 css 样式，找到目标对应 css 文件，修改 background:#transparent （面板透明色） rgba(255,255,255,.9) 添加网易云音乐插件 在 mian.xxxx.css 中设置位置 .header-music {margin-top: 55px;margin-left: 0px; } nofollw 作用 添加图片 可用样式为 图片放在对应 md 文件的文件夹中 添加链接： ctrl+k 添加背景图： 将括号里面的这里填写背景图片地址替换为你所要显示的背景图片地址，#ffffff表示背景颜色为#ffffff(白色)修改为你想要的背景颜色代码，repeat表示图片平铺，不平铺改为no-repeat，scroll表示图片随对象滚动，图片固定不滚动改为fixed。 头像旋转放大： hover 选择器使用 选择鼠标移到链接上的样式 xxx:hover(xxx 可以是 img 也可以是类选择器等。如果直接使用 img:hover 会将插入图片一起放大) .site-author-image:hover 设置网站图标 Favicon 设置网站图标时使用 ico 图片会无法正常显示，使用 32*32 png 图片即可 Typora markdown 语法 设置标签随机大小与颜色 设置过程中出现 jQuery 报错：Uncaught ReferenceError: $ is not defined 可以添加 jQuery 引用 网站 debug 通过但部署后报错：(index):1 Mixed Content: The page at ‘https://crow-song.github.io/tags/&#39; was loaded over HTTPS, but requested an insecure script ‘http://libs.baidu.com/jquery/1.9.0/jquery.js&#39;. This request has been blocked; the content must be served over HTTPS. 将其 http 改为 https github fork 别人的博客后 404 错误https://github.com/qiubaiying/qiubaiying.github.io/issues/98在code下找到CNAME文件，将里面的内容改为：https://你的Github账号名.github.io，然后点底部的commit changes，应该就可以了 hexo d 或 hexo deploy 无反应解决: 配置文档中 _config.yml 冒号后需要加空格deploy:type: gitrepo: https://github.com/crow-song/crow-song.github.io.gitbranch: master hexo g 错误ERROR Process failed: _posts/article-title.mdYAMLException: can not read a block mapping entry; a multiline key may not be an implicit key at line 4, column 1:md 文档中开头 3 个标题冒号后也需要加空格title: article titledate: 2018-07-11 23:09:21tags: 博客创建]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>博客创建</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
