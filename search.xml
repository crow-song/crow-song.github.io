<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[springBootDDD]]></title>
    <url>%2F2019%2F11%2F20%2FspringBootDDD%2F</url>
    <content type="text"><![CDATA[springboot 使用mybatis 分层 https://www.cnblogs.com/smfx1314/p/9689824.html DDD 风格分层架构 遵循基本的分层架构风格。 User Interface —— 用户接口层。对外提供各种协议形式的服务，并提供Validation参数校验，authenticate权限认证，业务实体组装器Assembler等。图中标绿组件。 Application —— 应用服务层。组合多个业务实体、基础设施层的各种组件完成业务服务。图中标黄部分。 Domain —— 业务领域层。DDD概念中的核心业务层，封装所有业务逻辑，包含entity、value object、domain service、domain event等。图中标蓝部分。 Infrastructure —— 基础设施层。提供公共组件，如：Logging、Trascation、HttpClient等。图中标灰部分。 https://www.cnblogs.com/daoqidelv/p/7499244.html Q:springbootlogback 出现报错A:16:46:33,199 |-ERROR in ch.qos.logback.core.rolling.RollingFileAppender[FILE] - openFile(/var/log/opentsdb/opentsdb.log,true) call failed. java.io.FileNotFoundException: 没有该路径，需要手动创建，或者在 logback-spring.xml 中配置 fileNamePattern Q:Unsupported major.minor version 52.0A: 直译过来意思是：不支持version52.0，其中version 52.0是魔码的其中一个版本，他对应的是jdk1.8 所以异议过来就是：不支持jdk1.8 简单来说，就是执行环境的jdk版本 低于 编译的jdk版本 jar 包编译时使用了 jdk 1.8,但是 linux 上使用的是 1.7 版本导致 java -jar 报错 参考：https://blog.csdn.net/qq_36769100/article/details/78880341 Q:springboot jar 包启动报错端口被占用The Tomcat connector configured to listen on port 8080 failed to start. The port may already be in use or the connector may be misconfigured. A:java -jar demo.jar –server.port=9090]]></content>
      <tags>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tenthPower]]></title>
    <url>%2F2019%2F11%2F01%2FtenthPower%2F</url>
    <content type="text"><![CDATA[创建 js 文件并将 text 文本输入到文件中 echo text&gt;demo.js 创建空文件 type nul&gt;demo.js]]></content>
      <categories>
        <category>java</category>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gitUse]]></title>
    <url>%2F2019%2F11%2F01%2FgitUse%2F</url>
    <content type="text"><![CDATA[git 命令 下载仓库文件到本地 git clone http://xxx.git 查看本地目录对应远程仓库地址 在本地 git 目录下 git remote -v git branch 查看当前分支 git add 文件 git add 文件夹/ git commit -m &quot;提交信息&quot; git status git pull git push 远程分支]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springBootHM]]></title>
    <url>%2F2019%2F10%2F21%2FspringBootHM%2F</url>
    <content type="text"><![CDATA[@SpringBootApplication @EnableAutoConfiguration @SpringBootConfiguration @ComponentScan 包含三个注解，ComponentScan 能查找当前 Application 包下所有文件 @EnableAutoConfiguration @Import({AutoConfigurationImportSelector.class}) org.springframework.boot.autoconfigure.AutoConfigurationImportSelector AutoConfigurationImportSelector 类中的getCandidateConfigurations() 方法中 该方法中打印的就是当前包下的 META-INF/spring.factories 1Assert.notEmpty(configurations, &quot;No auto configuration classes found in META-INF/spring.factories. If you are using a custom packaging, make sure that file is correct.&quot;); 查找 spring.factories 中的一个配置， 1org.springframework.boot.autoconfigure.web.servlet.ServletWebServerFactoryAutoConfiguration,\ 查找 ServletWebServerFactoryAutoConfiguration 类，在该类上的一个注释 1@EnableConfigurationProperties(&#123;ServerProperties.class&#125;) 12erverProperties.classprefix = &quot;server&quot;, 下有许多内置的属性private Integer port;通过配置文件加载 1/org/springframework/boot/spring-boot-autoconfigure/2.2.0.RELEASE/spring-boot-autoconfigure-2.2.0.RELEASE.jar!/META-INF/spring-configuration-metadata.json json中其中一个配置1234567&#123; "name": "server.port", "type": "java.lang.Integer", "description": "Server HTTP port.", "sourceType": "org.springframework.boot.autoconfigure.web.ServerProperties", "defaultValue": 8080 &#125;, 能在 application.properties 等配置文件中进行覆写 12server.port=12222server.servlet.context-path=/demo yml 配置 123456789101112131415161718192021222324252627282930server: port: 12345city: beijing#city:# - beijing# - shanghai# - zhejiang#city: [nanjing,tianjin]person: name: rufui age: 18 addr: beijing#配置数据、集合（对象数据）students: - name: zhangsan age: 18 addr: beijing - name: tom age: 20 addr: nanjing#配置行内集合对象#students: [&#123;name: luck,age: 19,addr: zhejiang&#125;,&#123;name: mike,age: 22,addr: tianjin&#125;]map: key1: value1 key2: value2 Q&amp;Aspringboot 整合 junit 测试 java.lang.Exception: No runnable methods 没有可运行的方法 因为没有在测试类中的对应方法上面加 @Test 注解 经过查看因为在测试类中加入的 @Test 方法是 org.junit.jupiter.api 的 Test 注释，把错误的包删掉，重新导入 org.junit.Test 的包 参考：https://www.cnblogs.com/libra0920/p/6228838.html]]></content>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
        <tag>springBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[thinkingInJava]]></title>
    <url>%2F2019%2F09%2F11%2FthinkingInJava%2F</url>
    <content type="text"><![CDATA[1.1 抽象的进步在面向对象的程序设计中，尽管我们真正要做的是新建各种各样的数据“类型”（Type），但几乎所有面向对象的程序设计语言都采用了“class”关键字。当您看到“type”这个字的时候，请同时想到“class”；反之亦然。 1.2 对象的接口12Light lt = new Light();lt.on(); 在这个例子中，类型／类的名称是Light，可向Light对象发出的请求包括包括打开（on）、关闭（off）、变得更明亮（brighten）或者变得更暗淡（dim）。通过简单地声明一个名字（lt），我们为Light对象创建了一个“句柄”。然后用new关键字新建类型为Light的一个对象。再用等号将其赋给句柄。为了向对象发送一条消息，我们列出句柄名（lt），再用一个句点符号（.）把它同消息名称（on）连接起来。从中可以看出，使用一些预先定义好的类时，我们在程序里采用的代码是非常简单和直观的。 1.3 实现方案的隐藏Java采用三个显式（明确）关键字以及一个隐式（暗示）关键字来设置类边界：public，private，protected以及暗示性的friendly。若未明确指定其他关键字，则默认为后者。这些关键字的使用和含义都是相当直观的，它们决定了谁能使用后续的定义内容。“public”（公共）意味着后续的定义任何人均可使用。而在另一方面，“private”（私有）意味着除您自己、类型的创建者以及那个类型的内部函数成员，其他任何人都不能访问后续的定义信息。private在您与客户程序员之间竖起了一堵墙。若有人试图访问私有成员，就会得到一个编译期错误。“friendly”（友好的）涉及“包装”或“封装”（Package）的概念——即Java用来构建库的方法。若某样东西是“友好的”，意味着它只能在这个包装的范围内使用（所以这一访问级别有时也叫作“包装访问”）。“protected”（受保护的）与“private”相似，只是一个继承的类可访问受保护的成员，但不能访问私有成员。 1.4 方案的重复使用为重复使用一个类，最简单的办法是仅直接使用那个类的对象。但同时也能将那个类的一个对象置入一个新类。我们把这叫作“创建一个成员对象”。新类可由任意数量和类型的其他对象构成。无论如何，只要新类达到了设计要求即可。这个概念叫作“组织”——在现有类的基础上组织一个新类。有时，我们也将组织称作“包含”关系，比如“一辆车包含了一个变速箱”。 对象的组织具有极大的灵活性。新类的“成员对象”通常设为“私有”（Private），使用这个类的客户程序员不能访问它们。这样一来，我们可在不干扰客户代码的前提下，从容地修改那些成员。也可以在“运行期”更改成员，这进一步增大了灵活性。后面要讲到的“继承”并不具备这种灵活性，因为编译器必须对通过继承创建的类加以限制。 由于继承的重要性，所以在面向对象的程序设计中，它经常被重点强调。作为新加入这一领域的程序员，或许早已先入为主地认为“继承应当随处可见”。沿这种思路产生的设计将是非常笨拙的，会大大增加程序的复杂程度。相反，新建类的时候，首先应考虑“组织”对象；这样做显得更加简单和灵活。利用对象的组织，我们的设计可保持清爽。一旦需要用到继承，就会明显意识到这一点。 1.5 继承：重新使用接口但在许多时候，我们必须为衍生类型加入新的接口元素。所以不仅扩展了接口，也创建了一种新类型。这种新类型仍可替换成基础类型，但这种替换并不是完美的，因为不可在基础类里访问新函数。我们将其称作“类似”关系；新类型拥有旧类型的接口，但也包含了其他函数，所以不能说它们是完全等价的。举个例子来说，让我们考虑一下制冷机的情况。假定我们的房间连好了用于制冷的各种控制器；也就是说，我们已拥有必要的“接口”来控制制冷。现在假设机器出了故障，我们把它换成一台新型的冷、热两用空调，冬天和夏天均可使用。冷、热空调“类似”制冷机，但能做更多的事情。由于我们的房间只安装了控制制冷的设备，所以它们只限于同新机器的制冷部分打交道。新机器的接口已得到了扩展，但现有的系统并不知道除原始接口以外的任何东西。 1.6 多形对象的互换使用设计程序时，我们经常都希望基础类只为自己的衍生类提供一个接口。也就是说，我们不想其他任何人实际创建基础类的一个对象，只对上溯造型成它，以便使用它们的接口。为达到这个目的，需要把那个类变成“抽象”的——使用abstract关键字。若有人试图创建抽象类的一个对象，编译器就会阻止他们。这种工具可有效强制实行一种特殊的设计。 亦可用abstract关键字描述一个尚未实现的方法——作为一个“根”使用，指出：“这是适用于从这个类继承的所有类型的一个接口函数，但目前尚没有对它进行任何形式的实现。”抽象方法也许只能在一个抽象类里创建。继承了一个类后，那个方法就必须实现，否则继承的类也会变成“抽象”类。通过创建一个抽象方法，我们可以将一个方法置入接口中，不必再为那个方法提供可能毫无意义的主体代码。 interface（接口）关键字将抽象类的概念更延伸了一步，它完全禁止了所有的函数定义。“接口”是一种相当有效和常用的工具。另外如果自己愿意，亦可将多个接口都合并到一起（不能从多个普通class或abstract class中继承）。 1.7 对象的创建和存在时间句柄在程序设计中，句柄是Windows操作系统用来标识被应用程序所创建或使用的对象的整数。其本质相当于带有引用计数的智能指针。当一个应用程序要引用其他系统所管理的内存块或对象时，可以使用句柄 第二个方法是在一个内存池中动态创建对象，该内存池亦叫“堆”或者“内存堆”。若采用这种方式，除非进入运行期，否则根本不知道到底需要多少个对象，也不知道它们的存在时间有多长，以及准确的类型是什么。这些参数都在程序正式运行时才决定的。若需一个新对象，只需在需要它的时候在内存堆里简单地创建它即可。由于存储空间的管理是运行期间动态进行的，所以在内存堆里分配存储空间的时间比在堆栈里创建的时间长得多（在堆栈里创建存储空间一般只需要一个简单的指令，将堆栈指针向下或向下移动即可）。由于动态创建方法使对象本来就倾向于复杂，所以查找存储空间以及释放它所需的额外开销不会为对象的创建造成明显的影响。除此以外，更大的灵活性对于常规编程问题的解决是至关重要的。]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springBoot-features3]]></title>
    <url>%2F2019%2F09%2F04%2FspringBoot-features3%2F</url>
    <content type="text"><![CDATA[除REST Web服务外，您还可以使用Spring WebFlux来提供动态HTML内容。Spring WebFlux支持各种模板技术，包括Thymeleaf，FreeMarker和Mustache。 当您使用其中一个模板引擎和默认配置时，您的模板将自动从 src/main/resources/templates 中获取。 1.1 创建 model 1.2 创建 repository 接口和实现类 在 repository 中返回一个 Flux 对象 1.3 创建 Controller 类 1.4 创建 index.html 页面 页面引入的 css 1.5 页面展示访问 localhost:8080 数据以流式传输，并且以每隔两秒的反应方式显示]]></content>
      <tags>
        <tag>spring</tag>
        <tag>springBoot</tag>
        <tag>springMVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lambda]]></title>
    <url>%2F2019%2F08%2F08%2Flambda%2F</url>
    <content type="text"><![CDATA[hashMap 中存储的是 entry，既索引和值的方式，用索引的方式进行查找内部的值。 如果插入一个新的值，没有索引的方式下，如果内部有 100W 值，需要进行 100W 次比较，但是 hashMap 使用 hashCode 将需要插入的值计算成索引的方式，去找索引位置有无该索引可以进行判断该对象是否存在，如果没有就可以直接将该值插入到此处。 如果索引处有值存在，那么用 equals 进行判断，两个值是否相同，如果相同就覆盖原来的值 如果不相同就会碰撞，形成一个链表，将新的值放链表头（1.7）或链表尾（1.8），如果再有相同索引的值进来，就要跟链表中所有值进行 equals，会降低效率 为了尽可能降低链表长度，如果容量达到原来 hashMap 的 75% 时，hashMap 会自动进行扩容（resize），将链表中所有元素重新运算，放到扩容完的 hashMap 的中 java1.8 中如果链表长度大于 8 ，那么就会将其转化为红黑树（提升除了添加以外所有操作效率） concurrenthashMap 也是 java8 开始转为红黑树 java8 中将方法区从永久区转移到元空间 MetaSpace，使用物理内存，因为内存变大了，所以垃圾回收机制运行的概率下降了 lambda 表达式 无参无返回值123456789101112131415public class testLambda1&#123; //通常实现 run 方法 Runnable r = new Runnable()&#123; @Override public void run()&#123; System.out.println("hello World"); &#125; &#125; r.run(); //方式二 Runnable r1 = ()-&gt;System.out.println("hello World"); r1.run();&#125; 函数式接口：如果一个接口中只有一个方法，那么这个接口就是函数式接口 @FunctionanlInterface 声明为函数式接口，如果有多个方法则无法通过 定义一个函数式接口，调用接口方法进行乘法操作（也可以定义其他加减法等函数）,输出结果为10000，2533 1234567891011121314public static Integer operation(Integer num,MyFun mf)&#123; return mf.getValue(num);&#125;public static void main(String[] args) &#123; Integer i = operation(100,(x)-&gt;x*x); System.out.println(i); System.out.println(operation(200,y-&gt;y+2333));&#125;public interface MyFun&#123; public Integer getValue(Integer num);&#125;]]></content>
      <tags>
        <tag>java</tag>
        <tag>lambda</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springBoot-features2]]></title>
    <url>%2F2019%2F08%2F01%2FspringBoot-features2%2F</url>
    <content type="text"><![CDATA[自动配置了ContentNegotiatingViewResolver和BeanNameViewResolver两个视图解析器。 支持静态资源，包括webjars Converter, GenericConverter和 Formatter bean类的自动化装配。 支持HttpMessageConverters MessageCodesResolver自动注册。 支持index.html静态页面。 支持自定义Favicon（网站图标）。 ConfigurableWebBindingInitializer自动使用 如果你想保留Spring Boot MVC原有的功能而且还想添加额外MVC配置(interceptors，formatter，视图控制器view controller或者其他功能)，你可以添加你自己@Configuration配置但没有@EnableWebMvc的WebMvcConfigurer类，如果你希望自定义RequestMappingHandlerMapping、RequestMappingHandlerAdapter或者ExceptionHandlerExceptionResolver对象。 你可以声明一个 WebMvcRegistrationsAdapter 对象去提供这些组件。 如果你想完全控制Spring MVC。你能添加自定义@Configuration和@EnableWebMvc注解的类。 视图解析器ContentNegotiatingViewResolver getCandidateView 是用来获取所有解析式图的 Collection&lt;ViewResolver&gt; matchingBeans = BeanFactoryUtils.beansOfTypeIncludingAncestors(getApplicationContext(), ViewResolver.class).values(); 自定义视图解析器 12345678910111213141516171819@Configurationpublic class ApplicationConfig &#123; public class MyViewResolver implements ViewResolver&#123; @Override public View resolveViewName(String viewName, Locale locale) throws Exception &#123; return null; &#125; &#125; /** * 自定义视图解析器 */ @Bean @ConditionalOnMissingBean(MyViewResolver.class) public ViewResolver myViewResolver()&#123; return new MyViewResolver(); &#125;&#125; 支持静态资源，包括webjarsspringMVC 项目一般将静态资源放在 webapp 文件夹下，但是使用 springBoot 创建的项目没有 webapp 目录，springboot 有着自己的映射规则 springBoot 中ResourceProperties.class此配置文件配置了默认的静态资源获取路径根据优先级排序 “classpath:/META-INF/resources/“, “classpath:/resources/“, “classpath:/static/“, “classpath:/public/“ 123public class ResourceProperties &#123; private static final String[] CLASSPATH_RESOURCE_LOCATIONS = new String[]&#123;"classpath:/META-INF/resources/", "classpath:/resources/", "classpath:/static/", "classpath:/public/"&#125;;&#125; 支持静态资源的一个用途 webjarsWebJars是将web前端资源（js，css等）打成jar包文件，然后借助Maven工具，以jar包形式对web前端资源进行统一依赖管理，保证这些Web资源版本唯一性。WebJars的jar包部署在Maven中央仓库上。 webjar 路径 classpath:/META-INF/resources/webjars/ webjar 官网：https://www.webjars.org/ 1234567891011121314151617public void addResourceHandlers(ResourceHandlerRegistry registry) &#123; if (!this.resourceProperties.isAddMappings()) &#123; logger.debug("Default resource handling disabled"); &#125; else &#123; Duration cachePeriod = this.resourceProperties.getCache().getPeriod(); CacheControl cacheControl = this.resourceProperties.getCache().getCachecontrol().toHttpCacheControl(); if (!registry.hasMappingForPattern("/webjars/**")) &#123; this.customizeResourceHandlerRegistration(registry.addResourceHandler(new String[]&#123;"/webjars/**"&#125;).addResourceLocations(new String[]&#123;"classpath:/META-INF/resources/webjars/"&#125;).setCachePeriod(this.getSeconds(cachePeriod)).setCacheControl(cacheControl)); &#125; String staticPathPattern = this.mvcProperties.getStaticPathPattern(); if (!registry.hasMappingForPattern(staticPathPattern)) &#123; this.customizeResourceHandlerRegistration(registry.addResourceHandler(new String[]&#123;staticPathPattern&#125;).addResourceLocations(getResourceLocations(this.resourceProperties.getStaticLocations())).setCachePeriod(this.getSeconds(cachePeriod)).setCacheControl(cacheControl)); &#125; &#125;&#125; 12345678910&lt;dependency&gt; &lt;groupId&gt;org.webjars&lt;/groupId&gt; &lt;artifactId&gt;bootstrap&lt;/artifactId&gt; &lt;version&gt;3.3.7-1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.webjars&lt;/groupId&gt; &lt;artifactId&gt;jquery&lt;/artifactId&gt; &lt;version&gt;3.1.1&lt;/version&gt; &lt;/dependency&gt; 12345678910111213141516&lt;html&gt;&lt;head&gt; &lt;script src="/webjars/jquery/3.1.1/jquery.min.js"&gt;&lt;/script&gt; &lt;script src="/webjars/bootstrap/3.3.7-1/js/bootstrap.min.js"&gt;&lt;/script&gt; &lt;title&gt;WebJars Demo&lt;/title&gt; &lt;link rel="stylesheet" href="/webjars/bootstrap/3.3.7-1/css/bootstrap.min.css" /&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="container"&gt;&lt;br/&gt; &lt;div class="alert alert-success"&gt; &lt;a href="#" class="close" data-dismiss="alert" aria-label="close"&gt;X&lt;/a&gt; Hello, &lt;strong&gt;WebJars!&lt;/strong&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 欢迎页面WebMvcAutoConfiguration 有一个getWelcomePage()方法，用于获取起始页面，在springboot静态资源路径下：”classpath:/META-INF/resources/“, “classpath:/resources/“, “classpath:/static/“, “classpath:/public/“ 放置一个 index.html ，springboot 就会自动去获取到它 页面图标 1mapping.setUrlMap(Collections.singletonMap("**/favicon.ico", this.faviconRequestHandler())); 转换器和格式化器formatter 格式化对象，例如日期格式化对象 converter 转换器类，将多个属性转换为一个对象 这些都是属于springMVC的自动配置，源码在WebMvcConfiguration.class中 12345@Bean@ConditionalOnProperty(prefix = "spring.mvc", name = "date-format")public Formatter&lt;Date&gt; dateFormatter() &#123; return new DateFormatter(this.mvcProperties.getDateFormat());&#125; 123456789101112131415@Overridepublic void addFormatters(FormatterRegistry registry) &#123; for (Converter&lt;?, ?&gt; converter : getBeansOfType(Converter.class)) &#123; registry.addConverter(converter); &#125; for (GenericConverter converter : getBeansOfType(GenericConverter.class)) &#123; registry.addConverter(converter); &#125; for (Formatter&lt;?&gt; formatter : getBeansOfType(Formatter.class)) &#123; registry.addFormatter(formatter); &#125;private &lt;T&gt; Collection&lt;T&gt; getBeansOfType(Class&lt;T&gt; type) &#123;return this.beanFactory.getBeansOfType(type).values();&#125;&#125; 日期格式化器，只有在配置文件中配置了spring.mvc.date-format的值才会注册该组件。 消息转换器HttpMessage 是一个接口，用于将 http 请求转换成一个对象，或者将一个对象转换成 http 请求 比如return对象，json形式响应 123456789101112public interface HttpMessageConverter&lt;T&gt; &#123; //检测参数是否可被读取 boolean canRead(Class&lt;?&gt; var1, @Nullable MediaType var2); //检测参数是否可被写入 boolean canWrite(Class&lt;?&gt; var1, @Nullable MediaType var2); //获取转换器支持的媒体类型 List&lt;MediaType&gt; getSupportedMediaTypes(); //从输入信息中读取指定类型对象 T read(Class&lt;? extends T&gt; var1, HttpInputMessage var2) throws IOException, HttpMessageNotReadableException; //将指定对象写入到输出 void write(T var1, @Nullable MediaType var2, HttpOutputMessage var3) throws IOException, HttpMessageNotWritableException;&#125; ConfigurableWebBindingInitializer此类是用来初始化web数据绑定器的 web数据绑定器是用来将前台传入的数据绑定到相关的bean中的 123456789public class WebMvcConfiguration &#123; protected ConfigurableWebBindingInitializer getConfigurableWebBindingInitializer() &#123; try &#123; return (ConfigurableWebBindingInitializer)this.beanFactory.getBean(ConfigurableWebBindingInitializer.class); &#125; catch (NoSuchBeanDefinitionException var2) &#123; return super.getConfigurableWebBindingInitializer(); &#125; &#125;&#125; 扩展SpringMVC1&lt;view-controller path="/hsw" view-name="success.html"/&gt; 在 springboot 新建一个类继承WebMvcConfigurer 1234567@Configurationpublic class MyWebMvcConfiguration implements WebMvcConfigurer &#123; @Override public void addViewControllers(ViewControllerRegistry registry) &#123; registry.addViewController("/hsw").setViewName("success.html"); &#125;&#125; WebMvcAutoConfiguration是SpringMVC的默认自动配置类。 自动配置类中有个静态内部类EnableWebMvcConfiguration，其父类DelegatingWebMvcConfiguratio有个方法public void setConfigurers(List&lt;WebMvcConfigurer&gt; configurers) {能获取我们自定义实现的所有配置类。然后在静态内部类中将配置给添加到容器中 参考:https://www.jianshu.com/p/2946c1c194c4 https://www.jianshu.com/p/3ed2e5594dcf https://blog.csdn.net/qq_40757662/article/details/95481999]]></content>
      <tags>
        <tag>spring</tag>
        <tag>springBoot</tag>
        <tag>springMVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pythonAutoDeploy]]></title>
    <url>%2F2019%2F07%2F18%2FpythonAutoDeploy%2F</url>
    <content type="text"><![CDATA[OPEN open open(filePath,’r’) 用于打开文件对象，第一个参数用于传入文件路径和文件名，第二个参数用于表示 open 函数的函数标识符，r 表示只读方式打开文件，文件的指针会放在文件的开头，这是默认模式 a+ 表示打开一个文件用于追加，如果该文件已经存在，文件指针会放在文件的结尾，新的内容会写入到现有内容以后，如果该文件不存在，创建新文件进行写入 with open() 因为 open 打开文件会产生 io 问题，文件不存在会抛出 IOError 错误，所以一般会使用 try finally 确保文件正确关闭。但是这样写比较麻烦，所以 python 引入了 with open 自动调用 close() 方法 123456try: f = open('/path/to/file', 'r') print(f.read())finally: if f: f.close() 使用 with open 12with open('/path/to/file', 'r') as file: print(file.read) 如果路径需要转义可以在路径前加 r，表示转义如 with open(r&#39;E\work\path\test.txt&#39;,&#39;a+&#39;) as file: python 文件读写 python with open 标识符 strftime12import timethetime = time.strftime(format[, t]) %Y ：表示四位数的年份 %m ：月份 0-12 %d：月中的一天 0-31 time.strftime(%Y%m%d) 结果是 201907118 os.pathisExists = os.path.exists(path) 用于判断路径是否存在，存在则返回 true 不存在则返回 false python os.path() 模块 path.strip()语法： rm为要删除的字符序列，当rm为空时，默认删除空白符（包括’\n’, ‘\r’, ‘\t’, ‘ ‘) str.strip(rm)：删除字符串开头、结尾处，位于 rm删除序列的字符； str.lstrip(rm)：删除字符串开头处，位于 rm删除序列的字符； str.rstrip(rm)：删除字符串结尾处，位于 rm删除序列的字符。 python split() 函数]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springBootJK]]></title>
    <url>%2F2019%2F07%2F07%2FspringBootJK%2F</url>
    <content type="text"><![CDATA[SpringBoot使用 spring inilitializr 创建 springBoot 项目框架 选择 maven project – java – springboot 2.16 – group com.xxx.spring – artifact demo.springBoot – Dependencies (选择需要的功能如 spring web starter 用于启动 web 项目自带 tomcat 等插件，spring boot actuator 等) 选择完成后点击 generate the project ，下载压缩包到本地，解压后用 idea 打开 import maven 项目，等自动导入 maven 依赖完成后才会出现 src 目录 给代码添加注释 1234567891011121314@SpringBootApplication@RestControllerpublic class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class, args); &#125; @RequestMapping("hello") public String hello()&#123; return "hello spring"; &#125;&#125; @RestController 可以直接将其视为 controller，@RequestMapping(“hello”) 就是一个拦截器名，运行该项目，利用 idea 自带 terminal 进行 curl http://localhost:8080/hello 即可访问到该项目，输出 hello spring 使用 mvn clean package -Dmaven.test.skip 打包项目，cd target 跳转到编译完的目录下，dir （window）或 ls （mac）查看目录，发现编译包有两个一个比较大，含有所有依赖，是可执行 jar 包；一个较小，只有代码 2019/07/07 17:43 18,309,095 demo.springBoot-0.0.1-SNAPSHOT.jar 2019/07/07 17:37 3,094 demo.springBoot-0.0.1-SNAPSHOT.jar.original 停止运行的程序，使用 java -jar demo.springBoot-0.0.1-SNAPSHOT.jar 也可以产生运行的效果，左上 绿色 + 号新开一个 teminal ，使用 curl http://localhost:8080/hello 依然能输出 hello spring 的效果 spring 常用注解java Config 相关注解@Configuration用于定义配置类，可替换xml配置文件 在@configuration中引入其它注解配置 @ImportSource 12@Configuration@ImportResource(&quot;classpath:applicationContext-configuration.xml&quot;) @ComponentScan 用于告诉 spring 容器可以扫描哪些 package 下的 bean 等配置 @Bean 标注的方法，它的返回能存在于 applicationContext 中 @RestController = @Controller+@ResponseBody @Autowired 在上下文中按类型查找注入 @Qualifier 上下文中有多个同类型的 bean 时，为了防止歧义，配合使用 Qualifier 指定 bean 的名字，根据名字注入 @Resource 直接使用名字注入 @Value 在 bean 中注入常量，spe 的表达式，配置方面的东西 lombok 注释@Builder @Data @Get @Set @ToString @NoArgsConstructor –空构造方法 @AllArgsConstructor –所有参数的构造方法 12@Type(type= "org.jadira.usertype.moneyandcurrency.joda.PersistentMoneyAmount", parameters = &#123;@org.hibernate.annotations.Parameter(name="currencyCode",value="CNY")&#125;) PersistentMoneyAmount 的输出类型为 decimal 1234567create table t_menu ( id bigint not null, create_time timestamp, price decimal(19,2), update_time timestamp, primary key (id) ) PersistentMoneyMinorAmount 的输出类型为 bigint 1234567create table t_menu ( id bigint not null, create_time timestamp, price bigint, update_time timestamp, primary key (id) ) Q&amp;AQ：运行spring boot 显示 No identifier specified for entity A：没有在 bean 上注释 @Entity 或者没有 @MappedSuperclass 找不到 bean 的实例，如果使用 @Entity hibernate 会错误的认为所有的Entity都是在一张数据表中的。 如下将继承 base bean 的数据字段全部放在 base_entity 中，不过 join 的表还是会被创建 Hibernate: drop table base_entity if exists Hibernate: drop table t_order_coffee if exists Hibernate: create table base_entity ( dtype varchar(31) not null, id bigint generated by default as identity, create_time timestamp, update_time timestamp, customer varchar(255), state integer not null, price bigint, primary key (id) ) Hibernate: create table t_order_coffee ( coffee_order_id bigint not null, items_id bigint not null ) Hibernate: alter table t_order_coffee add constraint FKj7y52vjqwbl1wptf9kopnkm54 foreign key (items_id) references base_entity Hibernate: alter table t_order_coffee add constraint FKr4nljvhowpwbciwa8xjs0h59y foreign key (coffee_order_id) references base_entity 使用 @MappedSupperclass 可以使继承该 bean 的子类创建多个表，能将各种继承 base bean 的表全部创建出来 Hibernate: drop table t_menu if exists Hibernate: drop table t_order if exists Hibernate: drop table t_order_coffee if exists Hibernate: create table t_menu ( id bigint generated by default as identity, create_time timestamp, update_time timestamp, price bigint, primary key (id) ) Hibernate: create table t_order ( id bigint generated by default as identity, create_time timestamp, update_time timestamp, customer varchar(255), state integer not null, primary key (id) ) Hibernate: create table t_order_coffee ( coffee_order_id bigint not null, items_id bigint not null ) Hibernate: alter table t_order_coffee add constraint FKj2swxd3y69u2tfvalju7sr07q foreign key (items_id) references t_menu Hibernate: alter table t_order_coffee add constraint FK33ucji9dx64fyog6g17blpx9v foreign key (coffee_order_id) references t_order 参考：https://blog.csdn.net/kunshan_shenbin/article/details/5516443]]></content>
      <tags>
        <tag>spring</tag>
        <tag>springBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springBoot_features_24.5]]></title>
    <url>%2F2019%2F07%2F07%2FspringBoot-features%2F</url>
    <content type="text"><![CDATA[24.5 Placeholders in Properties属性中的占位符 The values in application.properties are filtered through the existing Environment when they are used, so you can refer back to previously defined values (for example, from System properties). 属性文件中可以调用之前声明的属性 测试用例 main 函数： 123456789101112131415161718192021@SpringBootApplicationpublic class PropertyPlaceholderConfigurer &#123; //@Bean 标注在方法上(返回某个实例的方法)， //等价于 spring 的 xml 配置文件中的 &lt;bean&gt;，作用为：注册 bean 对象 @Bean DemoBean demoBean()&#123; return new DemoBean(); &#125; public static void main(String[] args) throws InterruptedException&#123; //创建对象后，返回 SpringApplication 对象 SpringApplication springBootDemo = new SpringApplication(PropertyPlaceholderConfigurer.class); ConfigurableApplicationContext context = springBootDemo.run(args); //获取 Bean DemoBean demoBean = context.getBean(DemoBean.class); //使用 Bean 的方法输出值 demoBean.showDemoTitle(); &#125;&#125; 测试用例 Bean 实体类: 12345678910public class DemoBean &#123; //从配置文件注入 demo.title 的值 @Value("$&#123;demo.title&#125;") private String demoTitle; //输出 demoTitle 的值 public void showDemoTitle()&#123; System.out.printf("Demo Result ----- %s ----- %n",demoTitle); &#125;&#125; 测试用例配置文件 123miku=2333# $&#123;&#125; 中的值可以在配置文件中定义，注入时直接能进行替换demo.title=SpringBoot $&#123;miku&#125; @project.parent.artifactId@ @project.version@ 测试1 mvn spring-boot:run 输出结果 Demo Result —– SpringBoot 2333 spring-boot-starter-parent 0.0.1-SNAPSHOT —– 结果中 ${miku} 被配置文件中的 miku = 2333 的值所替换了 而且 `@project.parent.artifactId@与@project.version@` 分别获得了maven 的 pom.xml 中的对应标签的值 1234567891011&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.6.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;&lt;/parent&gt;&lt;groupId&gt;com.nbcb.spring&lt;/groupId&gt;&lt;artifactId&gt;demo.springBoot.DateSource&lt;/artifactId&gt;&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;&lt;name&gt;demo.springBoot.DateSource&lt;/name&gt;&lt;description&gt;Demo project for Spring Boot&lt;/description&gt; 测试2 mvn spring-boot:run -Dmiku=no1 使用 D+字段的形式可以替换 ${} 所代表的值，使用命令的方式优先于使用配置文件的方式 依旧是上方的配置，但是输出结果为 Demo Result ----- SpringBoot no1 spring-boot-starter-parent 0.0.1-SNAPSHOT ----- 77.4 Use ‘Short’ Command Line Arguments Some people like to use (for example) --port=9000 instead of --server.port=9000 to set configuration properties on the command line. You can enable this behavior by using placeholders in application.properties, as shown in the following example: If you inherit from the spring-boot-starter-parent POM, the default filter token of the maven-resources-plugins has been changed from ${*} to @ (that is, `@maven.token@instead of${maven.token}) to prevent conflicts with Spring-style placeholders. If you have enabled Maven filtering for theapplication.properties` directly, you may want to also change the default filter token to use other delimiters. maven 继承了 spring-boot-starter-parent，并且 spring 的占位符也是 ${key}, 导致 mavenfilter 的占位符被 spring 的 maven pom 替换掉了，变成了 @maven.token@ In this specific case, the port binding works in a PaaS environment such as Heroku or Cloud Foundry. In those two platforms, the PORT environment variable is set automatically and Spring can bind to capitalized synonyms for Environment properties. 在这种特定情况下，端口绑定可在平台即服务环境（云计算服务，提供云计算平台与解决方案堆栈即服务）（如Heroku或Cloud Foundry）中运行。在这两个平台中，PORT环境变量自动设置，Spring可以绑定到环境属性的同义词。]]></content>
      <tags>
        <tag>spring</tag>
        <tag>springBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ssDeploy]]></title>
    <url>%2F2019%2F06%2F14%2FssDeploy%2F</url>
    <content type="text"><![CDATA[ss 搭建过程中的坑 debain 用 apt ，yunos 用 yum debain 系统的安装 unzip 安装问题 sudo ：apt-get：command not found – 不加 sudo ： 前缀 1apt-get update 1apt-get install zip 1apt-get install unzip 参考：https://www.luminanetworks.com/docs-lsc-610/Topics/SDN_Controller_Software_Installation_Guide/Appendix/Installing_Zip_and_Unzip_for_Ubuntu_1.html]]></content>
      <tags>
        <tag>ss</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[guankongMission]]></title>
    <url>%2F2019%2F05%2F21%2FguankongMission%2F</url>
    <content type="text"><![CDATA[nowrap 规定表中内容不换行 添加表格或其他文本出不来，先检查 &lt;tr&gt; &lt;td&gt;等标签是否封闭 json 字符串放在 “” 中需要对内部双引号使用 \ 转义,不能使用单引号，前端会无法识别 反射修改私有变量12345678910111213141516171819202122232425262728/** * 修改对象私有变量的值 * 为简洁代码，在方法上抛出总的异常 */private static void modifyPrivateFiled() throws Exception &#123; //1. 获取 Class 类实例 TestClass testClass = new TestClass(); Class mClass = testClass.getClass(); //2. 获取私有变量 Field privateField = mClass.getDeclaredField("MSG"); //3. 操作私有变量 if (privateField != null) &#123; //获取私有变量的访问权 privateField.setAccessible(true); //修改私有变量，并输出以测试 System.out.println("Before Modify：MSG = " + testClass.getMsg()); //调用 set(object , value) 修改变量的值 //privateField 是获取到的私有变量 //testClass 要操作的对象 //"Modified" 为要修改成的值 privateField.set(testClass, "Modified"); System.out.println("After Modify：MSG = " + testClass.getMsg()); &#125;&#125; 出处：https://juejin.im/post/598ea9116fb9a03c335a99a4 Q:bigDecimal cannot be cast to java.lang.StringA:使用 setBigDecimal() 替代 setString()]]></content>
      <tags>
        <tag>java</tag>
        <tag>ssh</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pyDay1]]></title>
    <url>%2F2019%2F04%2F18%2FpyDay1%2F</url>
    <content type="text"><![CDATA[UTF-8 与 Unicode UTF-8 Unicode Transformation Format 在计算机内存统一使用 Unicode 编码，当需要保存到硬盘或者需要传输的时候，就转换为 UTF-8 编码 记事本编辑时，从文件中读取的 UTF-8 字符被转换成 Unicode 字符到内存，编辑完成后，将 Unicode 转换成 UTF-8 保存到文件 浏览网页时，服务器会把动态生成的 Unicode 内容转换成 UTF-8 再传输到浏览器 JSP中pageEncoding和charset区别，中文乱码解决方案 将 abs 指向一个整数，就无法再调用原来的 abs 函数了，重启 python 交互环境，由于abs函数实际上是定义在import builtins模块中的，所以要让修改abs变量的指向在其它模块也生效，要用import builtins; builtins.abs = 10。]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DMP_deploy]]></title>
    <url>%2F2019%2F04%2F15%2FDMP-deploy%2F</url>
    <content type="text"><![CDATA[/home/edh 修改 tomcat 端口 &lt;Server port=&quot;9992(跟原端口有区分即可)&quot; shutdown=&quot;SHUTDOWN&quot;\&gt; &lt;Connector port=&quot;9026(跟原端口有区别即可)&quot; protocal=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; URIEncoding=&quot;UTF-8&quot;/\&gt; Server.xml 元素分类server.xml文件中的元素可以分为以下4类： （1）顶层元素：&lt;Server>和&lt;Service> &lt;Server>元素是整个配置文件的根元素，&lt;Service>元素则代表一个Engine元素以及一组与之相连的Connector元素。 （2）连接器：&lt;Connector> &lt;Connector>代表了外部客户端发送请求到特定Service的接口；同时也是外部客户端从特定Service接收响应的接口。 （3）容器：&lt;Engine>&lt;Host>&lt;Context> 容器的功能是处理Connector接收进来的请求，并产生相应的响应。Engine、Host和Context都是容器，但它们不是平行的关系，而是父子关系：Engine包含Host，Host包含Context。一个Engine组件可以处理Service中的所有请求，一个Host组件可以处理发向一个特定虚拟主机的所有请求，一个Context组件可以处理一个特定Web应用的所有请求。 （4）内嵌组件：可以内嵌到容器中的组件。实际上，Server、Service、Connector、Engine、Host和Context是最重要的最核心的Tomcat组件，其他组件都可以归为内嵌组件。 Server 元素的作用 Server 在元素的最顶层，代表 tomcat 容器，因此必须是 Server.xml 中唯一的一个外层元素，一个 Server 中可以包含多个 service 元素 Server 中 shutdown 端口的作用 shutdown 属性表示关闭 Server 的指令；port 属性表示 Server 接受 shutdown 指令的端口号，设为 -1 可以禁止掉该端口 Server 中 redirect 端口的作用 当用户用http请求某个资源，而该资源本身又被设置了必须要https方式访问，此时Tomcat会自动重定向到这个redirectPort设置的https端口。 Server 下 Service 的作用 Service 在 Connection 与 Engine 外包裹一层，将他们组装在一起，对外提供服务。一个 Service 可以包含多个 Connection 跟一个 Engine，Connection 用来接受客户端的请求，Engine 用来处理请求。Server 中可以只包含一个 Service ，名为 “Catalina”（名称没有限制），也可以包含多个 Service 来监听不同端口的请求 Service 下 Connector 的功能 Connection 的主要功能是接收连接请求，创建 Request 与 Response 对象用于和请求端交换数据，分配线程让 Engine 来处理这个请求，并把产生的 Request 与 Response 传递给 Engine Tomcat 监听 HTTP 请求一般用 8080 端口，而不是 80 端口（一般不将 Tomcat 直接对外开放请求，在 Tomcat 和客户端之间加一层代理服务器，如 nginx，用于请求转发、负载均衡、处理静态文件等） 配置第二个 Connector 客户端可以通过 8009 端口使用 AJP 协议访问 tomcat ，AJP 协议负责与其他 Http 服务器（如 Apache 与 IIS 等 HTTP 服务器）等集成，Tomcat 用作 Servlet/JSP 容器，处理动态资源，Apahe 等处理静态资源 Service 下的 Engine 组件 Engine 组件在 Service 中有且只有一个；Engine 是 Service 组件中的请求处理组件。Engine 组件从一个或多个 Connector 接收请求并处理，将完成的请求返回给 Connector ，最终传递给客户端 Engine、Host、Context 都是容器，它们是父子关系，Engine 包含 Host，Host 包含 Context Engine 配置 &lt;Engine name=&quot;Catalina&quot; defaultHost=&quot;localhost&quot;&gt; name 属性用于日志和错误信息，在整个 Server 中唯一。defaultHost 用于指定默认 host 名，当发往本机的 host 名不存在时，使用 defaultHost 指定的 host 进行处理，所以 defaultHost 指定的值必须与 Engine 中其中一个 Host 组件的 name 属性值匹配。 Engine 的子容器 Host Engine 中可以内嵌一个或多个 Host 组件，每个 Host 组件代表 Engine 中一个虚拟主机，Host 组件至少有一个，且其 name 与 defaultHost 属性相匹配。 host 虚拟主机，作用是运行多个 web 应用（一个 Context 代表一个 Web 应用），负责安装、展开、启动、结束每个 Web 应用 Host 组件代表一个虚拟主机，对应服务器的 IP 地址（192.168.0.128）或将 IP Context 元素 docBase 指定该 web 应用的 war 包路径，或应用目录。在自动部署时(配置文件位于xmlBase中)，docBase不在appBase目录中需要指定，如果 war 包在 docBase 中则不需要指定，如果指定会出错。 path 指定了上下文路径，请求到来时，Tomcat 会根据 Web 应用的 path 属性与 URI 的匹配程度选择 Web 应用的处理相应请求。如果请求时 /app1/index.html 则将其交由 “/app1” path 的 Web 应用处理，如果是 /app2/index.html 的请求，则交由 “/app2” 的 path 的 Web 应用处理，如果 path 属性为 “ “ ，那么用默认的 Web 应用处理 Tomcat 请求由谁处理 根据协议和端口号选定Service和Engine Service中的Connector组件可以接收特定端口的请求，因此，当Tomcat启动时，Service组件就会监听特定的端口。Catalina这个Service监听了8080端口（基于HTTP协议）和8009端口（基于AJP协议）。当请求进来时，Tomcat便可以根据协议和端口号选定处理请求的Service；Service一旦选定，Engine也就确定。 就是说 Service 中配置特定的 connector ，其端口就是用户可以访问到的端口 通过在Server中配置多个Service，可以实现通过不同的端口号来访问同一台机器上部署的不同应用。 根据域名或IP地址选定Host Service确定后，Tomcat在Service中寻找名称与域名/IP地址匹配的Host处理该请求。如果没有找到，则使用Engine中指定的defaultHost来处理该请求。在第一部分的例子中，由于只有一个Host（name属性为localhost），因此该Service/Engine的所有请求都交给该Host处理。 根据URI选定Context/Web应用 Tomcat根据应用的 path属性与URI的匹配程度来选择Web应用处理相应请求。 例 以请求http://localhost:8080/app1/index.html为例，首先通过协议和端口号（http和8080）选定Service；然后通过主机名（localhost）选定Host；然后通过uri（/app1/index.html）选定Web应用。 出处：详解 Tomcat 配置文件 server.xml linux 修改文件权限 chmodchmod的语法格式如下： chmod [who] [opt] [mode] 文件/目录名 其中who表示对象，是以下字母中的一个或组合： u：表示文件所有者g：表示同组用户o：表示其它用户a：表示所有用户 opt则是代表操作，可以为：+：添加某个权限-：取消某个权限=：赋予给定的权限，并取消原有的权限 而mode则代表权限：r：可读 w：可写 x：可执行 首先看第一个参数，目前我的需求是可以执行就行了，所以我让文件的拥有着，也就是root用户有可执行的权限就可以了，所以构造命令如下： chmod u 再看第二个参数，opt，很明显是加权限了，如下： chmod u + 再看第三个参数，这里是需要可执行的命令，也就是x，构造之后的命令如下： chmod u + x 最后加上文件名称： chmod u + x start-redis-cluster.sh https://blog.csdn.net/ksdb0468473/article/details/52150262 查询 java jdk 安装路径：which java –&gt;/usr/bin/java跳转到 usr/bin/ 查找 java，发现这是一个快捷方式，后有箭头指向 /etc/alternatives/java 跳转到 /etc/alternatives/ 在其目录下寻找对应 jre，jre 后有箭头指向目录 /user/lob/jvm/jre-1.7.0-openjdkx86 64 该目录就是需要的 jdk 路径 idea 启动 tomcat 显示 1099 地址已被占用Address localhost:1099 is aleady in use 使用 cmd 命令行查找 1099 端口的进程netstat -ano|findstr&quot;1099&quot; 发现进程 0.0.0.0:1099 6284 PID 为 6284 使用 taskkill -f -pid 6284 将其进程结束就行 为什么 tomcat 地址是 0.0.0.0:8080 因为这是 动态地址 ，本来本地 ip 应该是 127.0.0.1 但是这个 ip 是保留 ip ，无论外部 ip 是什么，系统都会保留这个 ip 识别。0.0.0.0 作为动态 ip 使用，上网后它会被外部 ip 替代 参考：ip 0.0.0.0 linux 下执行 window 中拷贝的 .sh shell 文件赋予权限后会报 python^M：bad interpreter:没有那个文件或目录的异常 其实IDE开发环境或者代码编辑器中都可以设置编程风格，在Linux下有最一般的修改方法，下面在Linux下修改： 方法一，执行如下命令： 1sed -i 's/^M//g' test.py 注意^M这个输入方法不是输入^再输入M，而是按住Ctrl+V快捷键，然后松开V，Ctrl不松，按M，按完之后^M就一并打好了，只有这个方法输入才是可以的，其他字符输入都一样 或者 用 vim 命令打开文件，底部模式下运行命令 ：set ff 或者 ：set fileformat 查看当前文件的换行标识，linux 返回的是 fileformat=unix，windows 换行返回的是 fileformat=dos 通过命令修改成 unix 风格的换行，使用 :set ff=unix 或者 :set fileformat=unix 回车后 wq 保存，如果要转成 window 风格将值改成 doc 即可。 参考：由于Windows和Linux行尾标识引起脚本无法运行的解决 DMP 页面无法登陆后台 tomcat 报错，tomcat:java.lang.OutOfMemoryError: PermGen space 临时重启 tomcat 可以解决 深入问题解决方法： Java 内存溢出（java.lang.OutOfMemoryError）的常见情况和处理方式总结 tomcat 启动无报错无法找到页面可能端口被修改过 查看 tomcat 进程 ps -aux | grep tomcat 使用命令查看 tomcat 端口号 sudo netstat -naop | grep 14177 Linux下Tomcat端口号以及进程相关命令 Q&amp;AQ:tomcat 启动报错：`Cannot find ./catalina.sh， The file is absent or does not have execute permission A:sh 文件没有运行没有权限 chmod +x /data/tomcat7/bin/*.sh或者chmod 755 /data/tomcat7/bin/*.sh 出处：https://blog.csdn.net/u012599988/article/details/44080673]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[oracle]]></title>
    <url>%2F2019%2F04%2F14%2Foracle%2F</url>
    <content type="text"><![CDATA[登录：（su - oracle） 密码认证 sqlplus scott/tiger@192.168.194.128/orcl sqlplus 显示命令不存在(可能使用了 su oracle 登录 oracle ，exit 后选择 su - oracle 登录) 主机认证（需要登录用户为管理员，计算机–管理本地用户和组–组–ora_dba 其中的成员都是数据库管理员） 如果不是数据库管理员登录会显示权限不足 管理员可以用 sqlplus / as sysdba 登录 / 前后用户密码任意，可以不填，登录用户都为 sys sql 与 sqlplus sql 命令不能缩写 select insert update delete sqlpuls 命令能缩写 desc（describe） ed（edit） c（change） for（format） col（column） oracle 包含空值的表达式为空 null 不等于 null，要用 is null 判断是否为 null 如果集合中含有空值 not in 不能加 null，in 中可以有 null select * from emp where deptno in (10,20,null)–可以 select * from emp where deptno not in (10,20,null)– 无法查询到值 || 用于连接字符串和查询内容 select ename||&#39;的薪水是&#39;||sal as 薪水 from emp dual 是一张特殊的表(伪表) select 3+2 as sum from dual select concat(&#39;hello&#39;,&#39; Wrold&#39;) from dual — 输出 hello World 过滤和排序oracle 大小写敏感，日期格式不敏感 select * from v$nls_parameters 这个表的字段表示了 oracle 的日期格式 alter session set NLS_DATE_FORMAT=&#39;yyyy-mm-dd&#39;; 将日期格式变为 2019-06-3 的格式 select * from emp where hiredate = &#39;2019-06-3&#39; 查询日期为当前日期的字段 恢复 oracle 默认字段 alter session set NLS_DATE_FORMAT=&#39;DD-MON-RR&#39; plsql 语句a number := 0; 等于 java 的 int a = 0 查询值（包含边界，大于等于，小于等于）在两个值之间，大小值不能换位置 select * from emp where sal between 1000 and 2000 查询以 A 开头名称的人 select * from emp where ename like &#39;A%&#39; 查询四个名称的人 select * from emp where ename like &#39;____&#39; 查询名字中带有 _ 的人,因为 \ % 在 oracle 中都为特殊含义的字符，所以需要用 escape 定义一个转义字符 select * from emp where ename like &#39;%\_%&#39; escape &#39;\&#39; order 排序order 作用于后面所有的列 order 排序，可以重新名字段，并根据字段排序，desc 逆序 order by 后可以加 列名、表达式、别名、序号 select empno,ename,sal,sal*12 年薪 from emp order by 年薪 desc; 4代表查询的第四个字段，所以就是按年薪排序，序号不能查询查询的列数 select empno,ename,sal,sal*12 年薪 from emp order by 4 desc; 双列排序查询，先按照第一列5降序排列，如果5相同，则按照4降序排列，desc 只作用于最相近的列，如果想多个降序，则放置多个 desc select empno,ename,sal,sal*12 年薪,deptno from emp order by 5 desc,4 desc; 因为 oralce 中默认空值最大，所以使用逆序排序时，字段为 null 的会在最前面，可以用 nulls last 将空值排序到最后 select * from emp order by comm desc nulls last; oracle sql 语句优化 尽量使用 列名 来代替 * 查询需要的字段 where 语句 解析顺序从右往左判断，and 将容易返回假的条件放右边，or 将容易返回真的放右边 如果 having 和 where（where 中不能使用多行函数） 都可以使用，尽量使用 where，where 是先过滤后分组，having 是先分组后过滤，where 效率较高。 尽量使用多表查询 尽量不使用集合运算 set timing on set timing off 显示关闭运行 sql 的时间 oracle 函数select upper(&#39;hello world&#39;) from dual转大写 lower 转小写 initcap 首字母大写 substr(a,b) – 从第一个字符串 a 中，从 b 位置开始取到最后 select substr(&#39;hello world&#39;,5) 子串 from dual; – o world length,lengthb – 取字符串或字节长度 select length(&#39;tokyo&#39;) 字符,lengthb(&#39;tokyo&#39;) from dual; – 4,4 select length(&#39;东京&#39;) 字符,lengthb(&#39;东京&#39;) 字节 from dual; – 2,4 instr – 返回字符串中某一个字符的位置，如果没有则为 0, select instr(‘hello world’,’ll’) 位置 from dual –3 select instr(‘hello world’,’hello’) 位置 from dual –1 lpad，rpad – 左填充，右填充 select lpad(&#39;ssss&#39;,20,&#39;*&#39;) 左,rpad(&#39;wwww&#39;,10,&#39;^&#39;) 右 from dual; select lpad(&#39;ssss&#39;,20,&#39;^w^&#39;) 左,rpad(&#39;wwww&#39;,10,&#39;^&#39;) 右 from dual; – ^w^^w^^w^^w^^w^^ssss – wwww^^^^^^ trim – 去掉前后字符串 select trim (&#39;h&#39; from &#39;hello worldh&#39;) from dual; – ello world replace – 替换指定字符串 select replace(&#39;hello world&#39;,&#39;world&#39;,&#39;sekai&#39;) from dual round – 四舍五入 select round(45.926,2) 一,round(45.926,1) 二,round(45.926,0) 三,round(45.926,-1) 四,round(45.926,-2) 五 from dual – 45.93–45.9–46–50–0 select sysdate from dual–查询当前系统时间 – 03-6月 -19 如果需要格式化时间，可以使用 to_char select to_char(sysdate,&#39;yyyy-mm-dd hh24:mi:ss&#39;) from dual 查询日期可以直接加减日 select (sysdate-1) 昨天,sysdate 今天,(sysdate+1)明天 from dual 日期间可以直接相减（根据当前年月时分秒减去另一个时间），不能直接相加 select ename,sysdate,hiredate,round((sysdate-hiredate),2) 天,round((sysdate-hiredate)/7,2) 星期, round((sysdate-hiredate)/30,2) 月,round((sysdate-hiredate)/365,2) 年 from emp; 计算两个日期间的月份差 months_between(sysdate,hiredate) 将一个日期加上53个月 select add_months(sysdate,53) from dual; 计算下个星期几 select next_day(sysdate,&#39;星期五&#39;) from dual 显示数据类型转换，将 num 类转换成金额 ￥999,999.99 的类型 select to_char(sal,&#39;L999,999.99&#39;) from emp 隐式数据类型转换，查询 222 跟 ‘222’ 都可查到值，因为 oracle 进行了隐式数据转换 如果直接相加，comm 为空时，整个计算值为空（null） select sal*12 + comm from emp 所以使用滤空函数，当 comm 为 null 时，返回 0，sal+comm 的值为 sal select sal*12+nvl2(comm,comm,0) from emp 如果 a=b ,返回 null，否则返回 a nullif(a,b) 用于从左往右返回查询字段中第一个不为空的值 (comm 不为空，返回 comm；comm 为空，sal 不为空则返回 sal，如果都为空，返回空 null） select comm,sal,coalesce(comm,sal) &quot;第一个不为 null 的值&quot; from emp case 表达式，类似于 java 中 if else select ename,job,sal 涨前, case job when &#39;PRESIDENT&#39; then sal+1000 when &#39;MANAGER&#39; then sal+800 else sal+400 end 涨后 from emp decode 函数作用与 case 一致 select ename,job,sal 涨前, decode(job,&#39;PRESIDENT&#39;,sal+1000, &#39;MANAGER&#39;,sal+800, sal+400) 涨后 from emp 根据个人工资跟 2000 取余，来判断税率,TRUNC 进行 select ename,sal, DECODE (TRUNC(sal/2000,0), 0,0.00, 1,0.09, 2,0.20, 3,0.30, 4,0.40, 5,0.42, 6,0.44, 0.45) TAX_RATE FROM emp WHERE deptno = 10; 多行函数取 count(*) 时会取到所有的 comm 值，count(comm) 跟 avg(comm) 会取到不为空的值 select sum(comm)/count(*) 一,sum(comm)/count(comm) 二,avg(comm) 三 from emp 取不重复的个数时，distinct 需要写在 () 中 select count(distinct deptno) from emp 包含在 select 列表中，未包含在组函数中的列必须包含在 group by 子句中 select deptno,count(ename) from emp – 报错ORA-00937: 不是单组分组函数 “not a single-group group function” 需要 select deptno,count(ename) from emp group by deptno; 先根据第一个列分组 deptno，如果第一个列相同，再根据第二个列分组 job select deptno,job,sum(sal) from emp group by deptno,job order by 1; where 和 having 的区别，where 内不能使用多行函数 多表查询连接条件的作用是避免使用两个表的笛卡尔积的全集，至少有 N-1 个连接条件，N 表示表的个数 等值连接 不等值连接 外连接：把某些不成立的记录，仍然包含在最后的结果中 左外连接，当条件不成立时，等号左边的表仍然被包含在最后的结果中 where e.deptno=d.deptno(+) 右外连接，当条件不成立时，等号右边的表仍然被包含在最后的结果中 自连接：通过一张表的多个别名，将一张表视为多张表 将一张员工表分为员工和老大表，进行自连接 select e.ename 员工姓名,b.ename 老大姓名 from emp e,emp b where e.mgr = b.empno 自连接不适合操作大表，得到的结果比较简明直观 自连接笛卡尔集至少是一张表的数据平方 层次查询–是单表查询，不会产生笛卡尔积，但是结果不直观 level 是伪列，用于层级查询看位于第几层的值， select level,empno,ename,mgr from emp connect by prior empno=mgr start with mgr is null order by 1 子查询 查询工资比30号部门所有员工高的员工信息 all:和集合中的所有值比较 select * from emp where sal &gt; (select max(sal) from emp where deptno=30) 或 select * from emp where sal &gt; all (select sal from emp where deptno=30) 查询工资比30号部门任意一个员工高的员工信息 any: 和集合中的任意一个值比较 select * from emp where sal &gt; any (select sal from emp where deptno=30); 或 select * from emp where sal &gt; (select min(sal) from emp where deptno=30); 单行空值问题 子查询为空时，主查询永远不等于空（空值不等于空） 多行子查询中的null where deptno in (10,50,null); 等价于where deptno=10 or deptno=50 or deptno=null deptno not in (10,50,null); 等价于where not (deptno=10 or deptno=50 or deptno=null) 集合运算集合运算的运算符 union - 获得两个表及表之间交集的部分一次 根据缺失的数据类型进行补充 select deptno,job,sum(sal) from emp group by deptno,job union select deptno,to_char(null),sum(sal) from emp group by deptno union select to_number(null),to_char(null),sum(sal) from emp intersect - 获得两个表之间的交集部分 select ename,sal from emp where sal between 700 and 1300 intersect select ename,sal from emp where sal between 1201 and 1400 minus - 获得第一个表的全部，减去和第二个表的交集部分 select ename,sal from emp where sal between 700 and 1300 minus select ename,sal from emp where sal between 1201 and 1400 处理数据DML(Data manipulation Language 数据操作语言)：select insert update delete DDL(Data Definition Language 数据定义语言)：create table ,alter table (修改表),truncate table ,drop table ​ create /drop view(视图) ,sequence(序列),index(索引),synonym(同义词) DCL(Data Controller Language 数据控制语言):grant(授权)，revoke(撤销权限) 地址符insert into emp(empno,ename,sal,deptno) values(&amp;empno,&amp;ename,&amp;sal,&amp;deptno) &amp; 后可以跟任何名称，但是一般与列名一致，使用了该语句后会让你进行对应值的输入，并且输入完成可以用 / 来重复调用该语句 去除碎片 alter table &lt;表名&gt; move; 数据导出后再导入 –&gt; 导出的文件为二进制的 dmp 文件 导出 exp（expdp） 导入 imp（impdp） delete和truncate的区别1、delete逐条删除；truncate先摧毁表 再重建22、（*）delete是DML truncate是DDL (可以回滚) （不可以回滚）3、delete不会释放空间 truncate会4、delete会产生碎片 truncate不会5、delete可以闪回(flashback) truncate不可以 truncate 在 oracle 中比 delete 慢 在 mysql 中比 delete 快 oracle 能 undo 数据（还原数据） oracle 中 delete 删除的数据能 rollback 也可以闪回 oracle 删除表空间及其数据文件删除前后可以查看磁盘所占用情况 df -hl 显示指定磁盘文件的可用空间。如果没有文件名被指定，则所有当前被挂载的文件系统的可用空间将被显示 -h 方便阅读方式显示 -H 等于“-h”，但是计算式，1K=1000，而不是1K=1024 -l 只显示本地文件系统 linux命令df中df -h和df -i的区别 //删除用户以及用户所有的对象 drop user username cascade; //删除表空间前提：删除表空间之前要确认该表空间没有被其他用户使用之后再做删除 drop tablespace tablename including contents and datafiles cascade onstraints; including contents 删除表空间中的内容，如果删除表空间之前表空间中有内容，而未加此参数，表空间删不掉，所以习惯性的加此参数including datafiles 删除表空间中的数据文件cascade constraints 同时删除tablespace中表的外键参照 你数据库版本是多少10G之前的我是无能为力，只能用非常笨重的方法，就是先EXP该表空间，然后删除重建，在IMP进去10GR2的话确认表空间有几个数据文件select file_name,file_id from dba_data_files where tablespace_name=’表空间名’确认表空间未被存储占用：select segment_name,file_id,blocks from dba_extents where file_id=表空间号;–表空间号（select file#,name from v$datafile; ）这么查如果是没有查询结果说明你可以做下面的操作了alter tablespace 表空间名 drop datafile ‘绝对路径‘ 清理表空间： 清空回收站：purge recyclebin – drop 表后可能还会在回收站，内存未释放，使用清理回收站命令 删除表并释放表空间：drop table \ purge; 删除表数据并释放表空间：truncate table \&lt;table_name&gt;; oracle 事务oracle 事务 起始标志：DML 语句 ，insert 与 update 是 DML 语句需要提交事务 结束标志：提交：显示提交（commit）/隐式提交：正常退出 DDL DCL 语句 （create table）将会提交这句前未提交的事务 回滚：显式回滚：rollback 隐式回滚：非正常退出 掉电 冗机 所以 DDL 语句是不可回滚的 oracle 支持 sql 99 的 不可重复读 和 串行化 ，另外还有一个只读 （read only） 练习题 rownum 只能按照默认的顺序生成 根据工资选出工资最高的三人 select rownum,empno,ename,sal from (select * from emp order by sal desc) where rownum &lt;= 3; 行号只能按照默认的顺序生成，如果使用排序，行号会跟着排序被打乱 如果要根据行号进行筛选，可以先进行一次子查询，再在外部进行筛选 如果在此语句进行 rownum 的 &gt;= 或 &gt; 判断，那么查询结果为空 rownum 只能使用 &lt; &lt;= 不能使用 &gt; &gt;= 使用 rownum 分页查询 5-8 行的数据 ERROR at line 5:ORA-00911: invalid character 如果在 sqlplus 的 edit 中进行修改语句，结尾加了 ; 会显示非法字符 先取出根据工资排序的全部员工，然后再其中查询员工的 rownum 号，可以使用 &lt;= 然后 &gt;= 需要在外层再进行使用，所以在外侧再嵌套一层查询语句 select * from (select rownum r,e1.* from (select * from emp order by sal) e1 where rownum&lt;=8) where r &gt;= 5 / 标准表、索引表、临时表临时表：当事务提交（commit）或会话（exit 退出 sql）结束时，表中的数据自动删除 临时表是根据事务或会话创建的表 查询所有工资大于平均工资的员工信息 select e.empno,e.ename,e.sal,d.avgsal from emp e,(select deptno,avg(sal) avgsal from emp group by deptno) d where e.deptno = d.deptno and e.sal &gt; d.avgsal select empno,ename,sal, (select avg(sal) from emp where deptno = e.deptno) avgsal from emp e where sal &gt; (select avg(sal) from emp where deptno = e.deptno) oracle 查询某个时间点的数据select * from 表名 as of timestamp to_timestamp(&#39;2012-7-5 17:00:10&#39;,&#39;YYYY-MM-DD HH24:MI:SS&#39;) 后可以加筛选条件 where …. 参考：https://chwshuang.iteye.com/blog/1578428 oracle 查询数据库操作记录 select t.SQL_TEXT, t.FIRST_LOAD_TIME from v$sqlarea t where t.FIRST_LOAD_TIME like &#39;2010-06-30%&#39; order by t.FIRST_LOAD_TIME desc 参考：https://blog.csdn.net/scgyus/article/details/79237024 行地址 rowid跟 rownum 一样是伪列。如果需要查询伪列的值，需要在查询语句中写出来 创建表创建一张表，导入从另一张表中查询到的数据 create table empinfo as select e.empno,e.ename,e.sal,e.sal*12 annsal,d.dname from emp e,dept d where e.deptno = d.deptno create table loginuser_bak as select * from loginuser_transer 修改表添加 photo 字段 alter table test1 add photo blob; 修改字段长度 alter table test1 modify tname varchar2(40); 删除 photo 字段 alter table test1 drop column photo; 重命名 tname 为 username alter table test1 rename column tname to username; 删除表查询所有表 select * from tab; 显示 TNAME TABTYPE CLUSTERID DEPT TABLEEMP TABLEBONUS TABLESALGRADE TABLETEST1 TABLEEMP20 TABLEEMPINFO TABLEEMP10 TABLETESTSAVEPOINT TABLEBIN$CHBIbAn4SZmBTjzBcs2+xQ==$0 TABLETESTDELETE TABLEBUFFERTEST1 TABLE drop table *** 删除表后会放到回收站 查询所有表显示 TNAME TABTYPE CLUSTERID DEPT TABLEEMP TABLEBONUS TABLESALGRADE TABLETEST1 TABLEEMP20 TABLEEMPINFO TABLEBIN$JOWGLe4TRn2tdBEYzcAF6g==$0 TABLEEMP10 TABLETESTSAVEPOINT TABLEBIN$CHBIbAn4SZmBTjzBcs2+xQ==$0 TABLEBUFFERTEST1 TABLE 多出一条乱码状数据 查看回收站 show recyclebin; 显示 ORIGINAL NAME RECYCLEBIN NAME OBJECT TYPE DROP TIME TESTDELETE BIN$JOWGLe4TRn2tdBEYzcAF6g==$0 TABLE 2019-06-27:19:31:29TESTDELETE BIN$CHBIbAn4SZmBTjzBcs2+xQ==$0 TABLE 2019-06-12:16:02:16 会有一条跟刚才乱码状代码一样的数据，就是刚才删除的数据 清空回收站 purge recyclebin; 继续查询回收站显示为空 回收站中的数据可以通过 select * from &quot;乱码状回收站表名&quot;; 查询出来 注意：管理员没有回收站 闪回可以恢复回收站的内容,恢复表 TESTSAVEPOINT flashback table TESTSAVEPOINT to before drop; 约束使用约束可以更好地保证数据的完整性 java 查询 oracle 的表结构因为出现 java 插入数据库异常： 分析原因： 字段名或者表名写错了 字段包含了oracle的关键字，把报错的字段用双引号括起来试试 使用如下方式查询 oracle 表结构，然后发现连错了数据库，测试数据库跟另一个数据库有同样的表，但是更改字段值更改了其中一个，导致报错 ora-00904 标识符无效 因为没有该字段却用了 insert 该字段导致 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package astar.sutil.db; import java.sql.Connection;import java.sql.DriverManager;import java.sql.PreparedStatement;import java.sql.ResultSetMetaData;import java.sql.SQLException;import java.util.ArrayList;import java.util.List; /** * @author 鲁炬**/public class DbMetaDataUtilTest &#123; public static void main(String[] args) throws SQLException, ClassNotFoundException &#123; String user = "user"; String password = "pwd"; String jdbcDriver = "com.ibm.db2.jcc.DB2Driver"; String jdbcUrl = "jdbc:db2://localhost:50000/DBNAME"; Connection conn = null; Class.forName(jdbcDriver); conn = DriverManager.getConnection(jdbcUrl, user, password); PreparedStatement pst = null; try &#123; pst = conn.prepareStatement("select * from t_table where 1=2"); ResultSetMetaData rsd = pst.executeQuery().getMetaData(); for(int i = 0; i &lt; rsd.getColumnCount(); i++) &#123; System.out.print("java类型："+rsd.getColumnClassName(i + 1)); System.out.print(" 数据库类型:"+rsd.getColumnTypeName(i + 1)); System.out.print(" 字段名称:"+rsd.getColumnName(i + 1)); System.out.print(" 字段长度:"+rsd.getColumnDisplaySize(i + 1)); System.out.println(); &#125; &#125; catch(SQLException e) &#123; throw new RuntimeException(e); &#125; finally &#123; try &#123; pst.close(); pst = null; &#125; catch(SQLException e) &#123; throw new RuntimeException(e); &#125; &#125; &#125; &#125; 出处：https://blog.csdn.net/rpg_marker/article/details/8204710 oracle 监听端口cd /etc cat hosts 可以看到当前 oracle 数据库服务器配置的 hosts 信息 cd $ORACLE_HOME more tnsnames.ora 可以查看对应的 tns 串 !lsnrctl status 可以查看监听的服务器地址 需要选择的 tns 串是该服务器所监听的服务器地址才可以访问该数据库 oracle 建表语句错误在一个用户下如果不小心使用了 create table “sss.table”() 的建表语句，oracle 不会把表建在 sss 这个用户下，而是当前用户下创建 “sss.table” 表，需要用 select * from “sss.table” 才能查询到该表，删除也是同样 oracle 查询归档日志是否打开select name,log_mode from v$database; 参考：http://www.worldwarner.com/m/view.php?aid=20107 执行 sql 脚本文件先登录sqlplus 然后在用 @全路径/文件名 SQL&gt;@/home/oracle/tmp.sql命令来执行sql脚本文件。 参考：https://blog.csdn.net/nvd11/article/details/8749322 insert 插入日期问题使用 to_date 转换格式 to_date(‘2007-12-28 10:07:24’ , ‘yyyy-mm-dd hh24:mi:ss’) 参考：jb51.net/article/51788.htm ORA-28000: the account is locked用户登录错误次数过多导致被锁用户 使用另外的用户登录该数据库，也可使用 sys/sys asdba 登录 &quot;SELECT RESOURCE_NAME, LIMIT FROM DBA_PROFILES WHERE RESOURCE_NAME = &#39;FAILED_LOGIN_ATTEMPTS&#39;; 查找登录信息，会有一个登录错误次数限制 使用命令 alter user xxx account unlock; 进行解锁，最后 commit 即可解锁 xxx 用户 参考：https://blog.csdn.net/Hello_World_QWP/article/details/78392129]]></content>
      <tags>
        <tag>database</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[e3mall_later]]></title>
    <url>%2F2019%2F03%2F22%2Fe3mall-later%2F</url>
    <content type="text"><![CDATA[zookeeper 在与 SolrCloud 搭配使用时，当做一个集群管理工具 zookeeper 在与 dubbo 搭配使用时，作为一个注册中心 solr 集群版与普通版配置 spring/applicationContext-solr.xml 123456789&lt;!--初始化一个 SolrServer--&gt; &lt;!--&lt;bean id="httpSolrServer" class="org.apache.solr.client.solrj.impl.HttpSolrServer"&gt;--&gt; &lt;!--&lt;constructor-arg index="0" value="http://192.168.25.128:8080/solr"/&gt;--&gt; &lt;!--&lt;/bean&gt;--&gt; &lt;!--集群版 solrServer--&gt; &lt;bean id="cloudSolrServer" class="org.apache.solr.client.solrj.impl.CloudSolrServer"&gt; &lt;constructor-arg name="zkHost" value="192.168.25.128:2181,192.168.25.128:2182,192.168.25.128:2183"/&gt; &lt;property name="defaultCollection" value="collection2"/&gt; &lt;/bean&gt; solr 查询 impl 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package cn.e3mall.search.service.impl;import cn.e3mall.common.pojo.SearchResult;import cn.e3mall.search.dao.SearchDao;import cn.e3mall.search.service.SearchService;import org.apache.solr.client.solrj.SolrQuery;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;@Servicepublic class SearchServiceImpl implements SearchService &#123; @Autowired private SearchDao searchDao; @Override public SearchResult search(String keyword, int page, int rows) throws Exception &#123; //创建一个 SolrQuery 对象 SolrQuery solrQuery = new SolrQuery(); //创建查询条件,keyword 为空时，查询到空字符串，没有结果 solrQuery.setQuery(keyword); //设置分页条件 if(page&lt;=0) page=1; solrQuery.setStart((page-1)*rows); solrQuery.setRows(rows); //设置默认搜索域 solrQuery.set("df","item_title"); //开启高亮显示 solrQuery.setHighlight(true); solrQuery.addHighlightField("item_title"); solrQuery.setHighlightSimplePre("&lt;em style='color:red'&gt;"); solrQuery.setHighlightSimplePost("&lt;/em&gt;"); //调用 dao 执行查询 SearchResult searchResult = searchDao.search(solrQuery); //计算总页数 long recourdCount = searchResult.getRecourdCount(); int totalPage = (int) (recourdCount/rows);// 如果除不尽，则总页数加1 if(recourdCount % rows&gt;0)&#123; totalPage++; &#125; searchResult.setTotalPages(totalPage); //返回结果 return searchResult; &#125;&#125; 商品搜索 dao 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package cn.e3mall.search.dao;import cn.e3mall.common.pojo.SearchItem;import cn.e3mall.common.pojo.SearchResult;import org.apache.solr.client.solrj.SolrQuery;import org.apache.solr.client.solrj.SolrServer;import org.apache.solr.client.solrj.response.QueryResponse;import org.apache.solr.common.SolrDocument;import org.apache.solr.common.SolrDocumentList;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Repository;import java.util.ArrayList;import java.util.List;import java.util.Map;/** * 商品搜索 dao * param 为查询条件 */@Repositorypublic class SearchDao &#123; @Autowired private SolrServer solrServer; public SearchResult search(SolrQuery query) throws Exception &#123; //根据 query 查询条件查询 QueryResponse queryResponse = solrServer.query(query); //取查询结果 SolrDocumentList solrDocumentList = queryResponse.getResults(); //取查询结果总记录数 long numFound = solrDocumentList.getNumFound(); SearchResult result = new SearchResult(); result.setRecourdCount(numFound); //取商品列表，取需要高亮显示的标题 Map&lt;String, Map&lt;String, List&lt;String&gt;&gt;&gt; highlighting = queryResponse.getHighlighting(); String itemTitle = ""; List&lt;SearchItem&gt; itemList = new ArrayList&lt;&gt;(); for (SolrDocument solrDocument : solrDocumentList) &#123; List&lt;String&gt; list = highlighting.get(solrDocument.get("id")).get("item_title"); SearchItem item = new SearchItem(); item.setId((String) solrDocument.get("id")); //取高亮显示 if(list!=null &amp;&amp; list.size()&gt;0)&#123; itemTitle = list.get(0); &#125;else&#123; itemTitle = (String) solrDocument.get("item_title"); &#125; item.setTitle(itemTitle); item.setSell_point((String) solrDocument.get("item_sell_point")); item.setPrice((Long) solrDocument.get("item_price")); item.setImage((String) solrDocument.get("item_image")); item.setCategory_name((String) solrDocument.get("item_category_name")); itemList.add(item); &#125; result.setItemList(itemList); //返回结果 return result; &#125;&#125; activeMQMQ 是一个消息中间件，流行的有 ActiveMQ（apache 旗下）、RabbitMQ、kafka（大数据用） 用于实现系统间通信，解耦 有点对点模式与发布/订阅模式 整合 spring 发送消息 123456789101112131415161718192021222324252627282930313233package cn.e3mall.activemq;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import org.springframework.jms.core.JmsTemplate;import org.springframework.jms.core.MessageCreator;import javax.jms.Destination;import javax.jms.JMSException;import javax.jms.Message;import javax.jms.Session;public class ActiveMqSpringTest &#123; @Test public void sendMessage() &#123;// 初始化 spring 容器 ApplicationContext applicationContext = new ClassPathXmlApplicationContext("classpath:spring/applicationContext-activemq.xml");// 从 spring 容器中获得 jmsTemplete 对象 JmsTemplate jmsTemplate = applicationContext.getBean(JmsTemplate.class);// 从容器中获得 Destination 对象 Destination destination = (Destination) applicationContext.getBean("queueDestination");// 发送消息 jmsTemplate.send(destination, new MessageCreator() &#123; @Override public Message createMessage(Session session) throws JMSException &#123; return session.createTextMessage("spring jmsTemplete message"); &#125; &#125;); &#125;&#125; applicationContext-activemq.xml 12345678910111213141516171819202122232425262728&lt;!-- 真正可以产生Connection的ConnectionFactory，由对应的 JMS服务厂商提供 --&gt;&lt;bean id="targetConnectionFactory" class="org.apache.activemq.ActiveMQConnectionFactory"&gt; &lt;property name="brokerURL" value="tcp://192.168.25.128:61616" /&gt;&lt;/bean&gt;&lt;!-- Spring用于管理真正的ConnectionFactory的ConnectionFactory --&gt;&lt;bean id="connectionFactory" class="org.springframework.jms.connection.SingleConnectionFactory"&gt; &lt;!-- 目标ConnectionFactory对应真实的可以产生JMS Connection的ConnectionFactory --&gt; &lt;property name="targetConnectionFactory" ref="targetConnectionFactory" /&gt;&lt;/bean&gt;&lt;!-- 配置生产者 --&gt;&lt;!-- Spring提供的JMS工具类，它可以进行消息发送、接收等 --&gt;&lt;bean id="jmsTemplate" class="org.springframework.jms.core.JmsTemplate"&gt; &lt;!-- 这个connectionFactory对应的是我们定义的Spring提供的那个ConnectionFactory对象 --&gt; &lt;property name="connectionFactory" ref="connectionFactory" /&gt;&lt;/bean&gt;&lt;!--这个是队列目的地，点对点的 --&gt;&lt;bean id="queueDestination" class="org.apache.activemq.command.ActiveMQQueue"&gt; &lt;constructor-arg&gt; &lt;value&gt;spring-queue&lt;/value&gt; &lt;/constructor-arg&gt;&lt;/bean&gt;&lt;!--这个是主题目的地，一对多的 --&gt;&lt;bean id="topicDestination" class="org.apache.activemq.command.ActiveMQTopic"&gt; &lt;constructor-arg value="topic" /&gt;&lt;/bean&gt; spring 整合 activemq 接受消息 12345678910public class MessageConsumer &#123; @Test public void msgConsumer() throws Exception&#123; //spirng 容器初始化 ClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext("classpath:spring/applicationContext-activemq.xml"); //等待 System.in.read(); &#125;&#125; 1234567891011121314151617181920212223242526272829303132&lt;!-- 真正可以产生Connection的ConnectionFactory，由对应的 JMS服务厂商提供 --&gt;&lt;bean id="targetConnectionFactory" class="org.apache.activemq.ActiveMQConnectionFactory"&gt; &lt;property name="brokerURL" value="tcp://192.168.25.128:61616" /&gt;&lt;/bean&gt;&lt;!-- Spring用于管理真正的ConnectionFactory的ConnectionFactory --&gt;&lt;bean id="connectionFactory" class="org.springframework.jms.connection.SingleConnectionFactory"&gt; &lt;!-- 目标ConnectionFactory对应真实的可以产生JMS Connection的ConnectionFactory --&gt; &lt;property name="targetConnectionFactory" ref="targetConnectionFactory" /&gt;&lt;/bean&gt;&lt;!--这个是队列目的地，点对点的 --&gt;&lt;bean id="queueDestination" class="org.apache.activemq.command.ActiveMQQueue"&gt; &lt;constructor-arg&gt; &lt;value&gt;spring-queue&lt;/value&gt; &lt;/constructor-arg&gt;&lt;/bean&gt;&lt;!--这个是主题目的地，一对多的 --&gt;&lt;bean id="topicDestination" class="org.apache.activemq.command.ActiveMQTopic"&gt; &lt;constructor-arg value="topic" /&gt;&lt;/bean&gt;&lt;!--将 cn.e3mall.search.message.MyMessageListener 注入到 spirng 配置监听器 --&gt;&lt;bean id="myMessageListener" class="cn.e3mall.search.message.MyMessageListener"/&gt;&lt;!-- 接收消息 --&gt;&lt;!-- 消息监听容器 --&gt;&lt;bean class="org.springframework.jms.listener.DefaultMessageListenerContainer"&gt; &lt;property name="connectionFactory" ref="connectionFactory" /&gt; &lt;property name="destination" ref="queueDestination" /&gt; &lt;property name="messageListener" ref="myMessageListener" /&gt;&lt;/bean&gt; 全局异常处理在 resource/conf 下配置文件 log4j.properties 1234567891011121314# INFO 指输出 INFO 级别，A3 指下面带有 log4j.appender.A3 等 A3 标志的全部类型，STDOUT 同理log4j.rootLogger=INFO,A3,STDOUT# ConsoleAppender 指输出到控制台log4j.appender.STDOUT=org.apache.log4j.ConsoleAppenderlog4j.appender.STDOUT.layout=org.apache.log4j.PatternLayoutlog4j.appender.STDOUT.layout.ConversionPattern=[%p] [%l] %10.10c - %m%n# RollingFileAppender 指循环输出到日志文件，文件路径与名 logs/server.log# MaxFileSize 指文件到达 1m 后新生成一个日志文件log4j.appender.A3=org.apache.log4j.RollingFileAppenderlog4j.appender.A3.file=logs/server.loglog4j.appender.A3.MaxFileSize=1024KBlog4j.appender.A3.MaxBackupIndex=10log4j.appender.A3.layout=org.apache.log4j.PatternLayoutlog4j.appender.A3.layout.ConversionPattern=\n\n[%-5p] %d&#123;yyyy-MM-dd HH\:mm\:ss,SSS&#125; method\:%l%n%m%n 在 springmvc.xml 配置读取配置文件 12在 contoller 中用 @Value("$&#123;properties.key&#125;") 注释一个私有变量 读取,这种配置文件只会生效一个--&gt;&lt;context:property-placeholder location="classpath:conf/*.properties" /&gt; 配置全局异常处理器 12&lt;!--全局异常处理器--&gt;&lt;bean class="cn.e3mall.search.exception.GlobalExceptionResolver"/&gt; 异常处理器类 12345678910111213141516171819202122232425262728package cn.e3mall.search.exception;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.web.servlet.HandlerExceptionResolver;import org.springframework.web.servlet.ModelAndView;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class GlobalExceptionResolver implements HandlerExceptionResolver &#123; private static final Logger logger = LoggerFactory.getLogger(GlobalExceptionResolver.class); @Override public ModelAndView resolveException(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) &#123; //打印到控制台 e.printStackTrace(); //写到日志 logger.debug("测试输出日志。。。。"); logger.info("系统异常。。。。"); logger.error("系统异常",e); //发邮件、短信 jmail 工具包发邮件，第三方 webService 发短信 //显示错误页面 ModelAndView modelAndView = new ModelAndView(); modelAndView.setViewName("error/exception"); return modelAndView; &#125;&#125; 添加 redis 缓存ItemServiceImpl 1234567891011121314151617181920212223242526272829303132333435363738394041424344@Autowired private JedisClient jedisClient; @Autowired private TbItemMapper itemMapper; @Value("$&#123;REDIS_KEY_PRE&#125;") private String REDIS_KEY_PRE; @Value("$&#123;ITEM_CACHE_EXPIRE&#125;") private Integer ITEM_CACHE_EXPIRE;@Override public TbItem getItemById(long itemId) &#123; //查询添加缓存不能影响普通查询 try &#123; //查询缓存 String s = jedisClient.get(REDIS_KEY_PRE + ":" + itemId + ":BASE"); if(StringUtils.isNotBlank(s))&#123; TbItem tbItem = JsonUtils.jsonToPojo(s, TbItem.class); return tbItem; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; //如果缓存为空，则查询数据库// 方法一：根据主键查询// TbItem tbItem = itemMapper.selectByPrimaryKey(itemId);// 方法二：设置查询条件查询 TbItemExample example = new TbItemExample();// 设置查询条件 example.createCriteria().andIdEqualTo(itemId);// 执行查询 List&lt;TbItem&gt; itemList = (List&lt;TbItem&gt;) itemMapper.selectByExample(example); if(itemList!=null &amp;&amp; itemList.size()&gt;0)&#123; //查询添加缓存不能影响普通查询 try &#123; //查询数据库后添加缓存 jedisClient.set(REDIS_KEY_PRE + ":" + itemId + ":BASE", JsonUtils.objectToJson(itemList.get(0))); jedisClient.expire(REDIS_KEY_PRE + ":" + itemId + ":BASE",ITEM_CACHE_EXPIRE); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; //返回查询结果 return itemList.get(0); &#125; return null; &#125; applicationContext-redis.xml 12345678&lt;!--配置 redis 单机版--&gt;&lt;bean id="jedisClientPool" class="cn.e3mall.common.jedis.JedisClientPool"&gt; &lt;property name="jedisPool" ref="jedisPool"/&gt;&lt;/bean&gt;&lt;bean id="jedisPool" class="redis.clients.jedis.JedisPool"&gt; &lt;constructor-arg name="host" value="192.168.25.128"/&gt; &lt;constructor-arg name="port" value="6379"/&gt;&lt;/bean&gt; resource.properties 1234#商品数据在缓存的 key 前缀REDIS_KEY_PRE=ITEM_INFO#商品数据在缓存的存储时间ITEM_CACHE_EXPIRE=3600 freemarker 静态页面的使用freemarker 测试类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package cn.e3mall.freemarker;import freemarker.template.Configuration;import freemarker.template.Template;import org.junit.Test;import java.io.File;import java.io.FileWriter;import java.io.Writer;import java.util.*;public class FreeMarkerTest &#123; @Test public void testFreeMarker() throws Exception&#123; //创建一个模板文件 //创建一个configuration 对象 Configuration cf = new Configuration(Configuration.getVersion()); //设置模板文件保存目录 cf.setDirectoryForTemplateLoading(new File("D:/masterSpring/trunk/e3-item-web/src/main/webapp/WEB-INF/ftl/")); //模板文件的编码格式 cf.setDefaultEncoding("utf-8"); //加载一个模板文件，创建一个模板对象// Template template = cf.getTemplate("hello.ftl"); Template template = cf.getTemplate("student.ftl"); //创建一个数据集，可以使 map 也可以使 pojo Map data = new HashMap&lt;&gt;(); data.put("hello","hello freemarker!"); //创建一个 Student 对象 Student student = new Student(1,"小明",18,"铜锣湾"); data.put("student",student); //添加一个 List List&lt;Student&gt; studentList = new ArrayList&lt;&gt;(); studentList.add(new Student(2,"孝宏",19,"霓虹")); studentList.add(new Student(3,"小黄",8,"常磐森林")); studentList.add(new Student(4,"小兰",10,"霓虹")); studentList.add(new Student(5,"小绿",10,"霓虹")); studentList.add(new Student(6,"傻东西",10,"玛莎拉通")); data.put("studentList",studentList); //添加日期类型 data.put("date",new Date()); //添加一个 null data.put("val","111"); //创建一个 writer 对象，指定输出文件的路径及文件名// Writer out = new FileWriter(new File("D:/upload/freemaker/hello.txt")); Writer out = new FileWriter(new File("D:/upload/freemaker/studentList.html")); //生成静态页面 template.process(data,out); //关闭流 out.close(); &#125;&#125; 模板对象类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;html&gt;&lt;head&gt; &lt;title&gt;学生对象&lt;/title&gt;&lt;/head&gt;&lt;body&gt;学生信息：&lt;br&gt;学号：$&#123;student.id&#125;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;姓名：$&#123;student.name&#125;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;年龄：$&#123;student.age&#125;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;家庭住址：$&#123;student.address&#125;&lt;br/&gt;&lt;table border="1"&gt; &lt;tr&gt; &lt;td&gt;序号&lt;/td&gt; &lt;td&gt;学号&lt;/td&gt; &lt;td&gt;姓名&lt;/td&gt; &lt;td&gt;年龄&lt;/td&gt; &lt;td&gt;家庭住址&lt;/td&gt; &lt;/tr&gt; &lt;#list studentList as stu&gt; &lt;#if stu_index % 2 == 0&gt; &lt;tr bgcolor="red"&gt; &lt;#else&gt; &lt;tr bgcolor="green"/&gt; &lt;/#if&gt; &lt;td&gt;$&#123;stu_index&#125;&lt;/td&gt; &lt;td&gt;$&#123;stu.id&#125;&lt;/td&gt; &lt;td&gt;$&#123;stu.name&#125;&lt;/td&gt; &lt;td&gt;$&#123;stu.age&#125;&lt;/td&gt; &lt;td&gt;$&#123;stu.address&#125;&lt;/td&gt; &lt;/tr&gt; &lt;/#list&gt;&lt;/table&gt;&lt;br&gt;&lt;#--可以使用 ?date,?time,?datetime,?string("parten")--&gt;&lt;#--当前日期：$&#123;date?datetime&#125;--&gt;当前日期：$&#123;date?string("yyyy-MM-dd hh:mm:ss")&#125;&lt;br&gt;null 值处理：$&#123;val!"val 为 null"&#125;&lt;br&gt;val 值判断：&lt;#if val??&gt; val 中有内容&lt;#else&gt; val 值为 null&lt;/#if&gt;&lt;br&gt;引用模板测试：&lt;br&gt;&lt;#include "hello.ftl"&gt;&lt;/body&gt;&lt;/html&gt; 单点登录系统集群环境下会出现用户多次登录的情况 解决方案： 配置 tomcat 集群，配置 tomcatSession 复制，此时因为广播 session ，节点数不能超过5个 使用 session 服务器，保存 session 信息，使每个节点处于无状态，需要模拟 session ，单点登录是使用 redis 模拟 session ，实现 session 统一管理（sso - single sign on 单点登录） window.onload 与 $(function()) 区别 购物车当 Long 与 Long 相比较时，因为是两个包装数据类型（是对象），所以 == 比较的是两个对象的内存地址，需要将其中一个装换成 long 才能进行 == 比较 1if(tbItem.getId() == itemId.longValue()) Q&amp;AQ:错误: 找不到或无法加载主类 org.apache.solr.cloud.ZkCLIA: yum install -y unzip zip 出处：https://blog.csdn.net/kzadmxz/article/details/75675239 Q:solr 集群开启后，只有一个 leaderA:tomcat/bin/catalina.sh 下另外三个 tomcat 配置错误 JAVA_OPTS=”-DzkHost=192.168.25.128:2181,192.168.25.128:2182,192.168.25.128:2183” Q:The type java.util.Map$Entry cannot be resolved. It is indirectly referenced from required .class filesA: IDE 的 jdk 版本过高，不要使用 1.8，改为 1.7 。 或者将 activemq 版本提高，使用 5.15X 版本 参考：https://www.cnblogs.com/sxdcgaq8080/p/7921449.html Q:IDEA 的 junit 无法在 System.in.read(); 的控制台输入内容A: 使用 main 函数调用测试函数替代 junit 参考：https://blog.csdn.net/weixin_40127127/article/details/78186002 Q: Destination 转换错误12345Error:(27, 20) java: 对于send(javax.print.attribute.standard.Destination,&lt;匿名org.springframework.jms.core.MessageCreator&gt;), 找不到合适的方法 方法 org.springframework.jms.core.JmsTemplate.send(javax.jms.Destination,org.springframework.jms.core.MessageCreator)不适用 (参数不匹配; javax.print.attribute.standard.Destination无法转换为javax.jms.Destination) 方法 org.springframework.jms.core.JmsTemplate.send(java.lang.String,org.springframework.jms.core.MessageCreator)不适用 (参数不匹配; javax.print.attribute.standard.Destination无法转换为java.lang.String) 错误选择转换 destination 的问题 12345//import 类型错误，需要 javax.jms.Destination import javax.print.attribute.standard.Destination;//从容器中获得 Destination 对象 Destination destination = (Destination) applicationContext.getBean("queueDestination"); Q:activemq 监听器异常，无法正常进入监听器Caused by: java.io.EOFException at java.io.DataInputStream.readInt(DataInputStream.java:392) at org.apache.activemq.openwire.OpenWireFormat.unmarshal(OpenWireFormat.java:258) at org.apache.activemq.transport.tcp.TcpTransport.readCommand(TcpTransport.java:221) at org.apache.activemq.transport.tcp.TcpTransport.doRun(TcpTransport.java:213) at org.apache.activemq.transport.tcp.TcpTransport.run(TcpTransport.java:196) … 1 more 连接不上 activemq，不算 bug ，重启项目解决 Q:spring 找不到 beanorg.springframework.beans.factory.BeanCreationException: Error creating bean with name ‘itemServiceImpl’: Injection of autowired dependencies failed; nested exception is org.springframework.beans.factory.BeanCreationException: Could not autowire field: private cn.e3mall.common.jedis.JedisClient cn.e3mall.service.impl.ItemServiceImpl.jedisClient; nested exception is org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of type [cn.e3mall.common.jedis.JedisClient] found for dependency: expected at least 1 bean which qualifies as autowire candidate for this dependency. Dependency annotations: {@org.springframework.beans.factory.annotation.Autowired(required=true)} at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessPropertyValues(AutowiredAnnotationBeanPostProcessor.java:334) A: SOA 架构不同的功能间配置文件需要重新配置，将 spring/applicationContext-redis.xml，拷贝一份到目标目录下 Q:nginx 打开 window 版错误A:由日志文件读到错误消息 nginx启动报错(1113: No mapping for the Unicode character exists in the target multi-byte code page) 经过查询发现是路径中含有中文 Q:nginx 网页中文乱码A: 在 conf/nginx.conf 中 server 中添加 charset=“utf-8”; 参考：https://blog.csdn.net/qq_35448976/article/details/79256873 Q:idea maven 文件改路径名后无法从 maven projects 管理移除原有空 moduleA:在 project structure 中 移除 module（不知是否必须），重新打开 module/重启 idea Q:idea 配置 maven 分布式架构时，依赖了 dao 却无法传递依赖A:从Idea中把项目删掉，手动删掉项目的.idea和.iml文件，当然也可以用命令删掉，重新导入项目，重新生成.idea和.iml文件。 但是我的问题是错误创建了一个 pom 文件（idea 在同目录下创建多个 maven module会报错，module 不会创建，但是 pom 文件会创建），删除错误的 pom，并且删除 module 重新导入 module 参考：https://blog.csdn.net/qq_38069453/article/details/78332992 Q:页面 找不到 js css在 springmvc.xml 配置资源映射不起作用，target 的生成文件夹中没有 css、js、images 等文件夹 1234&lt;!--资源映射--&gt;&lt;mvc:resources mapping=&quot;/css/&quot; location=&quot;/css/**&quot;/&gt;&lt;mvc:resources mapping=&quot;/js/&quot; location=&quot;/js/**&quot;/&gt;&lt;mvc:resources mapping=&quot;/images/&quot; location=&quot;/images/**&quot;/&gt; A:在 web.xml 配置过滤 url 12345678910111213141516&lt;servlet-mapping&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;url-pattern&gt;*.jpg&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;url-pattern&gt;*.js&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;url-pattern&gt;*.css&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;url-pattern&gt;*.html&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 来源：https://dushen.iteye.com/blog/2406913 Q:找不到依赖传递的方法12[ERROR] Failed to execute goal org.apache.maven.plugins:maven-compiler-plugin:3.2:compile (default-compile) on project e3-sso-web: Compilation failure: Compilation failure:[ERROR] /D:/masterSpring/trunk/e3-sso-web/src/main/java/cn/e3mall/sso/controller/LoginController.java:[3,30] 找不到符号 A:不小心在 common 下创建了 maven 的 module，删除了 pom 文件下的 modules 标签，而没有删除 &lt;packaging>pom&lt;/packaging>，所以运行 install 后其实是没有真正地将 jar 包放到 maven 仓库。删除 pom 即可 12345&lt;artifactId&gt;e3-common&lt;/artifactId&gt;&lt;packaging&gt;pom&lt;/packaging&gt;&lt;modules&gt; &lt;module&gt;../e3-item-web&lt;/module&gt;&lt;/modules&gt; Q:在修改页面的 location.href 的地址后，仍旧显示为旧地址1&lt;div class=&quot;pBtn&quot; id=&quot;cart-add-btn-sf&quot;&gt;&lt;a onclick=&quot;cartAdd($&#123;item.id&#125;, 0, 1, 0, 1, this);&quot;&gt;&lt;b&gt;&lt;/b&gt;加入购物车&lt;/a&gt;&lt;/div&gt; 123456function cartAdd(product_id,cart_type,opencity_id, flag,bs, obj, cfrom)&#123; //取购物车商品数量 var num = $(&quot;#number_&quot; + product_id).val(); //拼装url参数，做跳转 location.href=&quot;http://localhost:8091/cart/add/&quot;+product_id+&quot;.html?num=&quot; + num;&#125; A:因为页面设置了静态页面 freemarker 的 redis 缓存，将原来的页面保存在了浏览器中，所以只要将浏览器的缓存删除即可。谷歌浏览器 ctrl + shift + insert 快速删除缓存]]></content>
      <tags>
        <tag>java</tag>
        <tag>ssm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[e3mall]]></title>
    <url>%2F2019%2F03%2F08%2Fe3mall%2F</url>
    <content type="text"><![CDATA[e3mall简介分布式 需要按照功能点把系统拆分，拆分成独立的功能。单独为某一个节点添加服务器。需要系统之间配合才能完成整个业务逻辑。叫做分布式。 分布式架构：多个子系统相互协作才能完成业务流程。系统之间需要进行通信。 集群：同一个工程部署到多台服务器上。tomcat 集群节点数量服务能力会先上升后下降，因为节点间需要传递 session 数据要用到广播，随着节点增加，会在服务器间消耗过多带宽，从而下降服务能力，一般5个节点为佳。 分布式架构： 把系统按照模块拆分成多个子系统。 优点： 1、把模块拆分，使用接口通信，降低模块之间的耦合度。 2、把项目拆分成若干个子项目，不同的团队负责不同的子项目。 3、增加功能时只需要再增加一个子项目，调用其他系统的接口就可以。 4、可以灵活的进行分布式部署。 缺点： 1、系统之间交互需要使用远程通信，接口开发增加工作量。 2、各个模块有一些通用的业务逻辑无法共用。 SOA：Service Oriented Architecture面向服务的架构。也就是把工程拆分成服务层、表现层两个工程。服务层中包含业务逻辑，只需要对外提供服务即可。表现层只需要处理和页面的交互，业务逻辑都是调用服务层的服务来实现。 为什么互联网项目要实现单表查询？ 因为单表查询效率高 单表查询做 redis 缓存方便 数据库分库需要单表查询 web 层的 maven module 用 war 包的打包方式，为了把一个工程聚合在这个 war 包 parent 与 manager 用 pom（父工程必须为 pom） 其余 dao service interface pojo 默认 jar 包 该工程只有打包成 war 包的 web 层和聚合的 manager 能运行 运行时，推荐运行聚合工程 manager，因为 web 运行需要导入 manager 下其余 service、dao 等 jar 包模块，这些模块需要导入到本地仓库，而每一次修改这些模块都要重新导入到本地仓库 ssm 框架整合 创建数据库，导入数据库脚本 使用 mybatis 逆向工程生成 pojo 以及 mapper 接口及映射文件，并将其放到对应文件夹 整合 ssm Dao 层 ： Mybatis 配置文件：SqlMapConfig.xml 配置包别名，也可以不配置，但是文件必须存在，文件头必须保留 applicationContext-dao.xml：mybatis 整合 spring，，由 spring 创建数据库连接池，通过 spring 管理 sqlSessonFactory、mapper 代理对象（扫描包）。需要加入 mybatis 与 spring 的整合包 Service 层： applicationContext-service.xml ：所有 service 实现类都放到 spring 容器中管理，由 spring 管理事务 表现层： Springmvc 框架，由 springmvc 管理 controller springmvc 三大组件 配置 log4j parent 配置版本约束 123456&lt;!-- 日志处理 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;$&#123;slf4j.version&#125;&lt;/version&gt;&lt;/dependency&gt; web 中配置依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;&lt;/dependency&gt; web/resources/conf 中配置 log4j 配置文件 log4j.properties 123456789101112131415161718### set log levels ###log4j.rootLogger = DEBUG,Console,File### 输出到控制台 ###log4j.appender.Console=org.apache.log4j.ConsoleAppenderlog4j.appender.Console.Target=System.outlog4j.appender.Console.layout=org.apache.log4j.PatternLayoutlog4j.appender.Console.layout.ConversionPattern= %d&#123;ABSOLUTE&#125; %5p %c&#123;1&#125;:%L - %m%n### 输出到日志文件 ###log4j.appender.File=org.apache.log4j.RollingFileAppender log4j.appender.File.File=$&#123;project&#125;/WEB-INF/logs/app.loglog4j.appender.File.DatePattern=_yyyyMMdd&apos;.log&apos;log4j.appender.File.MaxFileSize=10MBlog4j.appender.File.Threshold=ALLlog4j.appender.File.layout=org.apache.log4j.PatternLayoutlog4j.appender.File.layout.ConversionPattern=[%p][%d&#123;yyyy-MM-dd HH\:mm\:ss,SSS&#125;][%c]%m%n web.xml 配置日志路径及监听器 12345678&lt;!--log4j 日志配置--&gt;&lt;context-param&gt; &lt;param-name&gt;log4jConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:conf/log4j.properties&lt;/param-value&gt;&lt;/context-param&gt;&lt;listener&gt; &lt;listener-class&gt;org.springframework.web.util.Log4jConfigListener&lt;/listener-class&gt;&lt;/listener&gt; 参考：解决log4j 警告信息的问题 Maven项目引入log4j的详细配置 Dubbo将框架分成 SOA 架构后，表现层和服务层将分离，同处一个等级。表现层要取得数据，需要调用服务，服务层则完全删除表现层的视图等，只剩业务逻辑。 如果将项目的表现层和服务层进行拆分，多个表现层能调用多个服务层的功能 表现层和服务层是不同的工程，实现一个查询功能涉及到两个系统间的通信，那么就需要 WebService 等服务调用的方式，但是 WebService 是基于 soap 协议，效率不高 可以使用 restful 形式的服务：http+json ,应用较多，但是如果应用跟服务过多，服务之间调用关系复杂，需要治疗服务 dubbo 可以实现 rpc 协议进行远程调用，直接使用 socket 通信（二进制传递对象）传输效率高 注册 Dubbo 使用 zookeeper 将 service 服务注册到 zookeerper ，然后用 web 层调用 dubbo 是一个管理服务后台，连接注册中心 zookeeper 后就能看到 service 和 web 的状态 MariaDB 是 Mysql 的一个分支，功能与 Mysql 一致 PageHelper 是 Mybatis 第三方分页插件，使用了 Mybatis 拦截器，在执行 sql 语句前拿到 sql 语句对其进行修改，加上 limit startPage，size 将 pagehelper 工程 install 成 jar 包，放到本地仓库，或者私服，然后用 service 引用（如果哪个工程要使用都可以用此方法） 发布服务 applicationContext-service.xml 123456789&lt;!-- 使用dubbo发布服务 --&gt;&lt;!-- 提供方应用信息，用于计算依赖关系 --&gt;&lt;dubbo:application name="e3-manager" /&gt;&lt;dubbo:registry protocol="zookeeper" address="192.168.171.128:2181" /&gt;&lt;!-- 用dubbo协议在20880端口暴露服务 --&gt;&lt;dubbo:protocol name="dubbo" port="20880" /&gt;&lt;!-- 声明需要暴露的服务接口 --&gt;&lt;dubbo:service interface="cn.e3mall.service.ItemService" ref="itemServiceImpl" /&gt; 引用服务 springmvc 12345&lt;!-- 引用dubbo服务 --&gt;&lt;dubbo:application name="e3-manager-web"/&gt;&lt;dubbo:registry protocol="zookeeper" address="192.168.171.128:2181"/&gt;&lt;!--timeout 设置请求服务超时时间单位毫秒 此处为10分钟--&gt;&lt;dubbo:reference interface="cn.e3mall.service.ItemService" id="itemService" timeout="600000"/&gt; SVN打开版本控制 SVN ：VSC–Enable Virsion control Itergation 将项目关联到 SVN ： import into Version control 提交：项目上右键，SubVersion–sharedirection–commit 从 SVN 项目下载：checkout from Virsion control ，选择下载到哪个目录 从 SVN 下载的项目没有 maven module 项目上右键 ，maven – Reimport 在一个 window 工程中打开多个 maven，在右边 maven 窗口点击绿色 + 号，选择另外几个 maven module 的 pom.xml 导入 配置忽略文件 https://blog.csdn.net/wangjun5159/article/details/74932433 js 页面index 单页面工程（将所有页面引入到 index.jsp 这个页面），在其中引入其他节点（只有 div 包裹的片段），将其加入 html，在单页面工程的父工程中引入了一个 js ，那么引入的其他节点片段也可以使用这个 js。 $(function(){ 页面加载完成执行的方法 }); 点击按钮弹出窗口的一个子节点后，关闭弹出窗口，并将选择节点内容添加到点击的按钮后 123456789101112onClick : function(node)&#123; if($(this).tree("isLeaf",node.target))&#123; // 填写到cid中 _ele.parent().find("[name=cid]").val(node.id); // 将内容填写到下一个 span 中 _ele.next().text(node.text).attr("cid",node.id); $(_win).window('close'); if(data &amp;&amp; data.fun)&#123; data.fun.call(this,node); &#125; &#125;&#125; NginxNginx是一款免费高性能的http 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器，官方测试 nginx 能够支支撑5万并发链接，并且 cpu、内存等资源消耗却非常低，运行非常稳定。 Nginx 应用 http服务器。Nginx是一个http服务可以独立提供http服务。可以做网页静态服务器。（图片、css、js、静态页面） 虚拟主机。可以实现在一台服务器虚拟出多个网站。例如个人网站使用的虚拟主机。（让多个网站共用8080 端口） 反向代理，负载均衡。当网站的访问量达到一定程度后，单台服务器不能满足用户的请求时，需要用多台服务器集群可以使用 nginx 做反向代理。并且多台服务器可以平均分担负载，不会因为某台服务器负载高宕机而某台服务器闲置的情况。（因为能支撑 5W 并发，所以先由它接受用户的访问请求，再平均分配给低并发的多个 tomcat） 查看含有 nginx 的进程 ps aux|grep nginx 查看 80 端口（用于查看某个端口是否被占用） netstat -anp|grep 80 启动 cd /usr/local/nginx/sbin/ ./nginx 停止 方式一，快速停止 cd /usr/local/nginx/sbin ./nginx -s stop 方式2，完整停止(建议使用)： cd /usr/local/nginx/sbin ./nginx -s quit 重启 方式1，先停止再启动（建议使用）： 对nginx进行重启相当于先停止nginx再启动nginx，即先执行停止命令再执行启动命令。 如下： ./nginx -s quit ./nginx 方式2，重新加载配置文件（在不关机情况下重新加载配置文件）： 当nginx的配置文件nginx.conf修改后，要想让配置生效需要重启nginx，使用-s reload不用先停止nginx再启动nginx即可将配置信息在nginx中生效，如下： ./nginx -s reload 反向代理正向代理：客户端上网 反向代理：服务端 反向代理服务器决定哪台服务器提供服务。 返回代理服务器不提供服务器。也是请求的转发。 proxy-pass 代理转发 nginx.conf 1234567891011121314151617181920212223242526272829303132333435upstream sina&#123; server 192.168.171.128:8080;&#125;server &#123; listen 80; server_name www.sina.com.cn; #charset koi8-r; #access_log logs/host.access.log main; location / &#123; proxy_pass http://sina; index index.html index.htm; &#125;&#125;upstream souhu&#123; server 192.168.171.128:8081;&#125;server &#123; listen 80; server_name www.souhu.com; #charset koi8-r; #access_log logs/host.access.log main; location / &#123; proxy_pass http://souhu; index index.html index.htm; &#125;&#125; 访问 www.sina.com.cn 时，会将请求转发给 upstream sina 的 server 地址 （server 192.168.171.128:8080） 当访问 www.souhu.com 时，会将请求转发给 upstream souhu 的 server 地址（ 192.168.171.128:8081） 请求访问的是 nginx，但它会把不同网址请求转发给各个 tomcat ，然后由 tomcat 给与响应 负载均衡指在反向代理基础上配置多个服务器，将同一网址请求随机发送给多个 tomcat，可以实现 tomcat 集群，但是 nginx 作为入口只能配置一个，不能多个同时使用，nginx 一个 ip 绑定一个域名，但是可以有 nginx 备份机，作为主机坏掉的备份。 实现高可用 两台nginx，一主一备：192.168.101.3和192.168.101.4 两台tomcat服务器：192.168.101.5、192.168.101.6 使用 keepalived 绑定主、备用 nginx 服务器，备用服务器的 keepalived 不停检测主服务器（nginx）心跳，如果主服务器挂了，将其虚拟 ip 绑定到备用机上。修复好主服务器后，继续将 ip 绑定到主服务器 1234upstream sina&#123; server 192.168.171.128:8080; server 192.168.171.128:8082;&#125; FastDFSTracker 群：向导（集群管理工具），类似于 dubbo 注册中心，记录 Storage 集群的状态，在客户端请求存储图片时，找 Tracker 来分配 ip 和端口号 Storage 集群：分多个组，组内部数据一致，用于备份，组内部有同步线程，组内能自动同步；组之间内容不一致，用于扩容 虚拟机网络配置： 桥接：虚拟机连接到电脑的网络（虚拟机跟电脑的网络一样，走的路由器或网线） host only 仅主机：只有虚拟机和主机间可以通信，虚拟机之间不能通信 NAT 模式：电脑和虚拟机可以通信，虚拟机之间也可以通信 文件上传在 E3.js 设置片段 12345678910var E3 = &#123; // 编辑器参数 kingEditorParams : &#123; //指定上传文件参数名称 filePostName : "uploadFile", //指定上传文件请求的url。 uploadJson : '/pic/upload', //上传类型，分别为image、flash、media、file dir : "image" &#125; url ：用来访问 servlet 返回页面数据 controller 返回信息： Contetent Type： application/json（json） text/plain（普通文本信息） @Response 是指不走逻辑视图，直接响应浏览器，类似调用 response.write() 将数据写回浏览器，但是如果返回的是对象，则转换成 json。 如果返回的是字符串，那么返回的值就是 text/plain,对于多图片上传的插件的浏览器兼容性会变好。 SEO 搜索引擎优化 12345&lt;servlet-mapping&gt; &lt;servlet-name&gt;e3-portal-web&lt;/servlet-name&gt; //伪静态化，将 url 后缀变成 html，但仍然是静态页面 &lt;url-pattern&gt;*.html&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; controller 指 Controller 类 Handler（处理器） 指 controller 中的方法，@RequestMapping（”/“） 处理器映射关系，指会被拦截到 handler 的路径 首页跳转：访问 url 路径：localhost：8080，先去找 web.xml 中的欢迎页配置，index.jsp 。发现 web 根目录没有该页面，去找 servlet，被前端控制器拦截（web.xml 配置 *.html 拦截），处理器配置 @RequestMapping(”/index“) 拦截 $(“#xxx”).tree({}); 初始化 tree，tree 中 {} 是一个 json 对象，包含了初始化的参数，{} 里的东西可以看做一个对象或变量 Service 服务需要以 war 包形式打包的原因是把几个模块打到一个 war 包，方便部署。其实 tomcat 只是初始化了一个 spring 容器，不做其他事情 可以自己写一个 main 方法，来进行 spring 容器的初始化，这样就不用 tomcat 也能发布 service 服务，但是需要自己手动打各种功能 jar 包，拷贝到同一目录下，用 main 方法进行批处理，加载所有 jar 包，然后启动类，所以使用 tomcat 比较方便 handler：function(){} 处理事件 Redis 存取redis 启动： ./redis-server 使用了 map 的方式，存放一个 key-value 形式的数据 key 计算一个 hash 值，放到一个特定位置，取值时再计算一次 hash 去特定位置取这个 value，不需要遍历，所以存取速度很快 redis 所有数据保存到内存，所以速度很快 存数据： key：str1，value：aaa set str1 aaa 将字符串 aaa 以 str1 的 key 存放到 redis 中 取数据： get str1 取出 key 为 str1 的值 加一： incr key1 如果 key1 不存在就创建，并赋值为1，如果是数字则执行 +1 decr key1 -1 操作 del key1 删除操作 redis 中都是以字符串保存的，+ - 操作中会将字符串变成整数，如果是真字符串则会无法转换 hash 操作 在 map 中保存 map hash1{ {filed1,1} {field2,2} } hset hash1 field1 1 hset hash1 field2 2 hset hash1 field3 3 hget hash1 field1 （获得 hash1 中 field1 的 hash 值） hkeys hash1 （获得所有 hash1 的 key 值） hvals hash1 （获得所有 hash1 的 value 值） hgetall hash1 （获得所有 hash1 的 key value 值） hdel hash1 field2 （删除 hash1 的 field2 值） list 操作 将 1 2 3 4 5 向左添加到队列，lrange 是从左开始遍历 list lpush list1 1 2 3 4 5 lrange list1 结果是：“5” “4” “3” “2” “1” rpush 向右添加到 list rpush list1 a b c d e 两次 push 后使用 lrange 结果是 “5” “4” “3” “2” “1” “a” “b” “c” “d” “e” lpop,rpop 从左、右弹出元素，取出的元素就不会存在于 list 中， lpop list1 结果是 “5”，并且将 “5” 从 list1 中去除 set 集合 sadd set1 a a b b c c c h 只会留下不重复的值 smembers set1 用来查询 set 中的值，结果为 a b c h srem set1 h 删除 set1 中的 h，结果为 a b c sdiff seta setb ，去除 seta 与 setb 重复的元素，保留 seta 的 sadd seta a b c d e sadd setb c d e f g sdiff seta setb 结果为 a b sdiff setb seta 结果为 g f （set 是无序的） sinter seta setb 结果为 d c e 取两者的交集 sunion seta setb 结果为 a b c d e f g 取两者综合，并去掉重复的 expire key 100设置 key 的保存时间，为 100 秒 ttl key 查询 key 的保存时间，如果有计数说明到时候就销毁，如果为 -1 则表示永久保存，如果 -2 为不存在，当倒计时到后，变为 -2。持久时间可以重复覆盖设置，persist key可以取消倒计时，让其变成永久保存状态 Redis 数据持久化方式RDB 形式，默认开启，默认 15 分钟内有一个 key 发生变化就持久化一次（从内存写到磁盘） 如果 5 分钟有 10 个 key 发生变化就持久化一次 如果 1 分钟有 10000 个 key 发生变化就持久化一次 save 900 1save 300 10save 60 10000 redis 可能会丢失数据，但效率高，一般用作缓存（可以容忍丢失数据），需要绝对不丢数据用关系型数据库 mysql 等 AOF 形式，默认不开启，如果 RDB 丢失数据可能较高，则开启这个 开启方式：appendonly：no 改为 yes 将查询的命令保存到一个文件中，如果要恢复数据库，则重新执行查询命令 每秒钟都会同步，写入磁盘，性能会降低，开启后恢复数据就用 aof Redis 集群Redis 集群最起码有 3 个节点，保证能够使用投票功能，每个节点需要一个备份机，所以需要 6 台服务器， 每个集群有16384（0-16383） 个槽 Redis 集群中内置了 16384 个哈希槽，当需要在 Redis 集群中放置一个 key-value 时，redis 先对 key 使用 crc16 算法算出一个结果，然后把结果对 16384 求余数，这样每个 key 都会对应一个编号在 0-16383 之间的哈希槽，redis 会根据节点数量大致均等的将哈希槽映射到不同的节点 redis 缓存策略模式 一个接口，多个实现类，可以进行实现类切换 在页面显示前查询缓存 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576package cn.e3mall.content.service.impl;import cn.e3mall.common.jedis.JedisClient;import cn.e3mall.common.utils.E3Result;import cn.e3mall.common.utils.JsonUtils;import cn.e3mall.content.service.ContentService;import cn.e3mall.mapper.TbContentMapper;import cn.e3mall.pojo.TbContent;import cn.e3mall.pojo.TbContentExample;import org.apache.commons.lang3.StringUtils;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Value;import org.springframework.stereotype.Service;import java.util.Date;import java.util.List;/** * 内容管理 Service */@Servicepublic class ContentServiceImpl implements ContentService &#123; @Autowired private TbContentMapper contentMapper; @Autowired private JedisClient jedisClient; @Value("$&#123;CONTENT_LIST&#125;") private String CONTENT_LIST; @Override public E3Result addContent(TbContent content) &#123; //补充 content 的日期 content.setCreated(new Date()); content.setUpdated(new Date()); contentMapper.insert(content); //缓存同步，删除缓存中对应的数据 jedisClient.hdel(CONTENT_LIST,content.getCategoryId().toString()); return E3Result.ok(); &#125; /** * 根据内容分类 id 查询内容列表 * @param cid * @return */ @Override public List&lt;TbContent&gt; getContentListByCid(long cid) &#123; //查询缓存, try&#123; //如果有缓存直接响应结果 String json = jedisClient.hget(CONTENT_LIST, cid + ""); if(StringUtils.isNotBlank(json))&#123; List&lt;TbContent&gt; contentList = JsonUtils.jsonToList(json, TbContent.class); return contentList; &#125; &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; //如果没有缓存查询数据库 TbContentExample example = new TbContentExample();// 设置查询条件 example.createCriteria().andCategoryIdEqualTo(cid);// 执行查询 List&lt;TbContent&gt; contentList = contentMapper.selectByExampleWithBLOBs(example); //把查询的结果添加到缓存，分出一个 CONTENT_LIST 的 hash 来存放 key、value 的值 try&#123; jedisClient.hset(CONTENT_LIST,cid + "", JsonUtils.objectToJson(contentList)); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; return contentList; &#125;&#125; solr 配置配置 solr Q&amp;AQ: 无法创建 maven moduleFailed to create a Maven project: ‘D:/masterSpring/e3-parent/e3-manager/pom.xml’ already exists in VFS A: 需要手动指定创建子目录，不然同一个目录下有两个 imi 文件就会报错 参考：https://blog.csdn.net/YangFanJ/article/details/73497803 Q：maven 运行 install 报错A: 当maven执行install:install出现如上错误时，则尝试改用install执行 出处：https://blog.csdn.net/qq_28345313/article/details/76855186 Q: ibasits.binding.bindingException找不到 mapper 方法和 pojo 类等错误 A: 一般都是这两类不在同一路径下，或者路径错误。我的问题是这两文件从逆向工程拷贝时，没有加 cn.e3mall 的路径前缀 Q:log4j:WARN No appenders could be found for loggerA:解决log4j 警告信息的问题 配置 web 中的 log4j 上下文路径以及监听器 Q: idea 创建 install maven 工程后访问 localhost:8080 网页无限转圈A:配置 log4j 后发现异常 Caused by: org.apache.ibatis.builder.BuilderException: Wrong namespace. Expected ‘cn.e3mall.mapper.TbOrderMapper’ but found ‘cn.e3mall.cn.e3mall.mapper.TbOrderMapper’. Caused by: org.apache.ibatis.builder.BuilderException: Wrong namespace. Expected ‘cn.e3mall.mapper.TbOrderMapper’ but found ‘cn.e3mall.cn.e3mall.mapper.TbOrderMapper’. 引入的 pojo mapper 逆向工程路径出了问题，使用 refactor 路径后出现的异常 Q:网页 404 The requested resource is not available.后台：00,323 WARN PageNotFound:1136 - No mapping found for HTTP request with URI [/item/562379] in DispatcherServlet with name ‘e3-manager’ 00,323 DEBUG RequestMappingHandlerMapping:328 - Did not find handler method for [/item/562379] 网页：The requested resource is not available. A:从 url 中取值方式 ${itemId} 多加了一个 $,去掉即可 1234567//url 模板映射，将 url 中的值取出来作为参数@RequestMapping(&quot;/item/&#123;itemId&#125;&quot;)@ResponseBodypublic TbItem getItemById(@PathVariable Long itemId)&#123; TbItem itemById = itemService.getItemById(itemId); return itemById;&#125; springmvc 处理器映射器 等的工作原理 https://stackoverflow.com/questions/41577234/why-does-spring-mvc-respond-with-a-404-and-report-no-mapping-found-for-http-req Q:tomcat linux 启动报错at net.sf.ehcache.store.disk.DiskStore.keySet(DiskStore.java:521) at net.sf.ehcache.store.disk.DiskStorageFactory$DiskExpiryTask.run(DiskStorageFactory.java:828) at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511) A:tomcat 报错端口被占用，jps 查看已启动的服务 [root@localhost bin]# jps2818 Bootstrap4516 Bootstrap 全部 kill 掉 [root@localhost bin]# kill -9 2818[root@localhost bin]# kill -9 4516 Q: 调用服务端分页方法警告三月 10, 2019 4:47:17 下午 com.alibaba.com.caucho.hessian.io.SerializerFactory getDeserializer警告: Hessian/Burlap: ‘com.github.pagehelper.Page’ is an unknown class in WebappClassLoader context: delegate: false repositories:———-&gt; Parent Classloader:ClassRealm[plugin&gt;org.apache.tomcat.maven:tomcat7-maven-plugin:2.2, parent: sun.misc.Launcher$AppClassLoader@b4aac2]:java.lang.ClassNotFoundException: com.github.pagehelper.Page A:服务端的 pagehelper 类下有一个 Page 类，Page 类继承了 ArrayList ，序列化后传到 web 层，web 层调用后将其转换成 ArrayList 但是它本质是个 Page，web 层没有该类，所以报出警告，如果要消除警告，在 web 层引入依赖 PageHelper Q: 控制层取 id 错误Controller [cn.e3mall.controller.ItemCatController]Method [public java.util.List&lt;cn.e3mall.common.EasyUITreeNode&gt; cn.e3mall.controller.ItemCatController.getItemCatList(java.lang.Long)] org.springframework.web.bind.MissingServletRequestParameterException: Required Long parameter ‘id’ is not present A:因为在一开始点击按钮时，页面不会传递 id 值，需要默认给一个参数 id =0 表示父节点。之后点击 tree 节点才会传递 id 过来 12// 防止形式参数与页面传入的参数名不同，设置别名 id，并且防止为空设置默认值 0public List&lt;EasyUITreeNode&gt; getItemCatList(@RequestParam(name="id",defaultValue="0") Long parentId)&#123; Q: nginx 重启 发生 var/run/nginx/nginx.pid no such file or directorynginx: [emerg] open() “/var/run/nginx/nginx.pid” failed (2: No such file or directory) A：nginx 启动需要创建该目录文件夹，不创建就会报错，mkdir /var/run/nginx 创建文件夹 Q:修改 host 无法生效A: 修改 host 需要重启浏览器才会释放之前的缓存 参考：https://blog.csdn.net/qq_33862644/article/details/76625557 Q:nginx 重启错误报错 nginx: [emerg] unknown directive “server:192.168.171.128:8080” in /usr/local/nginx/conf/nginx.conf:107 123upstream sina&#123; server:192.168.171.128:8080;&#125; 将 server 中间的冒号变为空格 Q:虚拟机启动图形界面错误 CentOS 6.5系统中安装了桌面环境（Gnome或KDE）后，发现桌面环境无法正常启动，出现如下错误提示： “You are currently trying to run as the root super user. The super user is a specialized account that is not designed to run a normal user session. Various progra?ms will not function properly, and actions performed under this account can cause unrecoverable damage to the operating system.” A:使用如下指令将相关服务设置为自动启动后，再重启系统即可： chkconfig –level 35 haldaemon on chkconfig –level 35 messagebus on 出处：https://linux.it.net.cn/m/view.php?aid=19360 Q:使用 E3Result 返回状态时无法刷新页面A:经查看页面返回状态 404，但是控制台返回的是 200 发现是没有加 @ResponseBody ，这样就会返回一个视图 http:xxxx/E3Result.jsp ，而不是一个表示状态的字符串 {“status”:200,”msg”:”OK”,”data”:null} Q:NoSuchBean 异常org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of type [cn.e3mall.service.ItemDescService] found for dependency: expected at least 1 bean which qualifies as autowire candidate for this dependency. Dependency annotations: {@org.springframework.beans.factory.annotation.Autowired(required=true)} A:在 applicationContext-service.xkml 发布服务后，没有在 springmvc.xml 引用服务 Q:Linux Tomcat 启动报错 ConnectExceptionCaused by: java.net.ConnectException: Connection refused at java.net.PlainSocketImpl.socketConnect(Native Method) at java.net.AbstractPlainSocketImpl.doConnect(AbstractPlainSocketImpl.java:339) at java.net.AbstractPlainSocketImpl.connectToAddress(AbstractPlainSocketImpl.java:200) at java.net.AbstractPlainSocketImpl.connect(AbstractPlainSocketImpl.java:182) at java.net.SocksSocketImpl.connect(SocksSocketImpl.java:392) at java.net.Socket.connect(Socket.java:579) at java.net.Socket.connect(Socket.java:528) at java.net.Socket.&lt;init>(Socket.java:425) at java.net.Socket.&lt;init>(Socket.java:241) at com.mysql.jdbc.StandardSocketFactory.connect(StandardSocketFactory.java:258) at com.mysql.jdbc.MysqlIO.&lt;init>(MysqlIO.java:305) … 19 more A:之前部署的一个无法连接到 mysql 导致的，删除该 tomcat/webapps 下的项目 Q：solr 启动报错HTTP Status 500 - {msg=SolrCore ‘collection1’ is not available due to init failure: Could not load conf for core collection1: Error loading solr config from /user/local/tomcat/webapps/solrhome/collection1/conf/solrconfig.xml,trace=org.apache.solr.common.SolrException: SolrCore ‘collection1’ is not available due to init failure: Could not load conf for core collection1: Error loading solr config from /user/local/tomcat/webapps/solrhome/collection1/conf/solrconfig.xml at A:solr 的配置文件配置错误 123456If you are getting above error it is mainly because of improper configuration in specified in tomcat6/webapps/solr/WEB-INF/web.xml&lt;env-entry&gt;&lt;env-entry-name&gt;solr/home&lt;/env-entry-name&gt;&lt;env-entry-value&gt;/home/solr&lt;/env-entry-value&gt; —–&gt; provide correct path to your solr installation&lt;env-entry-type&gt;java.lang.String&lt;/env-entry-type&gt;&lt;/env-entry&gt; 参考：https://pritisolanki.wordpress.com/tag/solrcore-collection1-is-not-available-due-to-init-failure/ Q: BindingExceptionorg.apache.ibatis.binding.BindingException: Invalid bound statement (not found): cn.e3mall.search.mapper.ItemMapper.getItemList A：在放置 dao、mapper 的 pom 文件下添加 xml 扫描 12345678910111213141516171819202122&lt;!-- 如果不添加此节点mybatis的mapper.xml文件都会被漏掉。 --&gt;&lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;cn.e3mall.search.mapper&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;!--在将默认的 resource 扫描地址也添加进去--&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt;&lt;/build&gt; Q:tomcat 启动 dubbo 无法访问tomcat 主页可以访问，访问 dubbo 失败 三月 18, 2019 11:47:31 下午 org.apache.catalina.loader.WebappClassLoader clearReferencesThreads严重: The web application [/dubbo-admin-2.5.4] appears to have started a thread named [DubboRegistryFailedRetryTimer-thread-1] but has failed to stop it. This is very likely to create a memory leak.三月 18, 2019 11:47:31 下午 org.apache.catalina.loader.WebappClassLoader clearReferencesThreads严重: The web application [/dubbo-admin-2.5.4] appears to have started a thread named [ZkClient-EventThread-17-127.0.0.1:2181] but has failed to stop it. This is very likely to create a memory leak.三月 18, 2019 11:47:31 下午 org.apache.catalina.loader.WebappClassLoader clearReferencesThreads严重: The web application [/dubbo-admin-2.5.4] appears to have started a thread named [localhost-startStop-1-SendThread(localhost:2181)] but has failed to stop it. This is very likely to create a memory leak.三月 18, 2019 11:47:31 下午 org.apache.catalina.loader.WebappClassLoader clearReferencesThreads严重: The web application [/dubbo-admin-2.5.4] appears to have started a thread named [localhost-startStop-1-EventThread] but has failed to stop it. This is very likely to create a memory leak. A:war 包名需要跟访问地址一致 Q:默认用户密码登录不了 dubboA:在 dubbo.properties 配置文件中修改用户密码，该文件在 dubbo 目录下 配置文件为dubbo.properties，配置如下 dubbo.registry.address=zookeeper://127.0.0.1:2182dubbo.admin.root.password=admin 参考：https://blog.csdn.net/lansedeshuyue/article/details/49911849 Q: mapper.xml 扫描不到org.apache.ibatis.binding.BindingException: Invalid bound statement (not found): cn.e3mall.search.mapper.ItemMapper.getItemList at org.apache.ibatis.binding.MapperMethod$SqlCommand.(MapperMethod.java:189) at org.apache.ibatis.binding.MapperMethod.(MapperMethod.java:43) at org.apache.ibatis.binding.MapperProxy.cachedMapperMethod(MapperProxy.java:58) at org.apache.ibatis.binding.MapperProxy.invoke(MapperProxy.java:51) at com.sun.proxy.$Proxy32.getItemList(Unknown Source) at cn.e3mall.service.impl.SearchItemServiceImpl.importAllItems(SearchItemServiceImpl.java:28) 1234567891011121314151617181920&lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java/cn/e3mall/search/mapper&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;!--在将默认的 resource 扫描地址也添加进去--&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt;&lt;/build&gt; 将 &lt;directory&gt;src/main/java/cn/e3mall/search/mapper&lt;/directory&gt;改为 &lt;directory&gt;src/main/java&lt;/directory&gt; Q：添加查询列表错误org.apache.solr.client.solrj.impl.HttpSolrServer$RemoteSolrException: Document is missing mandatory uniqueKey field: id A：添加字段时字段名错误 Q: redis 取不到线程池redis.clients.jedis.exceptions.JedisConnectionException: Could not get a resource from the pool at redis.clients.util.Pool.getResource(Pool.java:50) at redis.clients.jedis.JedisPool.getResource(JedisPool.java:86) at cn.e3mall.common.jedis.JedisClientPool.hget(JedisClientPool.java:76) at cn.e3mall.content.service.impl.ContentServiceImpl.getContentListByCid(ContentServiceImpl.java:53) A:没有开启 redis Q:HTTP Status 500 - Request processing failed1234org.springframework.web.util.NestedServletException: Request processing failed; nested exception is com.alibaba.dubbo.rpc.RpcException: Failed to invoke the method search in the service cn.e3mall.search.service.SearchService. Tried 3 times of the providers [192.168.25.1:20882] (1/1) from the registry 192.168.25.128:2181 on the consumer 192.168.25.1 using the dubbo version 2.5.3. Last error is: Failed to invoke remote method: search, provider: dubbo://192.168.25.1:20882/cn.e3mall.search.service.SearchService?anyhost=true&amp;application=e3-portal-web&amp;check=false&amp;dubbo=2.5.3&amp;interface=cn.e3mall.search.service.SearchService&amp;methods=search&amp;pid=213164&amp;revision=0.0.1-SNAPSHOT&amp;side=consumer&amp;timeout=600000&amp;timestamp=1553045729262, cause: Failed to send response: Response [id=6, version=2.0.0, status=20, event=false, error=null, result=RpcResult [result=cn.e3mall.common.pojo.SearchResult@1a289dc, exception=null]], cause: java.lang.RuntimeException: Serialized class cn.e3mall.common.pojo.SearchItem must implement java.io.Serializable Java field: private java.util.List cn.e3mall.common.pojo.SearchResult.itemListjava.lang.RuntimeException: Serialized class cn.e3mall.common.pojo.SearchItem must implement java.io.Serializable Java field: private java.util.List cn.e3mall.common.pojo.SearchResult.itemList A：Serialized class cn.e3mall.common.pojo.SearchItem must implement java.io.Serializable 该 pojo 需要实现序列化]]></content>
      <tags>
        <tag>java</tag>
        <tag>ssm</tag>
        <tag>javaweb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ssm]]></title>
    <url>%2F2019%2F03%2F01%2Fssm%2F</url>
    <content type="text"><![CDATA[MybatisMybatis 原身 Ibatis ，是 apache 的一个开源项目，2010 年迁移到谷歌，更名为 Mybatis，2013 年放到 github，ORM 架构。 原生 dao 缺陷 Dao方法体存在重复代码：通过SqlSessionFactory创建SqlSession，调用SqlSession的数据库操作方法 调用sqlSession的数据库操作方法需要指定statement的id，这里存在硬编码，不得于开发维护。 Mybatis 基础#{} select * from user where id = ? 占位符 ? == ‘字’ select * from user where id = #{v} ${} select * from user where username like ‘%字%’ 字符串拼接 select * from user where username like ‘%${value}%’ ‘%${value}%’ == “%”#{value}”%” 可以防止 sql 语句注入 Mapper 动态开发Mapper接口开发方法只需要程序员编写Mapper接口（相当于Dao接口），由Mybatis框架根据接口定义创建接口的动态代理对象，代理对象的方法体同上边Dao接口实现类方法。（实现类由系统自动生成） Mapper接口开发需要遵循以下规范： 1、 Mapper.xml文件中的namespace与mapper接口的类路径相同。 2、 Mapper接口方法名和Mapper.xml中定义的每个statement的id相同 3、 Mapper接口方法的输入参数类型和mapper.xml中定义的每个sql 的parameterType的类型相同 4、 Mapper接口方法的输出参数类型和mapper.xml中定义的每个sql的resultType的类型相同 创建 Mapper 接口 1234567891011//替代 UserDao 的动态代理开发接口public interface UserMapperDao &#123; //遵循四个原则 /** * 接口方法名与 Mapper.xml 中的 id 名一致 * 返回值类型与 Mapper.xml 文件中的返回值类型 resuletType 一致 * 入参类型与 Mapper.xml 的入参类型 parameterType 一致 * 将 Mapper.xml 命名空间 mapper.namespace 与该接口绑定 */ public User queryUserById(Integer id);&#125; 测试类 1234567891011121314151617181920212223public class MybatisMapperTest &#123; public SqlSessionFactory sqlSessionFactory; @Before public void before() throws IOException &#123; // 1. 创建SqlSessionFactoryBuilder对象 SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder(); // 2. 加载SqlMapConfig.xml配置文件 InputStream inputStream = Resources.getResourceAsStream("SqlMapConfig.xml"); // 3. 创建SqlSessionFactory对象 this.sqlSessionFactory = sqlSessionFactoryBuilder.build(inputStream); &#125; @Test public void testMapper()&#123;// 创建 sqlSession SqlSession sqlSession = sqlSessionFactory.openSession();// sqlSession 帮助生成实现类（给他一个接口，他会生成一个实现类） UserMapperDao userMapperDao = sqlSession.getMapper(UserMapperDao.class); User user = userMapperDao.queryUserById(27); System.out.println(user); &#125;&#125; User.xml 12345678910111213141516171819202122232425262728293031323334&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="cn.itcast.mybatis.mapper.UserMapperDao"&gt; &lt;!--值查询为 #&#123;aaa&#125; aaa 可以为任何值，只要 id 与方法第一个参数对应，入参 parameterType 与第二个参数类型对应即可--&gt; &lt;select id="queryUserById" parameterType="int" resultType="cn.itcast.mybatis.pojo.User"&gt; select * from User where id = #&#123;id&#125;; &lt;/select&gt; &lt;!--模糊查询的值只能为 value，id 与方法第一个参数对应，入参 parameterType 与第二个参数对应，返回值为 List&lt;User&gt; 但是只要写 User 即可，即返回一个泛型类型即可--&gt; &lt;!--'%$&#123;value&#125;' 用于字符串拼接，也可以用 "%"#&#123;&#125;"%" 方式，sql 语句中就是 "%"张"%" 形式的字符串拼接，使用这种 # 方式形参可以任意写，且可以防止 sql 注入--&gt; &lt;select id="queryUser" parameterType="String" resultType="cn.itcast.mybatis.pojo.User"&gt; select * from User where username like '%$&#123;value&#125;%'; &lt;/select&gt; &lt;!--增加用户，并返回自增长的 id 值--&gt; &lt;insert id="insertUser" parameterType="cn.itcast.mybatis.pojo.User"&gt; &lt;selectKey keyProperty="id" resultType="Integer" order="AFTER"&gt; select LAST_INSERT_ID(); &lt;/selectKey&gt; insert into user (username,sex,birthday,address) values (#&#123;username&#125;,#&#123;sex&#125;,#&#123;birthday&#125;,#&#123;address&#125;); &lt;/insert&gt; &lt;update id="updateUserById" parameterType="cn.itcast.mybatis.pojo.User"&gt; update user set username = #&#123;username&#125;,sex = #&#123;sex&#125;,birthday = #&#123;birthday&#125;,address = #&#123;address&#125; where id= $&#123;id&#125;; &lt;/update&gt; &lt;delete id="deleteUserById" parameterType="Integer"&gt; delete from user where id = #&#123;id&#125;; &lt;/delete&gt;&lt;/mapper&gt; 配置 SqlMapConfig.xml 文件一些属性123456789101112131415161718192021&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configurationPUBLIC "-//mybatis.org//DTD Config 3.0//EN""http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;!-- 和spring整合后 environments配置将废除 --&gt; &lt;environments default="development"&gt; &lt;environment id="development"&gt; &lt;!-- 使用jdbc事务管理 --&gt; &lt;transactionManager type="JDBC" /&gt; &lt;!-- 数据库连接池 --&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="com.mysql.jdbc.Driver" /&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/mybatis?characterEncoding=utf-8" /&gt; &lt;property name="username" value="root" /&gt; &lt;property name="password" value="root" /&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt;&lt;/configuration&gt; 根据返回值判断 sqlSession.selectOne() 还是 sqlSession.selectList() 123456789public interface UserMapper &#123; /** * 根据id查询 */ User queryUserById(int id); /** * 根据用户名查询用户 */ List&lt;User&gt; queryUserByUsername(String username); SqlMapConfig 的 properties 引入配置文件，键值对形式 &lt;properties resources=&quot;jdbc.properties&quot;/&gt; SqlMapConfig 自定义包名(别名) 用于简化 xml 的代码量 1234567891011121314151617181920212223242526272829303132333435&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;typeAliases&gt; &lt;!--单个命名别名--&gt; &lt;!--&lt;typeAlias alias="Orders" type="cn.itcast.mybatis.pojo.Orders" /&gt;--&gt; &lt;!-- 批量别名定义，扫描整个包下的类，别名为类名（大小写不敏感）--&gt; &lt;package name="cn.itcast.mybatis.pojo" /&gt; &lt;/typeAliases&gt; &lt;!-- 和spring整合后 environments配置将废除 --&gt; &lt;environments default="development"&gt; &lt;environment id="development"&gt; &lt;!-- 使用jdbc事务管理 --&gt; &lt;transactionManager type="JDBC" /&gt; &lt;!-- 数据库连接池 --&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="com.mysql.jdbc.Driver" /&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/mybatis?characterEncoding=utf-8" /&gt; &lt;property name="username" value="root" /&gt; &lt;property name="password" value="root" /&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 加载映射文件 --&gt; &lt;mappers&gt; &lt;mapper resource="cn/itcast/mybatis/sqlmap/User.xml"/&gt; &lt;mapper resource="cn/itcast/mybatis/sqlmap/OrderMapper.xml"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; SqlMapConfig 的 Mapper.xml 的位置，写 sql 语句的文件的位置 设置 resources 直接指定 Mapper.xml 的位置 class 引入写 IUserDao 接口，根据接口名称来找到 UserMapper.xml 此种方法要求mapper接口名称和mapper映射文件名称相同，且放在同一个目录中。 注册指定包下所有 mapper 接口 此种方法要求mapper接口名称和mapper映射文件名称相同，且放在同一个目录中。 如果用resources 与 class 每有一个 mapper 都需要配置一个 class 或 resources，所以一般用 package 方法 123456&lt;!-- 加载映射文件 --&gt; &lt;mappers&gt; &lt;mapper resource="sqlmap/User.xml" /&gt; &lt;mapper class="com.xxx.mapper.IUserDao.java"/&gt; &lt;package name="com.xxx.mybatis.mapper"/&gt; &lt;/mappers&gt; Mapper 及 POJO 包装类的使用Intellij IDEA生成serialVersionUID Mybatis使用ognl表达式解析对象字段的值，#{}或者${}括号中的值为pojo属性名称。 12345678910111213141516//替代 UserDao 的动态代理开发接口public interface UserMapperDao &#123; //遵循四个原则 /** * 接口方法名与 Mapper.xml 中的 id 名一致 * 返回值类型与 Mapper.xml 文件中的返回值类型 resuletType 一致 * 入参类型与 Mapper.xml 的入参类型 parameterType 一致 * 将 Mapper.xml 命名空间 mapper.namespace 与该接口绑定 */ public User queryUserById(Integer id); public List&lt;User&gt; findUserByQueryVo(QueryVo vo); /** * 查询所有数据条数 */ public Integer countUser();&#125; 创建 pojo 包装类包装 User 类 12345678910public class QueryVo implements Serializable&#123; private static final long serialVersionUID = 158137506017091245L; private User user; public User getUser() &#123; return user; &#125; public void setUser(User user) &#123; this.user = user; &#125;&#125; Mapper.xml 配置 sql 123456789101112131415&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="cn.itcast.mybatis.mapper.UserMapperDao"&gt;&lt;!--根据用户名模糊查询，入参为 pojo 包装类的 QueryVo，返回 pojo 的 User 类--&gt;&lt;select id="findUserByQueryVo" parameterType="cn.itcast.mybatis.pojo.QueryVo" resultType="cn.itcast.mybatis.pojo.User"&gt; select * from User where username like '%$&#123;user.username&#125;%';&lt;/select&gt;&lt;!--查询所有数据条数，没有入参--&gt;&lt;select id="countUser" resultType="Integer"&gt; select count(*) from user;&lt;/select&gt;&lt;/mapper&gt; 测试类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class MybatisMapperTest &#123; public SqlSessionFactory sqlSessionFactory;// 利用 before 在 test 前注入需要的 工厂 @Before public void before() throws IOException &#123; // 1. 创建SqlSessionFactoryBuilder对象 SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder(); // 2. 加载SqlMapConfig.xml配置文件 InputStream inputStream = Resources.getResourceAsStream("SqlMapConfig.xml"); // 3. 创建SqlSessionFactory对象 this.sqlSessionFactory = sqlSessionFactoryBuilder.build(inputStream); &#125; @Test public void testMapper()&#123;// 创建 sqlSession SqlSession sqlSession = sqlSessionFactory.openSession();// sqlSession 帮助生成实现类（给他一个接口，他会生成一个实现类） UserMapperDao userMapperDao = sqlSession.getMapper(UserMapperDao.class); User user = userMapperDao.queryUserById(27); System.out.println(user); &#125;// 根据用户名模糊查询 @Test public void TestQueryVo()&#123;// 创建 sqlSession SqlSession sqlSession = sqlSessionFactory.openSession();// sqlSession 帮助生成实现类（给他一个接口，他会生成一个实现类） UserMapperDao userMapperDao = sqlSession.getMapper(UserMapperDao.class); QueryVo vo = new QueryVo(new User("王")); List&lt;User&gt; list = userMapperDao.findUserByQueryVo(vo); for(User user : list) &#123; System.out.println(user); &#125; &#125;// &lt;!--查询所有数据条数--&gt; @Test public void TestQueryUserCount()&#123;// 创建 sqlSession SqlSession sqlSession = sqlSessionFactory.openSession();// sqlSession 帮助生成实现类（给他一个接口，他会生成一个实现类） UserMapperDao userMapperDao = sqlSession.getMapper(UserMapperDao.class); Integer count = userMapperDao.countUser(); System.out.println(count); &#125;&#125; resultMap 使用pojo 属性名 与 表的字段名 不一致时，使用 resultMap 来映射（一致时用 resultType，自动映射） mapper.xml 123456789101112131415&lt;mapper namespace="cn.itcast.mybatis.mapper.OrderMapper"&gt; &lt;!--&lt;select id="selectOrdersList" resultType="cn.itcast.mybatis.pojo.Orders"&gt;--&gt; &lt;!--将 pojo 中与数据库字段不同的字段进行 result 映射，resultMap 的 id 对应下面 select 中 resultMap 的值--&gt; &lt;!--type 为返回值 pojo--&gt; &lt;resultMap id="orders" type="cn.itcast.mybatis.pojo.Orders"&gt; &lt;result property="userId" column="user_id"/&gt; &lt;/resultMap&gt; &lt;select id="selectOrdersList" resultMap="orders"&gt; select * from orders; &lt;/select&gt;&lt;/mapper&gt; 动态 sql 的标签使用sql、whrere、if 1234567891011121314151617&lt;!--sql 标签用来截取一个 sql 片段，可以在其他标签中用 include 重复引用--&gt;&lt;sql id="selectF"&gt; select * from user&lt;/sql&gt;&lt;!--根据性别和姓名查询用户 where 标签用来去除第一个 前 and--&gt;&lt;select id="selectUserBySexAndUsername" parameterType="User" resultType="User"&gt; &lt;include refid="selectF"/&gt; &lt;where&gt; &lt;if test="sex!=null and sex!=''"&gt; sex = #&#123;sex&#125; &lt;/if&gt; &lt;if test="username!=null and username!=''"&gt; and username = #&#123;username&#125;; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; 根据多个 ID 查找多个用户 foreach 标签 mapper.xml 查询语句 12345678910&lt;!--根据多个 id 查询用户--&gt;&lt;select id="selectUserByIds" parameterType="queryVo" resultType="User"&gt; &lt;include refid="selectF"/&gt; &lt;where&gt; id in &lt;foreach collection="idsList" item="id" separator="," open="(" close=")"&gt; #&#123;id&#125; &lt;/foreach&gt; &lt;/where&gt;&lt;/select&gt; UserMapperDao public List&lt;User&gt; selectUserByIds(QueryVo vo); QueryVo 中生成 idsList 字段及 get set 属性 public List&lt;Integer&gt; idsList; 测试方法 12345678910111213141516@Testpublic void selectUserByIds()&#123; SqlSession sqlSession = sqlSessionFactory.openSession(); UserMapperDao userMapperDao = sqlSession.getMapper(UserMapperDao.class); List&lt;Integer&gt; ids = new ArrayList&lt;&gt;(); ids.add(1); ids.add(16); ids.add(27); ids.add(32); QueryVo vo = new QueryVo(); vo.setIdsList(ids); List&lt;User&gt; users = userMapperDao.selectUserByIds(vo); for(User u : users)&#123; System.out.println(u); &#125;&#125; 如果传入的是 QueryVo 包装类，那么用其中的一个集合或数组的属性名作为 collection 的值 如果传入的是 List 集合 或 [] 数组，那么 collection 值为 list 或 array 12345678910111213/** * 根据多个 id 查询用户 */ public List&lt;User&gt; selectUserByIdsList(List&lt;Integer&gt;ids); &lt;foreach collection=&quot;list&quot; item=&quot;id&quot; separator=&quot;,&quot; open=&quot;(&quot; close=&quot;)&quot;&gt; public List&lt;User&gt; selectUserByIdsArray(Integer[]ids); &lt;foreach collection=&quot;array&quot; item=&quot;id&quot; separator=&quot;,&quot; open=&quot;(&quot; close=&quot;)&quot;&gt; //内部封装了名为 idsList 的集合 public List&lt;User&gt; selectUserByIds(QueryVo vo); &lt;foreach collection=&quot;idsList&quot; item=&quot;id&quot; separator=&quot;,&quot; open=&quot;(&quot; close=&quot;)&quot;&gt; mapper.xml 123456789101112131415161718192021222324252627282930&lt;!--根据多个 id 查询用户 QueryVo--&gt;&lt;select id="selectUserByIds" parameterType="queryVo" resultType="User"&gt; &lt;include refid="selectF"/&gt; &lt;where&gt; id in &lt;foreach collection="idsList" item="id" separator="," open="(" close=")"&gt; #&#123;id&#125; &lt;/foreach&gt; &lt;/where&gt;&lt;/select&gt;&lt;!--根据多个 id 查询用户 Integer[]--&gt;&lt;select id="selectUserByIdsArray" parameterType="queryVo" resultType="User"&gt; &lt;include refid="selectF"/&gt; &lt;where&gt; id in &lt;foreach collection="array" item="id" separator="," open="(" close=")"&gt; #&#123;id&#125; &lt;/foreach&gt; &lt;/where&gt;&lt;/select&gt;&lt;!--根据多个 id 查询用户 Integer[]--&gt;&lt;select id="selectUserByIdsList" parameterType="queryVo" resultType="User"&gt; &lt;include refid="selectF"/&gt; &lt;where&gt; id in &lt;foreach collection="list" item="id" separator="," open="(" close=")"&gt; #&#123;id&#125; &lt;/foreach&gt; &lt;/where&gt;&lt;/select&gt; MapperDao 123456/** * 根据多个 id 查询用户 */public List&lt;User&gt; selectUserByIdsList(List&lt;Integer&gt;ids);public List&lt;User&gt; selectUserByIdsArray(Integer[]ids);public List&lt;User&gt; selectUserByIds(QueryVo vo); 测试方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/** * 根据多个 id 查询用户 queryVo 包装类 */ @Test public void selectUserByIds() &#123; SqlSession sqlSession = sqlSessionFactory.openSession(); UserMapperDao userMapperDao = sqlSession.getMapper(UserMapperDao.class);// public List&lt;User&gt; selectUserByIds(QueryVo vo);// QueryVo 中包含 List&lt;Integer&gt; List&lt;Integer&gt; ids = new ArrayList&lt;&gt;(); ids.add(1); ids.add(16); ids.add(27); ids.add(32); QueryVo vo = new QueryVo(); vo.setIdsList(ids); List&lt;User&gt; users = userMapperDao.selectUserByIds(vo); for(User u : users)&#123; System.out.println(u); &#125; &#125; /** * 根据多个 id 查询用户 Integer[] 数组 */ @Test public void selectUserByIdsArray()&#123; SqlSession sqlSession = sqlSessionFactory.openSession(); UserMapperDao userMapperDao = sqlSession.getMapper(UserMapperDao.class);// public List&lt;User&gt; selectUserByIdsArray(Integer[]ids);// Integer[] 数组类型 Integer[] ids = new Integer[]&#123;1,27&#125;;// ids[0]=1;// ids[1]=27;// ids[2]=32; List&lt;User&gt; users = userMapperDao.selectUserByIdsArray(ids); for(User u : users)&#123; System.out.println(u); &#125; &#125; /** * 根据多个 id 查询用户 List&lt;Integer&gt; 集合 */ @Test public void selectUserByIdsList()&#123; SqlSession sqlSession = sqlSessionFactory.openSession(); UserMapperDao userMapperDao = sqlSession.getMapper(UserMapperDao.class);// public List&lt;User&gt; selectUserByIdsList(List&lt;Integer&gt;ids);// List &lt;Integer&gt; 集合类型 List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(1); list.add(25); list.add(32); List&lt;User&gt; users = userMapperDao.selectUserByIdsList(list); for(User u : users)&#123; System.out.println(u); &#125; &#125; 一对一查询订单与用户是多对一关系， 但是以订单为中心，在内部关联一个用户对象，查询用户是一对一关系 一对一映射，多表查询时不能省略 resultMap 中的 result 字段关系映射 一对一查询 订单为中心 相对用户 一对一 Orders 对象（中加入用户 User 对象） 一对多关联 用户为中心 相对订单一对多 User 对象（中加入 List\&lt;Orders> 对象） mapper.xml 12345678910111213141516171819202122232425262728&lt;!--* 一对一关联查询,以订单为中心关联用户--&gt;&lt;!--public List&lt;Orders&gt; selectOrders();--&gt;&lt;resultMap id="order" type="Orders"&gt; &lt;!--在有多表查询时不能省略 result 属性关联--&gt; &lt;result column="id" property="id"/&gt; &lt;result column="number" property="number"/&gt; &lt;result column="createtime" property="createtime"/&gt; &lt;!--一对一映射标签--&gt; &lt;association property="user" javaType="User"&gt; &lt;id column="user_id" property="id"/&gt; &lt;result column="username" property="username"/&gt; &lt;/association&gt;&lt;/resultMap&gt;&lt;select id="selectOrders" resultMap="order"&gt; select o.id, o.user_id, o.number, o.createtime, u.username from orders o left join user u on o.user_id = u.id;&lt;/select&gt; mapper 1public List&lt;Orders&gt; selectOrders(); test 1234567891011121314/** * 一对一根据订单查询用户相关 */ @Test public void testOrderMapper()&#123;// 创建 sqlSession SqlSession sqlSession = sqlSessionFactory.openSession();// sqlSession 帮助生成实现类（给他一个接口，他会生成一个实现类） OrderMapper orderMapper = sqlSession.getMapper(OrderMapper.class); List&lt;Orders&gt; orders = orderMapper.selectOrders(); for (Orders order : orders) &#123; System.out.println(order); &#125; &#125; 一对多 12345678910111213141516171819202122232425&lt;!--* 一对多关联--&gt;&lt;!--public List&lt;User&gt; selectUserList();--&gt;&lt;resultMap id="user" type="User"&gt; &lt;id property="id" column="user_id"/&gt; &lt;result property="username" column="username"/&gt; &lt;!--一对多 User 中的 List&lt;Orders&gt; 集合--&gt; &lt;collection property="ordersList" ofType="Orders"&gt; &lt;id property="id" column="id"/&gt; &lt;result property="number" column="number"/&gt; &lt;/collection&gt;&lt;/resultMap&gt;&lt;select id="selectUserList" resultMap="user"&gt; select o.id oid, o.user_id, o.number, o.createtime, u.username from user u left join orders o on o.user_id = u.id;&lt;/select&gt; test 123456789101112131415/** * 一对多 */ @Test public void testUserList()&#123;// 创建 sqlSession SqlSession sqlSession = sqlSessionFactory.openSession();// sqlSession 帮助生成实现类（给他一个接口，他会生成一个实现类） OrderMapper orderMapper = sqlSession.getMapper(OrderMapper.class); List&lt;User&gt; users = orderMapper.selectUserList(); for (User user : users) &#123; System.out.println(user); &#125; &#125; Mybatis Spring 整合 准备工作 Spring 包 、Mybatis 包、Spring-Mybatis 整合包、数据库驱动包、连接池包、log4j 包 SqlMapConfig.xml 配置别名\&lt;typeAliases>、配置扫描 Mapper 下的 xml \&lt;Mappers> applicationContext.xml 配置文件、数据源、Mybatis 工厂（数据源，核心配置文件所在位置路径） 方式一：原始 dao 开发 手动实例化 Dao 在 impl 中 id ApplicationContext ac = new ApplicationContext(“applicationContext.xml”); ac.getBean(id); Dao 实现类继承 sqlSessionDaoSupport，该 Support 中有 setSqlSessionFactory 方法 调用时直接 this.getSqlSession.insert() 保存 SqlSession 方式二：Mapper 动态代理开发 创建接口 Mapper 文件 然后 Mybatis 会帮你生成实现类，本质还是实例化接口，不过是由 Mybatis 来写该实现类，所以可以减少代码量 注入接口、 接口所在类路径 方式三：Mapper 动态代理扫描（增强） 可以注入工厂也可以不注入，自己会去寻找 spring 实例化的工厂 bean 接口所在基本包，用来扫描基本包下的接口 application.xml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:context="http://www.springframework.org/schema/context" xmlns:p="http://www.springframework.org/schema/p" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.0.xsd"&gt; &lt;context:property-placeholder location="classpath:db.properties"/&gt; &lt;!-- 数据库连接池 --&gt; &lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt; &lt;property name="driverClassName" value="$&#123;jdbc.driver&#125;" /&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;" /&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;" /&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;" /&gt; &lt;property name="maxActive" value="10" /&gt; &lt;property name="maxIdle" value="5" /&gt; &lt;/bean&gt; &lt;!--Mybatis 工厂--&gt; &lt;bean id="sqlSessionFactoryBean" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;property name="dataSource" ref="dataSource"/&gt; &lt;!--核心配置文件的位置--&gt; &lt;property name="configLocation" value="classpath:sqlMapConfig.xml"/&gt; &lt;/bean&gt; &lt;!--方式一：dao 原始开发，实例化 dao--&gt; &lt;bean id="userDao" class="com.itcast.mybatis.dao.impl.UserDaoImpl"&gt; &lt;!--注入到 UserDaoImpl 的父类的 setSqlSessionFactory 方法中--&gt; &lt;property name="sqlSessionFactory" ref="sqlSessionFactoryBean"/&gt; &lt;/bean&gt; &lt;!--方式二：mybatis 动态代理开发--&gt; &lt;!--MapperFactoryBean 用来替代 getMapper 方法， 创建 mapper 的实现类需要提供一个 接口.class 以及 sqlSessionFactory，所以注入属性 方法：SqlSession sqlSession = sqlSessionFactory.openSession(); UserMapperDao userMapperDao = sqlSession.getMapper(UserMapperDao.class); 都在 MaperFactoryBean 中有所实现--&gt; &lt;!--&lt;bean id="userMapper" class="org.mybatis.spring.mapper.MapperFactoryBean"&gt;--&gt; &lt;!--&lt;property name="sqlSessionFactory" ref="sqlSessionFactoryBean"/&gt;--&gt; &lt;!--&lt;property name="mapperInterface" value="com.itcast.mybatis.mapper.UserMapper"/&gt;--&gt; &lt;!--&lt;/bean&gt;--&gt; &lt;!--方式三：动态代理开发增强版，扫描包,不需要注入 sqlSessionFactoryBean ，会自动去找 spring 中实例化的 sqlSessionFactory 只需要指定基本包，它就会去找包中及其子包中所有的接口来创建 Mapper 的实例，不需要 id 属性 普通的动态代理如果有多个 UserMapper 等接口，需要配置很多 interface--&gt; &lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;property name="basePackage" value="com.itcast.mybatis.mapper"/&gt; &lt;/bean&gt;&lt;/beans&gt; 第一种 dao 原始方法 创建 interface 并实现 dao daoImpl 12345678910111213141516171819202122232425262728package com.itcast.mybatis.dao.impl;import com.itcast.mybatis.dao.IUserDao;import org.mybatis.spring.support.SqlSessionDaoSupport;/** * 原始 dao 开发 */public class UserDaoImpl extends SqlSessionDaoSupport implements IUserDao &#123; /*通过 spring 在父类中 set 方法注入 sqlsession public void setSqlSessionFactory(SqlSessionFactory sqlSessionFactory) &#123; if (!this.externalSqlSession) &#123; this.sqlSession = new SqlSessionTemplate(sqlSessionFactory); &#125; &#125; 通过 get 方法获得 session public SqlSession getSqlSession() &#123; return this.sqlSession; &#125; */// 通过父类对象获得 sqlSession// public void insertUser()&#123;// this.getSqlSession().insert();// &#125;&#125; 动态代理开发 mapper 1234567package com.itcast.mybatis.mapper;import com.itcast.mybatis.pojo.User;public interface UserMapper &#123; public User queryUserById(Integer id);&#125; mapper.xml 12345678910111213&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="com.itcast.mybatis.mapper.UserMapper"&gt; &lt;!--值查询为 #&#123;aaa&#125; aaa 可以为任何值，只要 id 与方法第一个参数对应，入参 parameterType 与第二个参数类型对应即可--&gt; &lt;select id="queryUserById" parameterType="Integer" resultType="com.itcast.mybatis.pojo.User"&gt; select * from User where id = #&#123;id&#125;; &lt;/select&gt;&lt;/mapper&gt; sqlMapConfig.xml 123456789101112131415&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;!-- 设置别名 --&gt; &lt;typeAliases&gt; &lt;!-- 2. 指定扫描包，会把包内所有的类都设置别名，别名的名称就是类名，大小写不敏感 --&gt; &lt;package name="com.itcast.mybatis.pojo" /&gt; &lt;/typeAliases&gt; &lt;mappers&gt; &lt;package name="com.itcast.mybatis.mapper"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 动态代理方法（二、三）测试 12345678910111213141516171819package com.itcast.mybatis.mapper;import com.itcast.mybatis.pojo.User;import org.junit.Test;import org.springframework.context.support.ClassPathXmlApplicationContext;public class UserMapperTest &#123; @Test public void testMapper()&#123; ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext("applicationContext.xml");// 可以使用两种方法获得 userMapper// UserMapper mapper = context.getBean(UserMapper.class); UserMapper userMapper = (UserMapper) context.getBean("userMapper"); User user = userMapper.queryUserById(27); System.out.println(user); &#125;&#125; 逆向工程Dao 接口、Mapper POJO（返回值）、POJO Example（条件查询时放查询条件的对象） SpringMVCORM：Object Relational Mapping Springmvc 与 struts2 区别springmvc 是将变量绑在形参上；struts2 绑定在成员变量上 springmvc 是单例，单例指以方法为单位，每一个请求创建一个方法副本，让请求去访问该方法副本；struts2 是多例的，多例是指以类为单位，每一个请求创建一个类，让请求去访问方法 springmvc 存数据用 ModelAndView.addObject 底层是 request.setAttribute()，将数据放在 request 域中，参数解析器解析 request 请求中内容，并赋值给形参；而 struts 有一个值栈，将数据放在值栈中，通过 OGNL 存取数据 springmvc 入口是前端控制器（Servlet）；struts 入口是过滤器（Filter） springmvc 处理流程Springmvc 处理流程：【客户端】–用户请求–【前端控制器（dispatcherSerlvet）】–请求业务处理 –【处理器 （handler）】–返回处理结果–【前端控制器（dispatcherSerlvet）】–处理结果转发给 jsp – 【jsp 页面】– 返回 html 页面 –【前端控制器（dispatcherSerlvet）】– 响应用户–【客户端】 入门 springmvc 配置流程 创建 web 工程 导入 jar 包 在 web.xml 中配置前端控制器（指定上下文路径 classpath:springmvc.xml）拦截规则：/、/、\.action 在 springmvc.xml 配置扫描 @Controller 注解 书写 Action Controller Handler 处理器，类上添加注解 @Controller 书写方法，添加注解 @RequestMapping （value=请求路径）.action ，acion 可以省略 架构 一个中心：前端控制器 三大组件：处理器映射器、处理器适配器、视图解析器 由springmvc 提供 Handler 处理器、JSP 视图 由程序员编写 默认三大组件 默认的已废弃需要自己配置 RequestMappingHandlerMapping 处理器映射器 RequestMappingHandlerAdapter 处理器适配器 可以用 \mvc:annotation-driver/\ 替代以上两个配置 可以配置视图解析器 InternalResourceViewResolver 来简化代码前后缀 整合 Mybatis SqlMapConfig.xml 配置 mybatis 的核心配置文件（配置别名 typeAliases，可以将 pojo 包中类设置别名，不需要再书写完整路径；mappers 不需要再配置，因为 spring 的 appicationContext.xml 已经配置了MapperScannerConfigurer 来扫描 dao 下的基本包） 配置 spring applicationContext.xml 数据源 Druid; 读取 db.properties; Mybatis 的工厂；Mybatis Mapper 动态代理开发扫描方式； 基本包 创建 db.properties 事务、扫描 @Service、spring+mybatis 创建 springmvc.xml 三大组件 扫描基本包（com.itcast） 会扫描该包下所有 controller 和 service ，所以可以将第 4 步扫描 @Service 省略 web.xml 配置监听器，读取 applicationContext.xml 上下文；并配置前端控制器，读取 springmvc.xml ；配置 Post 提交乱码 Filtter 过滤器 参数绑定 默认参数绑定 Request Response Session Model ModelMap 是实现关系 简单类型参数绑定 方法的形参上绑定基本类型（Integer id，String，Double，Boolen,double） POJO 类型 Items items ，表单中需要 name 与 Items 对象中属性名一致 包装类型 QueryVo vo（包装 private Items items） 表单需要 items.username 自定义参数类型 在 springmvc 中配置转换器的工厂 Converters ， list set array&lt;bean class=自定义转换器类 创建自定义转换器类 实现 Converter\&lt;S,T> ；S 是页面传过来的类型，T 是转换后的类型 前端控制器一实例化就会去加载默认组件 spring-webmvc.jar 包，其下的 DispatcherServlet.properties 配置文件中配置了 HandlerMapping（处理器映射器）、HandlerAdapter（处理器适配器）、 spring mvc拦截器配置 / （真）全拦截；struts2 的 / 不拦截 css/jsp/js/png 等（不建议） spring mvc 拦截器 .action .do 拦截 action 与 do 后缀的请求，（用于 ERP、 进销存系统、） spring mvc 拦截器配置 / 全拦截，不拦截 jsp 页面，但是会拦截样式 css、js 等；struts2 的 /* 不拦截 jsp、css、js、png 等，对静态资源放行（建议使用，用于前台面向消费者） 静态资源放行 springmvc.xml 1234&lt;!--放行静态资源，放行 web 文件夹下的静态资源--&gt;&lt;mvc:resources location="/css/" mapping="/css/**"/&gt;&lt;mvc:resources location="/js/" mapping="/js/**"/&gt;&lt;mvc:resources location="/fonts/" mapping="/fonts/**"/&gt; 入门程序配置前端控制器 web.xml 1234567891011121314151617181920212223242526&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd" version="3.1"&gt; &lt;!--因为 springmvc 跟 spring 是无缝整合的，所以配置配置文件路径放在一起--&gt; &lt;!--&lt;context-param&gt;--&gt; &lt;!--&lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;--&gt; &lt;!--&lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt;--&gt; &lt;!--&lt;/context-param&gt;--&gt; &lt;!--前端控制器--&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;!--如果没有配置，默认找/WEB-INF/"servlet名称"-servlet.xml--&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;*.action&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 配置 springmvc.xml 开启 spring 注解扫描（将其配置到 web.xml 使其能进行用户请求的拦截，前端控制器是 springmvc 的入口，对应 sturts2 的 filter 过滤器） 12345678910111213141516171819&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p" xmlns:context="http://www.springframework.org/schema/context" xmlns:mvc="http://www.springframework.org/schema/mvc" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd"&gt; &lt;!--开启 spring 注释扫描，@Controller，@Service...--&gt; &lt;context:component-scan base-package="com.itcast"&gt;&lt;/context:component-scan&gt; &lt;!--实例化视图解析器--&gt; &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;!--可以不自己配置，但是配置后可以简化 controller 的 ViewName（统一前后缀）--&gt; &lt;property name="prefix" value="/WEB-INF/jsp/"/&gt; &lt;property name="suffix" value=".jsp"/&gt; &lt;/bean&gt;&lt;/beans&gt; 创建 controller 层或 handler 层 - springmvc（就是 web 层-servlet 或 action 层-struts2 ） 123456789101112131415161718192021/** * 商品管理 */@Controllerpublic class ItemController &#123; //页面访问该路径（localhost:8080+路径）即可访问到该 mav 所返回的页面 @RequestMapping(value="/item/itemlist.action") public ModelAndView itemList()&#123; // 创建页面需要显示的商品数据 List&lt;Items&gt; list = new ArrayList&lt;&gt;(); list.add(new Items(1, "1小米 RedMi3", 999f, new Date(), "牛逼！1")); 是springmvc 提供的对象，由 处理器（Handler） 处理请求后返回响应，再由前端控制器（DispatcherServlet）转发给 jsp 页面 ModelAndView mav = new ModelAndView(); mav.addObject("itemList",list); mav.setViewName("/WEB-INF/jsp/itemList.jsp"); return mav; &#125;&#125; ssm 整合web.xml 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd" version="3.1"&gt; &lt;!--因为 springmvc 跟 spring 是无缝整合的，所以配置配置文件路径放在一起--&gt; &lt;!--&lt;context-param&gt;--&gt; &lt;!--&lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;--&gt; &lt;!--&lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt;--&gt; &lt;!--&lt;/context-param&gt;--&gt; &lt;!--配置监听器读取配置文件--&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!--前端控制器--&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;!--如果没有配置，默认找/WEB-INF/"servlet名称"-servlet.xml--&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; applicationContext.xml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:context="http://www.springframework.org/schema/context" xmlns:p="http://www.springframework.org/schema/p" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.0.xsd"&gt; &lt;context:property-placeholder location="classpath:db.properties"/&gt; &lt;!-- 数据库连接池 --&gt; &lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt; &lt;property name="driverClassName" value="$&#123;jdbc.driver&#125;" /&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;" /&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;" /&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;" /&gt; &lt;property name="maxActive" value="10" /&gt; &lt;property name="maxIdle" value="5" /&gt; &lt;/bean&gt; &lt;!--Mybatis 工厂--&gt; &lt;bean id="sqlSessionFactoryBean" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;property name="dataSource" ref="dataSource"/&gt; &lt;!--核心配置文件的位置--&gt; &lt;property name="configLocation" value="classpath:sqlMapConfig.xml"/&gt; &lt;/bean&gt; &lt;!--方式三：动态代理开发增强版，扫描包,不需要注入 sqlSessionFactoryBean ，会自动去找 spring 中实例化的 sqlSessionFactory 只需要指定基本包，它就会去找包中及其子包中所有的接口来创建 Mapper 的实例，不需要 id 属性 普通的动态代理如果有多个 UserMapper 等接口，需要配置很多 interface--&gt; &lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;property name="basePackage" value="com.itcast.springmvc.dao"/&gt; &lt;/bean&gt; &lt;!--配置事务--&gt; &lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource"/&gt; &lt;/bean&gt; &lt;!--开启注解,给驱动提供事务管理器--&gt; &lt;tx:annotation-driven/&gt;&lt;/beans&gt; springmvc.xml 123456789101112131415161718192021222324252627&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p" xmlns:context="http://www.springframework.org/schema/context" xmlns:mvc="http://www.springframework.org/schema/mvc" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd"&gt; &lt;!--开启 spring 注释扫描，@Controller，@Service...--&gt; &lt;context:component-scan base-package="com.itcast"/&gt; &lt;!--配置处理器映射器--&gt; &lt;!--&lt;bean class="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping"/&gt;--&gt; &lt;!--配置处理器适配器--&gt; &lt;!--&lt;bean class="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter"/&gt;--&gt; &lt;!--注解驱动 相当于映射器加适配器--&gt; &lt;mvc:annotation-driven/&gt; &lt;!--实例化视图解析器--&gt; &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;!--可以不自己配置，但是配置后可以简化 controller 的 ViewName（统一前后缀）--&gt; &lt;property name="prefix" value="/WEB-INF/jsp/"/&gt; &lt;property name="suffix" value=".jsp"/&gt; &lt;/bean&gt;&lt;/beans&gt; sqlMapConfig.xml 12345678910111213141516&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;!-- 设置别名 --&gt; &lt;typeAliases&gt; &lt;!-- 2. 指定扫描包，会把包内所有的类都设置别名，别名的名称就是类名，大小写不敏感 --&gt; &lt;package name="com.itcast.springmvc.pojo" /&gt; &lt;/typeAliases&gt; &lt;!--在 spring 配置文件中 applicationContext.xml 中配置了扫描全部基本包--&gt; &lt;!--&lt;mappers&gt;--&gt; &lt;!--&lt;package name="com.itcast.springmvc.dao"/&gt;--&gt; &lt;!--&lt;/mappers&gt;--&gt;&lt;/configuration&gt; db.properties、log4j.properties 省略 controller 1234567891011121314151617181920212223242526272829303132package com.itcast.springmvc.controller;import com.itcast.springmvc.pojo.Items;import com.itcast.springmvc.service.ItemService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.servlet.ModelAndView;import java.util.List;/** * 商品管理 */@Controllerpublic class ItemController &#123; @Autowired private ItemService itemService; @RequestMapping(value="/item/itemlist.action") public ModelAndView itemList()&#123; //从 mysql 查询需要展示的数据 List&lt;Items&gt; list = itemService.selectItemsList(); ModelAndView mav = new ModelAndView(); mav.addObject("itemList",list); mav.setViewName("itemList"); return mav; &#125;&#125; 参数绑定因为 springmvc 是单例模式 单例模式是一个方法为一个模板，每有一个用户访问就创建一个模板的副本，让多个用户进行多线程访问 controller 12345678910111213141516171819/** * 修改页面 * 入参 id */ @RequestMapping(value="/itemEdit.action") public ModelAndView edit(Integer id,HttpServletRequest request, HttpServletResponse response, HttpSession session,Model model)&#123; //servlet 世代开发// 可以直接从页面传递 id 过来// String sid = request.getParameter("id");// Integer id = Integer.parseInt(sid); //查询商品 Items item = itemService.selectItemById(id); ModelAndView modelAndView = new ModelAndView(); modelAndView.addObject("item",item); modelAndView.setViewName("editItem"); return modelAndView; &#125; RequestMapping(url) 在类上加可以统一提取 方法中的路径前缀，窄化路径 @RequestMapping(&quot;/item/&quot;) 多请求路径，可以访问多个地址实现请求访问 @RequestMapping(value={&quot;/item/itemlist.action&quot;,&quot;/item/list.action&quot;}) 方法限定，只能使用 get 或 post 提交响应 @RequestMapping(value=&quot;/update.action&quot;,method = {RequestMethod.POST,RequestMethod.GET}) controller 返回值类型 ModelAndView 万能的 带数据 返回视图路径后结束 全局异常处理会用到 String 只能返回视图路径 需要通过方法传参数 Model model，通过 model 带数据 官方推荐 符合解耦合 数据 视图 分离 MVC 123456789@RequestMapping(value=&#123;"/item/itemlist.action","/item/list.action"&#125;) //传入 model ，用来给他赋值，传递到页面 public String itemList(Model model)&#123; //从 mysql 查询需要展示的数据 List&lt;Items&gt; list = itemService.selectItemsList(); model.addAttribute("itemList",list); //返回路径 return "itemList"; &#125; void ajax 请求 适合返回 json 格式数据（response 异步请求使用，不用刷页面），因为是请求转发，所以如果原本没有页面，直接访问该 action 转发后还是 404 not found。 123456789@RequestMapping(value=&#123;"/item/itemlist.action","/item/list.action"&#125;) //传入 model ，用来给他赋值，传递到页面 public void itemList(Model model,HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException &#123; //从 mysql 查询需要展示的数据 List&lt;Items&gt; list = itemService.selectItemsList(); model.addAttribute("itemList",list); //ajax 异步请求数据不需要跳转页面 request.getRequestDispatcher("itemList").forward(request,response); &#125; 重定向标签 重定向后网址改变，刷新后 request 的提交参数不保留 1234567@RequestMapping(value="/updateitem.action")// public ModelAndView updateitem(Items items)&#123; public String updateitem(QueryVo vo)&#123; itemService.updateitem(vo.getItems());// 修改后 重定向到列表页面 return "redirect:/item/itemlist.action"; &#125; 内部转发标签 return &quot;forward:/item/itemlist.action&quot;; 转发后网址不会变，刷新后会提示是否重新提交表单 异常处理在各个层之间捕获的异常抛出，最终到 controller 层，由 controller 层将异常抛给 前端控制器，前端控制器将异常交给 异常处理器（HandlerExceptionResolver）处理，它会调用一个实现类接口（自己编写接口，并配置到 spring 容器中实例化）来处理异常 异常处理器自定义类 123456789101112131415161718192021/** * 异常处理器自定义实现类 */public class CustomerExceptionResolver implements HandlerExceptionResolver&#123; @Override public ModelAndView resolveException(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) &#123; //Object o 是发生异常的地方，结构：包名+类名+方法名（形参）的字符串 //打日志，将 o 写到日志中（发布项目后在 tomcat 下的是 war 包，无法用开发工具查看；发布的 tomcat 在 Linux 服务器下，无法查看，需要打 log4j 日志） ModelAndView mav = new ModelAndView(); if(e instanceof MessageException)&#123; //预期异常 mav.addObject("error",((MessageException) e).getMsg()); &#125;else&#123; //运行时的未知异常 mav.addObject("error","未知异常"); &#125; mav.setViewName("errors"); return mav; &#125;&#125; 将其配置到 springmvc.xml 中 12&lt;!--springmvc 的异常处理器,自定义异常处理器--&gt;&lt;bean class="com.itcast.springmvc.exception.CustomerExceptionResolver"/&gt; 在 controller 等层中定义可能发生异常的状况 12345//从 mysql 查询需要展示的数据List&lt;Items&gt; list = itemService.selectItemsList();if(null==null)&#123; throw new MessageException("商品不能为空");&#125; 定义 MessageException 等自定义异常类，设置 msg 属性和 get set 方法 图片上传如果 idea 要进行图片上传路径设置，需要在 tomcat 设置中 Deployment 中配置 upload 路径，ApplicationContext 用来表示 localhost:8080 后所添加的路径，如果配置为 /spring_mvc 以后的访问路径就是 localhost:8080/spring_mvc/xxx.action，访问文件路径也是如此 可以将图片放在某一个盘符下，防止开发阶段的修改将该图片删除 12345678910111213141516171819 @RequestMapping(value="/updateitem.action")// public ModelAndView updateitem(Items items)&#123; public String updateitem(QueryVo vo, MultipartFile pictureFile) throws IOException &#123;// 保存图片到// 用 uuid 作为图片名，且去除自动生成的 - ，将 36 位 uuid 变成 32 位 String name = UUID.randomUUID().toString().replaceAll("-",""); //截取后缀名 String ext = FilenameUtils.getExtension(pictureFile.getOriginalFilename()); pictureFile.transferTo(new File("D:\\upload\\" + name + "." + ext)); vo.getItems().setPic(name+"."+ext); itemService.updateitem(vo.getItems()); return "redirect:/itemEdit.action?id="+vo.getItems().getId() ; &#125; jsp 页面 12345678910&lt;tr&gt; &lt;td&gt;商品图片&lt;/td&gt; &lt;td&gt; &lt;c:if test="$&#123;item.pic !=null&#125;"&gt; &lt;img src="/pic/$&#123;item.pic&#125;" width=100 height=100/&gt; &lt;br/&gt; &lt;/c:if&gt; &lt;input type="file" name="pictureFile"/&gt; &lt;/td&gt;&lt;/tr&gt; json 数据交互页面发送 ajax 请求并接受服务器返回的数据 123456789101112131415$(function()&#123; var params = '&#123;"id":1,"name":"测试商品","price":99.9,"detail":"测试商品描述","pic":"123456.jpg"&#125;'; $.ajax(&#123; url:"$&#123;pageContext.request.contextPath&#125;/json.action", data:params, contentType:"application/json;charset=UTF-8",//发送数据格式 dataType:"json", type:"POST", success:function(data)&#123; alert(data.name); &#125; &#125;);&#125;); controller 接收返回 json 1234567891011/** * 接受 json 格式数据,并返回 json 数据 * RequestBody 能使接受的数据变为 json 格式 * ResponseBody 使返回的格式转为 json 格式 */@RequestMapping(value="/json.action")public @ResponseBody Items json(@RequestBody Items items)&#123; System.out.println(items); return items;&#125; 使用 RESTful 操作资源localhost:8080/list.action?id=10086 localhost:8080/list/10086.action 将 id 放到文件后 action 前 12345678910111213141516/** * 修改页面 RESTful 风格 * 入参 id 将 id 放到访问路径中需要配置 @PathVariable */@RequestMapping(value="/itemEdit/&#123;id&#125;.action")public ModelAndView toEdit(@PathVariable Integer id, HttpServletRequest request, HttpServletResponse response, HttpSession session, Model model)&#123; //查询商品 Items item = itemService.selectItemById(id); ModelAndView mav = new ModelAndView(); mav.addObject("item",item); mav.setViewName("editItem"); return mav;&#125; 拦截器拦截器中有三个方法：方法前、方法后、页面渲染后 用户访问 – 【拦截器方法前】– controller 执行方法 – 【拦截器方法后】– jsp 页面渲染为 html –【拦截器页面渲染后】– 返回给用户 配置两个放行拦截器时，经过拦截器顺序 方法前1–方法前2–方法后–方法后1–页面渲染后2–页面渲染后1 当第一个拦截器拒绝访问，执行拦截器1 方法前，拦截器2 不执行 当第二个拦截器拒绝访问，执行拦截器1方法前–拦截器2 方法前 – 拦截器1 页面渲染后 配置拦截器 springmvc.xml 1234567891011&lt;!--springmvc 拦截器--&gt;&lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path="/**"/&gt; &lt;bean class="com.itcast.springmvc.intercptor.Interceptor1"/&gt; &lt;/mvc:interceptor&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path="/**"/&gt; &lt;bean class="com.itcast.springmvc.intercptor.Interceptor2"/&gt; &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt; URL:http://localhost:8080/springmvc_mybatis/item/list.action URI:/item/list.action springmvc 高级参数绑定 List 多个 \ pojo :public String list(Integer[] ids) 包装类型：public String list(QueryVo vo) QueryVo 中有 Integer[] ids 时跟 普通 pojo 一样 List 集合，方法内不能直接写 List ，需要在包装类内 QueryVo - List 有一个 List itemList 属性， \&lt;input type=”checkbox” name=”itemList[${i.index}].name”/> RequestMapping 处理器映射器（找此标签，路径） Value {多个路径} Value={/item/} 用于类头上，可以抽取多个方法路径相同的部分，减少代码量 Method=RequestMethod=POST 、GET String 形参绑定路径，Model 形参绑定视图，返回的 “redirect” 重定向另一个方法的映射，“dispatcher” 内部转发 void ajax 异步请求 浏览器 ajax 发送 json 字符串 模拟手机等发送的 报文，浏览器一般直接发送 json 格式的数据，而不是字符串 自定义标签库在 jsp 引用标签库，prefix 表示用何种 符号 来使用该标签，uri 是该标签的名字，用来告诉该标签库引用哪个 uri 名的 tld 文件 &lt;%@ taglib prefix=&quot;itcast&quot; uri=&quot;http://itcast.cn/common/&quot;%&gt; taglib.tld 文件是自定义标签库文件，uri 表示它的名字，在被 jsp 导入标签库时所定位； 每个 tag 表示定义一个标签； tag 标签中 name 是标签库被使用时显示的标签， attribute 中配置的是属性，name 指使用标签中可选择的属性 \&lt;itcast:page url=”” number=”” bean=””/> attribute 中 \&lt;rtexprvalue> 指在使用标签时能不能使用表达式来动态指定数据 ，一般用 true 就行 \&lt;itcast:page url=”&lt;%=’url’%&gt;” number=”&lt;%’num’%&gt;” bean=””/> 如果是 true 表示可以用表达式动态修改， \&lt;itcast:page url=”http://aa.com&quot; number=”123” bean=””/> false 表示不能,只能填写固定值，使用动态值会报出异常 \&lt;required>true\&lt;/required> true 表示该项是必须填的，在创建该标签时，此项会一起出现 123456789101112131415161718192021222324252627&lt;taglib&gt; &lt;tlib-version&gt;2.0&lt;/tlib-version&gt; &lt;jsp-version&gt;1.2&lt;/jsp-version&gt; &lt;short-name&gt;common&lt;/short-name&gt; &lt;uri&gt;http://itcast.cn/common/&lt;/uri&gt; &lt;display-name&gt;Common Tag&lt;/display-name&gt; &lt;description&gt;Common Tag library&lt;/description&gt; &lt;tag&gt; &lt;name&gt;page&lt;/name&gt; &lt;tag-class&gt;cn.itcast.common.utils.NavigationTag&lt;/tag-class&gt; &lt;body-content&gt;JSP&lt;/body-content&gt; &lt;description&gt;create navigation for paging&lt;/description&gt; &lt;attribute&gt; &lt;name&gt;bean&lt;/name&gt; &lt;rtexprvalue&gt;true&lt;/rtexprvalue&gt; &lt;/attribute&gt; &lt;attribute&gt; &lt;name&gt;number&lt;/name&gt; &lt;rtexprvalue&gt;true&lt;/rtexprvalue&gt; &lt;/attribute&gt; &lt;attribute&gt; &lt;name&gt;url&lt;/name&gt; &lt;required&gt;true&lt;/required&gt; &lt;rtexprvalue&gt;true&lt;/rtexprvalue&gt; &lt;/attribute&gt; &lt;/tag&gt;&lt;/taglib&gt; 当使用 &lt;c:foreach … 或自定义标签 &lt;c:itcast url…. 时，会去调用一个 java 类 NavigationTag 中的 doStartTag 方法，执行一系列定义好的方法完成相应的功能 @Value(&quot;${dictType.code}&quot;) 注入 properties 文件的值 该配置必须写在 springmvc.xml 中，不然无法正确解析值，直接将 dictType.code 作为字符串赋值给了成员变量 12&lt;!--读取 controller keyvalue 键值对--&gt;&lt;context:property-placeholder location="classpath:resource.properties"/&gt; SSM@RepsonseBody 该注解用于将Controller的方法返回的对象，通过适当的HttpMessageConverter转换为指定格式后，写入到Response对象的body数据区。 当返回不是 html 页面而是其他数据格式（json、xml 等）时使用 假如Controller类中返回值为 return “OK”，那么根据视图解析器可得将要跳转的页面路径为：/WebContent/jsp/OK.jsp 视图解析器的作用 @RequestBody, @ResponseBody 注解详解 SSM 增删改查Controller 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970@Controller@RequestMapping(value="/customer/")public class CustomerController &#123; @Autowired private IBaseDictService baseDictService; @Autowired private ICustomerService customerService;// 添加成员变量，用注解读取 properties 中的字段 @Value("$&#123;fromType.code&#125;") private String fromTypeCode; @Value("$&#123;industryType.code&#125;") private String industryTypeCode; @Value("$&#123;levelType.code&#125;") private String levelTypeCode; @RequestMapping(value="list.action") public String list(Model model,QueryVo vo)&#123; List&lt;BaseDict&gt; fromType = baseDictService.selectBaseDictByCode(fromTypeCode); List&lt;BaseDict&gt; industryType = baseDictService.selectBaseDictByCode(industryTypeCode); List&lt;BaseDict&gt; levelType = baseDictService.selectBaseDictByCode(levelTypeCode); model.addAttribute("fromType",fromType); model.addAttribute("industryType",industryType); model.addAttribute("levelType",levelType);// 通过四个条件查询分页对象 Page&lt;Customer&gt; customerPage = customerService.selectPageByQueryVo(vo); model.addAttribute("page",customerPage); model.addAttribute("custName",vo.getCustName()); model.addAttribute("custSource",vo.getCustSource()); model.addAttribute("custIndustry",vo.getCustIndustry()); model.addAttribute("custLevel",vo.getCustLevel()); return "customer"; &#125; /** * 返回 Customer 对象的字符串 * response 用于将返回对象转换成 json 字符串 */ @RequestMapping(value="edit.action") public @ResponseBody Customer edit(Integer id)&#123; return customerService.selectCustomerById(id); &#125; /** * 修改保存 */ @RequestMapping(value="update.action") public @ResponseBody String update(Customer customer)&#123; customerService.update(customer); return "OK"; &#125; /** * 删除，加上 ResponseBody 使其不走视图解析器，直接返回 ajax * 如果不加 ResponseBody 视图解析器会跳转到 WEB-INF/jsp/OK.jsp */ @RequestMapping(value="delete.action") public @ResponseBody String delete(Integer id)&#123; customerService.deleteCustomerById(id); return "OK"; &#125;&#125; serviceImpl 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/** * 客户管理 */@Servicepublic class CustomerServiceImpl implements ICustomerService &#123; //通过四个条件查询分页对象 @Autowired private CustomerDao customerDao; public Page&lt;Customer&gt; selectPageByQueryVo(QueryVo vo)&#123; Page&lt;Customer&gt; page = new Page&lt;Customer&gt;();// 配置每页显示条数，vo 要传入 sql 语句，给 limit 限制每页数传值 vo.setSize(5);// page 的 size 必须有值，不为空 page.setSize(5);// 防止 vo 及 vo 内的5个值为空或空字符串 if (null!=vo) &#123; if(null!=vo.getPage())&#123; if(vo.getPage()&lt;=0) vo.setPage(1); page.setPage(vo.getPage()); vo.setStartRow((vo.getPage()-1)*vo.getSize()); &#125; if(null!=vo.getCustName()&amp;&amp; !"".equals(vo.getCustName().trim()))&#123; vo.setCustName(vo.getCustName().trim()); &#125; if(null!=vo.getCustSource()&amp;&amp; !"".equals(vo.getCustSource().trim()))&#123; vo.setCustSource(vo.getCustSource().trim()); &#125; if(null!=vo.getCustIndustry()&amp;&amp; !"".equals(vo.getCustIndustry().trim()))&#123; vo.setCustIndustry(vo.getCustIndustry().trim()); &#125; if(null!=vo.getCustLevel()&amp;&amp; !"".equals(vo.getCustLevel().trim()))&#123; vo.setCustLevel(vo.getCustLevel().trim()); &#125; //通过 dao 查询总条数和总结果集，赋给还未赋值 Page 的两个属性 page.setTotal(customerDao.getCustomerCountByQueryVo(vo)); page.setRows(customerDao.selectCustomerListByQueryVo(vo)); &#125; return page; &#125; public Customer selectCustomerById(Integer id)&#123; return customerDao.selectCustomerById(id); &#125; @Override public void update(Customer customer) &#123; customerDao.updateCustomerById(customer); &#125; @Override public void deleteCustomerById(Integer id) &#123; customerDao.deleteCustomerById(id); &#125;&#125; dao.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="com.itcast.crm.mapper.CustomerDao"&gt; &lt;!--根据四个条件查询总条数 private String custName; private String custSource; private String custIndustry; private String custLevel; --&gt; &lt;select id="getCustomerCountByQueryVo" parameterType="QueryVo" resultType="Integer"&gt; SELECT count(*) FROM customer &lt;where&gt; &lt;if test="custName != null and custName!=''"&gt; cust_name LIKE "%"#&#123;custName&#125;"%" &lt;/if&gt; &lt;if test="custSource != null and custSource!=''"&gt; AND cust_source = #&#123;custSource&#125; &lt;/if&gt; &lt;if test="custIndustry !=null and custIndustry!=''"&gt; AND cust_industry = #&#123;custIndustry&#125; &lt;/if&gt; &lt;if test="custLevel !=null and custLevel!=''"&gt; AND cust_level = #&#123;custLevel&#125; &lt;/if&gt; &lt;/where&gt; &lt;/select&gt; &lt;!--根据 QueryVo 查询 Customer结果集--&gt; &lt;select id="selectCustomerListByQueryVo" parameterType="QueryVo" resultType="Customer"&gt; SELECT * FROM customer &lt;where&gt; &lt;if test="custName != null and custName!=''"&gt; cust_name LIKE "%"#&#123;custName&#125;"%" &lt;/if&gt; &lt;if test="custSource != null and custSource!=''"&gt; AND cust_source = #&#123;custSource&#125; &lt;/if&gt; &lt;if test="custIndustry !=null and custIndustry!=''"&gt; AND cust_industry = #&#123;custIndustry&#125; &lt;/if&gt; &lt;if test="custLevel !=null and custLevel!=''"&gt; AND cust_level = #&#123;custLevel&#125; &lt;/if&gt; &lt;/where&gt; limit #&#123;startRow&#125;,#&#123;size&#125; &lt;/select&gt; &lt;!--public Customer selectCustomerById(Integer id);--&gt; &lt;!--根据 QueryVo 查询 Customer结果集--&gt; &lt;select id="selectCustomerById" parameterType="Integer" resultType="Customer"&gt; SELECT * FROM customer &lt;where&gt; cust_id = #&#123;custId&#125; &lt;/where&gt; &lt;/select&gt; &lt;!--根据 id 修改 Customer 对象--&gt; &lt;!--public void updateCustomerById(Customer customer); set 标签用来去除最后的语句的 ，--&gt; &lt;update id="updateCustomerById" parameterType="Customer"&gt; UPDATE customer &lt;set&gt; &lt;if test="cust_name!=null"&gt; cust_name=#&#123;cust_name&#125;, &lt;/if&gt; &lt;if test="cust_source!=null"&gt; cust_source=#&#123;cust_source&#125;, &lt;/if&gt; &lt;if test="cust_linkman!=null"&gt; cust_linkman=#&#123;cust_linkman&#125;, &lt;/if&gt; &lt;/set&gt; &lt;where&gt; cust_id = #&#123;cust_id&#125; &lt;/where&gt; &lt;/update&gt; &lt;!--根据 id 删除 Customer 对象--&gt; &lt;delete id="deleteCustomerById" parameterType="Integer"&gt; DELETE FROM customer &lt;where&gt; cust_id = #&#123;id&#125; &lt;/where&gt; &lt;/delete&gt;&lt;/mapper&gt; jsp 页面 javascript 1234567891011121314151617181920212223242526272829303132333435363738&lt;script type="text/javascript"&gt; function editCustomer(id) &#123; $.ajax(&#123; type:"get", url:"&lt;%=basePath%&gt;customer/edit.action", data:&#123;"id":id&#125;, success:function(data) &#123; $("#edit_cust_id").val(data.cust_id); $("#edit_customerName").val(data.cust_name); $("#edit_customerFrom").val(data.cust_source) $("#edit_custIndustry").val(data.cust_industry) $("#edit_custLevel").val(data.cust_level) $("#edit_linkMan").val(data.cust_linkman); $("#edit_phone").val(data.cust_phone); $("#edit_mobile").val(data.cust_mobile); $("#edit_zipcode").val(data.cust_zipcode); $("#edit_address").val(data.cust_address); &#125; &#125;); &#125; function updateCustomer() &#123; // 更新操作，$(表单).serialize() 是将表单内容序列化，提交整个 form 表单$.post 的 function(data) data 回调函数为 "OK" 时才能继续执行 $.post("&lt;%=basePath%&gt;customer/update.action",$("#edit_customer_form").serialize(),function(data)&#123; alert("客户信息更新成功！"); window.location.reload(); &#125;); &#125; function deleteCustomer(id) &#123; if(confirm('确实要删除该客户吗?')) &#123; $.post("&lt;%=basePath%&gt;customer/delete.action",&#123;"id":id&#125;,function(data)&#123; alert("客户删除更新成功！"); window.location.reload(); &#125;); &#125; &#125;&lt;/script&gt; Q&amp;AQ：Mybatis 的 select Key 标签错误Caused by: org.apache.ibatis.builder.BuilderException: Error creating document instance. Cause: org.xml.sax.SAXParseException; lineNumber: 24; columnNumber: 14; 元素类型为 “select” 的内容必须匹配 “(include|trim|where|set|foreach|choose|if|bind)”。 A:将 select Key 标签写在了 select 标签内，需要将其 写在 insert 标签内 注：select 标签内执行 insert 语句也会成功，但是 select 标签内无法包含 select Key 标签 Q: org.apache.ibatis.binding.BindingExceptionorg.apache.ibatis.binding.BindingException: Type interface cn.itcast.mybatis.mapper.OrderMapper is not known to the MapperRegistry. 没有将 mapper(Bean.xml) 添加到 mybatis-config.xml 中 https://my.oschina.net/kaigejava/blog/726728 Q: idea 提示 decompiled .class file version 50.0(java6)从 eclipse 拷贝的项目，出现：idea 提示 decompiled .class file version 50.0(java6) 中文解释是：反编译 .class文件中的字节码 到Java 8 版本,这种情况下打开的 class 文件，可以打开 .java 文件重新编译一次 idea 提示 decompiled .class file version 52.0(java8) Q: 逆向工程生成的 pojo 与 Mapper 运行报错Result Maps collection already contains value for com.itcast.mybatis.mapper.OrdersMapper.BaseResultMap A:因为有重复的 sql id ，只要删除重复的语句即可（自己是因为运行了两次逆向工程，将所有的代码生成了两次，删除生成的 pojo 与 mapper 包及包下的文件，重新生成即可） mybatis 报错 Q:实例化 servlet 失败 Message Error instantiating servlet class [org.springframework.web.servlet.DispatcherServlet] Description The server encountered an unexpected condition that prevented it from fulfilling the request. Exception 1javax.servlet.ServletException: Error instantiating servlet class [org.springframework.web.servlet.DispatcherServlet] A:一般是 web.xml 配置问题，但是我的这个问题实际发现是 idea 没有正确导入 jar 包导致的，在 Project Struture 中 Problem 中 fix 修复没有将 libs 目录添加进 artifact 的问题（输出的 war 包中没有包含 libs 目录） Q:导入了包还是显示包不存在Error:(5, 37) java: 程序包org.apache.ibatis.annotations不存在 A:试着重启，不行就删除包路径，重新导入 Q: 404 错误 The origin server did not find a current representation for the target resource or is not willing to disclose that one exists. A: 前端控制器在 web.xml 配置错误，需要将 springmvc.xml 配置到 DispatcherServlet，不然无法进入 controller（没有 springmvc.xml 注释驱动就等于没配置，无法生效，自然无法进入 controller 了） 12345678910&lt;!--前端控制器--&gt;&lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;!--如果没有配置，默认找/WEB-INF/"servlet名称"-servlet.xml--&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt;&lt;/servlet&gt; Q: sql 错误1org.springframework.web.util.NestedServletException: Request processing failed; nested exception is org.springframework.dao.DataIntegrityViolationException: A:自己添加 属性 set Q: 500 错误Message Request processing failed; nested exception is java.lang.NullPointerException Description The server encountered an unexpected condition that prevented it from fulfilling the request. Exception 1org.springframework.web.util.NestedServletException: Request processing failed; nested exception is java.lang.NullPointerException 如果入参是包装类，那么参数提交页面（jsp 页面）也需要将 name 变为包装类中的类型前缀，QueryVo 中封装一个 Items items 的 pojo，那么需要在页面的 name 属性前加上 items 的前缀，不然后台取不到属性值。 name=”items.username”… Q: idea jsp 热修改页面不生效A：在 tocmat 配置中将 On ‘Update’ action 设置为 Restart server；将 On frame Q:NullPointException12345678Type Exception ReportMessage Request processing failed; nested exception is java.lang.NullPointerExceptionDescription The server encountered an unexpected condition that prevented it from fulfilling the request.org.springframework.web.util.NestedServletException: Request processing failed; nested exception is java.lang.NullPointerException org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:978) A:查询看到有人是因为输出 classes 文件中没有生成 BeanMapper.xml 文件，是 src/main/java 在 eclipse 下是资源目录，在 Idea 下是普通目录，所以不生成文件。但是我的 Mapper.xml 已经在out 的 classes 下生成了，于是继续找资料发现需要在 Mapper.xml 最好以 Mapper 结尾。 最后发现是 Mapper.xml 名字与 Mapper.java 不一致，BaseDictDao.xml 与 BaseDictDao.java 需要名字一致， 我加了一个 I前缀 IBaseDictDao.java 参考： Rename mapper/drugmasterDao.xml to mapper/DrugMasterDao.xml , the name has to match the *Dao.java file name otherwise it throws error or we have to create Ibatismapping.xml explictly and add mapper configuration there https://stackoverflow.com/questions/20427210/mybatis-spring-mvc-application-getting-invalid-bound-statement-not-found]]></content>
      <tags>
        <tag>java</tag>
        <tag>web</tag>
        <tag>ssm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[interview]]></title>
    <url>%2F2019%2F02%2F25%2Finterview%2F</url>
    <content type="text"><![CDATA[List 的实现类区别List 列表类，顺序存储任何对象，可重复 ArrayList：实现动态数组 随机访问，查询快 O(1) ，增删慢 线程不同步（非线程安全） 数组可变长，本质是在数组满后，会自动将该数组复制到一个新的 1.5 倍长得新数组中 LinkList：：实现链表（JDK 1.7 后为双向链表） 查询慢 O(n)，增删快 ArrayList 在内存中是一段连续的空间，数组名 a 指向了该空间的起始地址，也是数组第一个元素的地址，与 a[0] 指向的地方相同，但是意义不同，一个是指该内存地址，一个指该地址上存放的元素。 a[0] a[1] 中的数组表示相对于起始地址的偏移量，如果是 0，表示没有偏移，1 表示偏移量为 1。 a[1] 底层执行的是 *(a+1) ，*表示取出该地址上存储的元素，不管该数组多长，取出哪个元素都是这两步（加偏移量，取数据），所以按索引访问时间复杂度是 O(1) LinkList 虽然也是按索引访问，但是链表在内存中不是连续的，操作系统分配时会将每个元素的数据和下一个元素在内存的索引保存到一个内存地址中，如果要查询则要从一开始的元素进行遍历，使用 for(int i =0;i&lt;list.size();i++) 这种方式遍历时复杂度为 O(n*n) ，如果使用增强 for 循环(底层也是迭代器实现) 或 迭代器，则可以达到 O(n)。LinkList 的增删时间复杂度几乎为 O(1),因为只需断开前后连接重新指向即可添加删除。 使用迭代器可以不用从头开始访问 LinkList，它会缓存当前节点的前后节点,时间复杂度 O（n） 123456LinkList&lt;String&gt; list = new LinkList&lt;&gt;();Interator&lt;String&gt; it = list.interator();while(it.hasNext)&#123; String s = it.next();&#125; 参考 Java数据结构之LinkedList、ArrayList的效率分析 Iterator 迭代器 HashMap 与 HashSet 区别Set的集合里不允许对象有重复的值，List允许有重复 HashSet实现了Set接口，它不允许集合中有重复的值，当我们提到HashSet时，第一件事情就是在将对象存储在HashSet之前，要先确保对象重写equals()和hashCode()方法，这样才能比较对象的值是否相等，以确保set中没有储存相等的对象。如果我们没有重写这两个方法，将会使用这个方法的默认实现。 public boolean add(Object o)方法用来在Set中添加元素，当元素值重复时则会立即返回false，如果成功添加的话会返回true。 HashMap实现了Map接口，Map接口对键值对进行映射。Map中不允许重复的键。Map接口有两个基本的实现，HashMap和TreeMap。TreeMap保存了对象的排列次序，而HashMap则不能。HashMap允许键和值为null。HashMap是非synchronized的，但collection框架提供方法能保证HashMap synchronized，这样多个线程同时访问HashMap时，能保证只有一个线程更改Map。 public Object put(Object Key,Object value)方法用来将元素添加到map中。 HashMap HashSet HashMap实现了Map接口 HashSet实现了Set接口 HashMap储存键值对 HashSet仅仅存储对象 使用put()方法将元素放入map中 使用add()方法将元素放入set中 HashMap中使用键对象来计算hashcode值 HashSet使用成员对象来计算hashcode值，对于两个对象来说hashcode可能相同，所以equals()方法用来判断对象的相等性，如果两个对象不同的话，那么返回false HashMap比较快，因为是使用唯一的键来获取对象 HashSet较HashMap来说比较慢 HashMap和HashSet的区别 Set 中元素如何比较是否重复 1、什么是Set?(what) Set是Collection容器的一个子接口，它不允许出现重复元素，当然也只允许有一个null对象。 2、如何来区分重复与否呢？(how) “ 用 iterator() 方法来区分重复与否 ”，这是在网上流传的答案，个人认为这是个错误的答案。JPI中写的很明白：“set 不包含满足 e1.equals(e2) 的元素对 e1 和 e2 ”，由此可见回答使用equals()区分更合适。 3、为什么用equals()而不用==来区分？(why) 应该从它俩的区别谈起，==是用来判断两者是否是同一对象（同一事物），而equals是用来判断是否引用同一个对象。再看一下Set里面存的是 对象，还是对象的引用。根据java的存储机制可知，set里面存放的是对象的引用，所以当两个元素只要满足了equals()时就已经指向同一个对象， 也就出现了重复元素。所以应该用equals()来判断。 来源：https://blog.csdn.net/fhm727/article/details/5221792 String s = new String(“xyz”); 创建几个对象因为 String(“xyz”) 这条语句会在 String 常量池（字符串常量缓冲区）创建一个对象 new String 又会在 堆内存中创建一个新的对象， 所以一般情况是两个，一个放入常量池，一个放入堆内存。但是如果之前就用过 “xyz” 对象，那么就不会再常量池创建对象，直接从常量池拿。 参考：https://www.cnblogs.com/dangzhenjiuhao/p/4585389.html String s=”a”+”b”+”c”+”d”; 一共创建了几个对象一个， String s1 = “a”; String s2 = s1 + “b”; String s3 = “a” + “b”; sout(s2 == “ab”);–false sout(s3 == “ab”);–true javac 编译器会对 string 字符串常量相加时进行优化，直接将其编译成常量相连的结果 当 try 语句中有 return 时，finally 中的语句还执行吗执行，但是在执行 finally 前就会把 return 的值在局部变量开辟一个空间保存起来，即使这个值在 finally 被修改，返回给主函数的值也是原来保存起来的值。 x=1– 到 return 行，x=3 并保存到一个新的局部变量空间– 到 finally 行，x=7 – 返回到 return 行，将 x=3 返回 1234567891011121314151617181920class Test &#123; public int lalala()&#123; int x = 1; try&#123; return x=x+2; &#125;catch (Exception e)&#123; &#125;finally&#123; x=x+4; &#125; return x; &#125; public static void main(String[] args) &#123; Test t = new Test(); int lalala = t.lalala(); System.out.println(lalala); &#125;&#125; 参考：http://www.cnblogs.com/averey/p/4379646.html 堆和栈 栈区(stack)–由编译器自动分配和释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。 堆区(heap)–一般由程序员分配和释放，若程序员不释放，程序结束时可能由OS回收，注意它与数据结构中的堆是两回事，分配方式倒是类似于链表。 全局区(静态区)(static)–全局变量和静态变量的存储是放在一起的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域，程序结束后由系统释放。 JVM 中堆和栈属于不同内存区域，栈常用于保存方法和局部变量，不会被多个线程共享，当定义一个变量时， java 在栈中为这个变量分配了内存空间，超过变量的作用域后，就会释放掉该空间； 对象分配在堆上，堆被整个 JVM 所有线程共享，用来存放 new 出来的对象和数组，堆内存由java 虚拟机的垃圾回收期自动回收管理 在堆内存创建数组或对象后，可以在栈中定一个特殊变量，让这个变量的取值为数组或对象在堆内存的首地址，那么就称栈中这个变量为数组或对象的引用变量，以后可以在程序中使用栈中的引用变量来访问堆中数组或对象，引用变量相当于一个数组或对象的名称 参考：https://blog.csdn.net/hairetz/article/details/4141043 https://www.jianshu.com/p/ce02402fb36b 泛型是java泛型的两种用法：List是泛型方法，List&lt;?&gt;是限制通配符 List一般有两种用途： 1、定义一个通用的泛型方法。 伪代码： 1234567891011public interface Dao&#123; List&lt;T&gt; getList()&#123;&#125;;&#125;List&lt;String&gt; getStringList()&#123; return dao.getList();//dao是一个实现类实例&#125;List&lt;Integer&gt; getIntList()&#123; return dao.getList();&#125; 上面接口的getList方法如果定义成List&lt;?&gt; ，后面就会报错。‘ 2、限制方法的参数之间或参数和返回结果之间的关系。 1List&lt;T&gt; getList&lt;T param1,T param2&gt; 这样可以限制返回结果的类型以及两个参数的类型一致。 List&lt;?&gt;一般就是在泛型起一个限制作用。 伪代码： 12345678910public Class Fruit()&#123;&#125;public Class Apple extends Fruit()&#123;&#125;public void test(? extends Fruit)&#123;&#125;;test(new Fruit());test(new Apple());test(new String()); //这个就会报错这样可以现在test方法的参数必须是Fruit或其子类。 来源：作者：zane zhou 删除一个表中所有重复的字段，只剩下一个多次插入相同字段 1234insert into test(aa,bb,cc) values(&quot;a1&quot;,&quot;b1&quot;,&quot;c1&quot;);insert into test(aa,bb,cc) values(&quot;a2&quot;,&quot;b2&quot;,&quot;c2&quot;);insert into test(aa,bb,cc) values(&quot;a3&quot;,&quot;b3&quot;,&quot;c3&quot;);insert into test(aa,bb,cc) values(&quot;a4&quot;,&quot;b4&quot;,&quot;c4&quot;); 先查询出 id 用 aa 列进行分组（分组同时会过滤重复的列），group 默认 min（）取最小值，然后用 delete 删除未查询出的列 1234delete from test where id not in(select id from (select id from test group by aa having count(aa) &gt; 1) t); 如果直接使用以下方式查询，会出现 [Err] 1093 - You can’t specify target table ‘test’ for update in FROM clause 错误，因为 mysql 中直接修改刚查询出的表会发生错误，可以在中间表多进行一次 select 12delete from test where id not in(select id from test group by aa having count(aa) &gt; 1); 如果使用以下方式查询，会出现 [Err] 1248 - Every derived table must have its own alias 错误，每个派生表需要一个命名 1234delete from test where id not in(select id from (select id from test group by aa having count(aa) &gt; 1)); 参考:https://blog.csdn.net/fdipzone/article/details/52695371 正则表达式123456789// 3.1、 截取连续的数字 【读取字符串中第一个连续的字符串，不包含后面不连续的数字】 public static String getNumbers(String content) &#123; Pattern pattern = Pattern.compile("\\d+"); //英文字母数字为 "[A-Za-z0-9]+" Matcher matcher = pattern.matcher(content); while (matcher.find()) &#123; return matcher.group(0); &#125; return ""; &#125; 12345678910public static String reg()&#123; String content = "证件类111111型代码CD010003中一级分CD12类为“10000” 且备注Cd422为“朱证件类型” 的代码"; // Pattern pattern = Pattern.compile("\\d+"); //英文字母数字为 "[A-Za-z0-9]+" Pattern pattern = Pattern.compile("[C][D][0-9]+"); //英文字母数字为 "[A-Za-z0-9]+" 将给定的正则表达式编译赋予给 pattern 类 （以 CD 开头接多个数字的字符串） Matcher matcher = pattern.matcher(content); while (matcher.find()) &#123; //目标字符串进行匹配，匹配到的字符串可以在任意位置返回 true return matcher.group(0); //返回匹配到的字符串 &#125; return ""; &#125; 正则表达式 href 跟 url src 区别 href url src link href 是 a 标签的一个属性，用于指向网络资源所在的位置，也可以建立和当前元素（用于设置锚点，返回页面顶部或页面中某个文件）或当前文档（链接）间的联系 [Ljava.lang.String;@f0c85e“[“ 表示一维数组“[[“表示二维数组“L”表示一个对象“java.lang.String”表示对象的类型“@”后面表示该对象的HashCode 在打印 String 数组时会出现以上情况，可以将值用 [0] 等方式取出来再打印]]></content>
      <tags>
        <tag>interview</tag>
        <tag>面试</tag>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BOS_later]]></title>
    <url>%2F2019%2F02%2F21%2FBOS-later%2F</url>
    <content type="text"><![CDATA[BOS 项目 定区关联客户在 BOS 中配置代理对象远程调用 crm完善 CRM 中的客户查询方法（增加未关联定区的客户，和已关联定区的客户） 更新 BOS 中的 ICustomerService（重新使用 wsimport -s . -p com.itheima.crm http://192.168.171.1:8080/service/customer?wsdl 下载代码，对程序中代码进行覆盖） 在 BOS 项目中配置代理对象，远程调用 crm 服务 在 pom 文件中引入 cxf jar 包 使用 wsimport 命令解析 wsdl 文件生成本地代码，只保留接口文件 ICustomerService 和 Customer bean 1234567891011121314151617181920212223242526272829303132333435363738package com.itheima.crm;import com.itheima.crm.service.Customer;import javax.jws.WebMethod;import javax.jws.WebResult;import javax.jws.WebService;import javax.xml.bind.annotation.XmlSeeAlso;import javax.xml.ws.RequestWrapper;import javax.xml.ws.ResponseWrapper;import java.util.List;/** * This class was generated by the JAX-WS RI. * JAX-WS RI 2.2.9-b130926.1035 * Generated source version: 2.2 * */@WebService(name = "ICustomerService", targetNamespace = "http://service.crm.itheima.com/")@XmlSeeAlso(&#123; //ObjectFactory.class&#125;)public interface ICustomerService &#123; /** * * @return * returns java.util.List&lt;com.itheima.crm.service.Customer&gt; */ @WebMethod @WebResult(targetNamespace = "") @RequestWrapper(localName = "findAll", targetNamespace = "http://service.crm.itheima.com/", className = "com.itheima.crm.service.FindAll") @ResponseWrapper(localName = "findAllResponse", targetNamespace = "http://service.crm.itheima.com/", className = "com.itheima.crm.service.FindAllResponse") public List&lt;Customer&gt; findAll();&#125; 在 spring 配置文件注册 crm 客户端代理对象 123&lt;!--注册 crm 客户端代理对象 192.168.171.1--&gt;&lt;jaxws:client id="crmClient" serviceClass="com.itheima.crm.ICustomerService" address="http://192.168.171.1:8080/service/customer"/&gt; 在 action 中调用 crm 服务 1234public class UserAction extends BaseAction&lt;User&gt; &#123; //注入 crm 代理对象 @Autowired private ICustomerService proxy; 关联客户绑定事件函数123456789101112131415161718192021222324252627282930313233343536373839404142function doAssociations()&#123; //获取当前选中所有行，返回数组 var rows = $("#grid").datagrid('getSelections'); if(rows.length != 1)&#123; //选中多个或没有选择定区 $.messager.alert("提示信息","请选择一个定区进行操作","message"); &#125;else&#123; //选中一个定区 $('#customerWindow').window('open'); //清理下拉框 $("#noassociationSelect").empty(); //发送 ajax 请求，在定区 action 中通过 crm 代理对象完成 crm 远程调用获取客户数据 var url_1 = "DecidedzoneAction_findListNotAssociation.action"; $.post(url_1,function(data)&#123; for(var i=0;i&lt;data.length;i++)&#123; var id = data[i].id; var name=data[i].name; var telephone = data[i].telephone; name = name + "(" + telephone + ")"; $("#noassociationSelect").append("&lt;option id='"+id+"'&gt;"+name+"&lt;/option&gt;"); &#125; &#125;); //清理下拉框 $("#associationSelect").empty(); var decidedzoneId = rows[0].id; //发送 ajax 请求，在定区 action 中通过 crm 代理对象完成 crm 远程调用获取客户数据 var url_2 = "DecidedzoneAction_findListHasAssociation.action?"; $.post(url_2,&#123;"id":decidedzoneId&#125;,function(data)&#123; for(var i=0;i&lt;data.length;i++)&#123; var id = data[i].id; var name=data[i].name; var telephone = data[i].telephone; name = name + "(" + telephone + ")"; $("#associationSelect").append("&lt;option id='"+id+"'&gt;"+name+"&lt;/option&gt;"); &#125; &#125;); &#125;&#125; 页面根据 ajax 请求访问后台，传回 json 数据 12345678910111213141516171819202122232425/** * 注入 crm 代理对象 */@Autowiredprivate ICustomerService proxy;/** * 查询未关联定区的客户 * @return */public String findListNotAssociation()&#123; List&lt;Customer&gt; list = proxy.findListNotAssociation(); java2Json(list,new String[]&#123;&#125;); return NONE;&#125;/** * 查询已关联定区的客户 */public String findListHasAssociation()&#123; List&lt;Customer&gt; list = proxy.findListHasAssociation(model.getId()); java2Json(list,new String[]&#123;&#125;); return NONE;&#125; $(“#id”).append(“value”) 相当于一个剪切效果，将 value 原本的值剪切到 id 的位置 1、空格表示获取所有子孙后代元素2、 &gt;表示获取一级子元素3、next函数获取紧接在之后的同辈元素列表4、nextAll函数表示获取之后的所有同辈元素列表5、siblings函数表示获取所有同辈元素列表，无论前后 jquery 层次选择器 为转移用户和提交客户按钮绑定事件 1234567891011121314151617181920212223242526&lt;script type="text/javascript"&gt; // 添加将左边窗口名字转移到右边的方法 $(function()&#123; $("#toRight").click(function()&#123; $("#associationSelect").append($("#noassociationSelect option:selected")); &#125;); &#125;); $(function()&#123; $("#toLeft").click(function()&#123; $("#noassociationSelect").append($("#associationSelect option:selected")); &#125;); &#125;); // 添加提交表单功能 $(function()&#123; $("#associationBtn").click(function()&#123; var rows = $("#grid").datagrid("getSelections")[0]; var id = rows.id; $("input[name=id]").val(id); //提交前将选项全部选中，option 添加 selected $("#customerForm option").attr("selected","selected"); alert("选择"); $("#customerForm").submit(); &#125;); &#125;);&lt;/script&gt; 给 crm 服务端扩展定区关联客户方法action 1234567891011121314 /** * 远程调用 crm 将客户关联到定区 */ public String assigncustomerstodecidedzone()&#123; proxy.assigncustomerstodecidedzone(model.getId(),customerIds); return LIST; &#125;// 属性驱动获得页面提交的多个客户 id private List&lt;Integer&gt; customerIds; public void setCustomerIds(List&lt;Integer&gt; customerIds) &#123; this.customerIds = customerIds; &#125; Webservice 123456789101112131415/** * 定区关联客户 * @param decidedzonedId * @param customerIds */@Overridepublic void assigncustomerstodecidedzone(String decidedzonedId, Integer[] customerIds) &#123; String sql = "update t_customer set decidedzone_id = null where decidedzone_id = ?;"; jdbcTemplate.update(sql,decidedzonedId); sql = "update t_customer set decidedzone_id = ? where id = ?"; for(Integer id :customerIds)&#123; jdbcTemplate.update(sql,decidedzonedId,id); &#125;&#125; 查看分区中关联的方法绑定 双击方法，创建双击方法函数 12345678910111213function doDblClickRow(rowIndex,rowData)&#123; // rowIndex: 点击的行索引,从0 // rowData: 点击对应的记录行 alert("双击表格数据..."); $('#association_subarea').datagrid( &#123; fit : true, border : true, rownumbers : true, striped : true, url : "SubareaAction_findListByDecidedzoneId.action?id="+rowData.id, columns : [ [&#123; field : 'id', title : '分拣编号', action 根据定区 id 查看关联分区 12345678910111213/** * 根据定区 id 查看关联分区 */public String findListByDecidedzoneId()&#123; List&lt;Subarea&gt; list = subareaService.findListByDecidedzoneId(decidedzoneId); this.java2Json(list,new String[]&#123;"decidedzone","subareas"&#125;); return NONE;&#125;private String decidedzoneId;public void setDecidedzoneId(String decidedzoneId) &#123; this.decidedzoneId = decidedzoneId;&#125; service 123456789101112/** * 根据定区 id 查询关联的 分区 * @param decidedzoneId * @return */@Overridepublic List&lt;Subarea&gt; findListByDecidedzoneId(String decidedzoneId) &#123; DetachedCriteria detachedCriteria = DetachedCriteria.forClass(Subarea.class); //添加过滤条件，单表查询不需要别名 detachedCriteria.add(Restrictions.eq("decidedzone.id",decidedzoneId)); return subareaDao.findByCriteria(detachedCriteria);&#125; yum ：Yellow dog Updater Modified,（黄狗升级修改器）软件包管理器，能从指定服务器自动下载 RPM 包并安装，可以自动处理依赖关系，并一次安装所有依赖软件包，无需多次下载安装 业务受理需求逆向工程生成 bean.hbm.xml 在 crm 拓展方法： 根据客户手机号查询客户的信息 根据客户的取件地址查询定区的 id（定区 id 可以查询是哪个取派员负责的地区） 在 bos 添加 页面绑定事件 与 action 为手机号输入框绑定事件，根据手机号回显用户 id name 与 联系人信息 123456789101112131415161718192021222324252627&lt;td&gt;来电号码:&lt;/td&gt;&lt;td&gt;&lt;input type="text" class="easyui-validatebox" name="telephone" required="true" /&gt;&lt;/td&gt;&lt;script type="text/javascript"&gt; $(function()&#123; //页面加载完成后为手机号输入框绑定离焦事件 $("input[name='telephone']").blur(function()&#123; //获取页面输入的手机号 var telephone = this.value; //发送 ajax 请求，服务器调用 crm 服务器，获取客户信息用于页面显示 $.post('NoticebillAction_findCustomerByTelephone.action', &#123;"telephone":telephone&#125;, function(data)&#123; if(data!=null)&#123; $("input[name='customerName']").val(data.name); $("input[name='customerId']").val(data.id); $("input[name='delegater']").val(data.name); $("input[name='pickaddress']").val(data.address); &#125;else&#123; $("input[name='customerName']").val(""); $("input[name='customerId']").val(""); $("input[name='delegater']").val(""); $("input[name='pickaddress']").val(""); &#125; &#125;); &#125;); &#125;);&lt;/script&gt; 创建 NoticebillAction，注入 crm 代理方法，提供根据手机号查找用户信息的方法 123456789101112//导入 crm customerService 服务@Autowiredprivate ICustomerService customerService;/** * 根据电话号码查找用户 */public String findCustomerByTelephone()&#123; Customer customerByTelephone = customerService.findCustomerByTelephone(model.getTelephone()); this.java2Json(customerByTelephone,new String[]&#123;&#125;); return NONE;&#125; 业务受理自动分单action 12345678910// 导入 NoticebillService 服务 @Autowired private INoticebillService noticebillService; /** * 保存一个业务通知单，尝试自动分单 */ public String add()&#123; noticebillService.save(model); return "noticebill_add"; &#125; service 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152@Service@Transactionalpublic class NoticebillServiceImpl implements INoticebillService &#123; @Autowired private INoticebillDao noticebillDao; @Autowired private IDecidedzoneDao decidedzoneDao; @Autowired private IWorkbillDao workbillDao; @Autowired private ICustomerService customerService; @Override /** * 保存业务通知单，尝试自动分单 */ public void save(Noticebill model) &#123; User loginUser = BOSUtils.getLoginUser(); model.setUser(loginUser);//设置当前登录用户 noticebillDao.save(model); //获取客户取货地址 String address = model.getPickaddress(); //远程调用客户方法根据地址获得定区id String decidedzoneId = customerService.findDecidedzoneIdByAddress(address); if(decidedzoneId!=null)&#123; //查询到定区id可以自动分单 Decidedzone decidedzone = decidedzoneDao.findById(decidedzoneId); Staff staff = decidedzone.getStaff(); model.setStaff(staff);//业务通知单关联取派员对象 //设置自动分单 model.setOrdertype(Noticebill.ORDERTYPE_AUTO); //为取派员生成一个工单 Workbill workbill = new Workbill(); workbill.setAttachbilltimes(0);//追单次数 workbill.setBuildtime(new Timestamp(System.currentTimeMillis()));//精确到秒的时间值 workbill.setNoticebill(model);//工单关联业务通知单 workbill.setPickstate(Workbill.PICKSTATE_NO);//取件状态 workbill.setRemark(model.getRemark());//添加备注 workbill.setStaff(staff);//关联取派员 workbill.setType(Workbill.ORDERTYPE_1);//工单类型 workbillDao.save(workbill); //调用短信平台发短信 &#125;else&#123; //查不到不能自动分单 model.setOrdertype(Noticebill.ORDERTYPE_MAN); &#125; &#125;&#125; datagrid 数据表格编辑功能使用方式 数据表格编辑功能以列为单位 以列属性来指定哪列具有编辑功能 权限控制 拦截权限控制 底层根据 过滤器 或 拦截器 实现 方法注解权限控制 底层基于代理技术实现，为 Action 设置一个注解，那么就会给 Action 创建代理对象，由代理对象进行权限校验（类似事务控制的 transactional） authenticate:权限，认证 anonymous:匿名 认证：系统提供的用于识别用户身份的功能，通常认证就是登陆–让系统知道你是谁 授权：系统授予用户可以访问那些功能的许可（证书）–让系统知道你能干什么 创建权限控制模型： 权限表 角色表 用户表 角色权限关系表 用户权限关系表 资源表（用来对应是否有某个按钮功能） 资源权限关系表 资源表与资源权限表不一定存在 早期框架 EJB 框架（enterprise java bean， 企业级 java bean，已被 spring 替代） entity bean （实体bean）– hibernate session bean （会话 bean） message bean（信息 bean） shiro 框架认证流程： Application Code：应用程序代码，由开发人员负责开发 subject：提供框架的接口，代表当前用户对象 SecurityManager：框架提供的接口，代表安全管理器对象 Realm：可以开发人员编写，框架也提供一部分，类似于 DAO ，用于访问权限数据 Application Code–&gt;subject–&gt;shiro SecurityManager–&gt;Realm shiro 的使用 在项目的 pom.xml 中引入 shiro 的依赖（shiro-all） 在 web.xml 中配置一个过滤器，spring 提供的，用于整合 shiro 框架 123456789&lt;!-- 配置spring框架提供的用于整合shiro框架的过滤器 --&gt;&lt;filter&gt; &lt;filter-name&gt;shiroFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;shiroFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 在 spring 中配置文件中配置 bean ，id 为 shiroFilter 1234567891011121314151617181920212223&lt;!--配置 shiro 框架的过滤器工厂对象--&gt;&lt;bean id="shiroFilter" class="org.apache.shiro.spring.web.ShiroFilterFactoryBean"&gt; &lt;!--注入安全器管理对象--&gt; &lt;property name="securityManager" ref="securityManager"/&gt; &lt;!--注入相关页面访问 URL--&gt; &lt;property name="loginUrl" value="/login.jsp"/&gt; &lt;property name="successUrl" value="/index.jsp"/&gt; &lt;property name="unauthorizedUrl" value="/unauthorized.jsp"/&gt; &lt;!--注入 url 拦截器规则--&gt; &lt;property name="filterChainDefinitions"&gt; &lt;value&gt; /css/** = anon /js/** = anon /images/** = anon /validatecode.jsp* = anon /*login.jsp = anon /UserAction_login.action = anon /page_base_staff.action = perms["staff-list"] /* = authc &lt;/value&gt; &lt;/property&gt;&lt;/bean&gt; anon：匿名访问过滤器，没登录时也能访问 authc：登录访问，不登录不能访问 perms：指定权限校验 roles：指定某个角色 ssl：指定是否安全链接，https 在 spring 中配置安全管理器 12345&lt;!--注册安全管理器对象--&gt;&lt;bean id="securityManager" class="org.apache.shiro.web.mgt.DefaultWebSecurityManager"&gt; &lt;!--根据 DefaultWebSecurityManager 父类的 setRealm 方法注入--&gt; &lt;property name="realm" ref="bosRealm"/&gt;&lt;/bean&gt; 修改 UserAction 的 login 方法，使用 shiro 提供的方式进行认证 1234567891011121314151617181920212223242526272829 /** * 用户登录方法,使用 shiro 框架 * @return */ public String login()&#123;// 查看验证码是否正确，先从 session 获得正确的验证码 String validatecode = (String) ServletActionContext.getRequest().getSession().getAttribute("key"); if(StringUtils.isNotBlank(checkcode) &amp;&amp; checkcode.equals(validatecode))&#123;// 使用 shiro 框架提供的方式进行认证 Subject subject = SecurityUtils.getSubject();//获得当前用户对象，状态为未认证 AuthenticationToken token = new UsernamePasswordToken(model.getUsername(), MD5Utils.md5(model.getPassword())); try &#123; subject.login(token); &#125; catch (AuthenticationException e) &#123; e.printStackTrace(); return LOGIN; &#125; //取出放到 SimpleAuthenticationInfo 的第一个参数 User user = (User) subject.getPrincipal(); ServletActionContext.getRequest().getSession().setAttribute("loginUser",user); return HOME; &#125; else&#123; //验证码错误 this.addActionError("验证码错误"); return LOGIN; &#125; &#125; 自定义 realm，并注入给安全管理器 12345678910111213141516171819@Override//认证方法protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException &#123; System.out.println("自定义 realm 认证方法"); //根据用户名查询数据库中的方法 UsernamePasswordToken passwordToken = (UsernamePasswordToken) token; //获得页面输入的用户名 String username = passwordToken.getUsername(); //根据用户名查询数据库中的密码 User user = userDao.findUserByUserName(username); if(user==null)&#123; //页面输入用户名不存在 return null; &#125; //框架对比数据库中密码与页面密码是否一致,第一个参数将 user 放到了本地线程，可以通过 subject.getPrinclpal() 取出 AuthenticationInfo info = new SimpleAuthenticationInfo(user,user.getPassword(),this.getName()); return info;&#125; 12&lt;!--注册 realm--&gt;&lt;bean id="bosRealm" class="com.itheima.bos.realm.BOSRealm"/&gt; 使用 shiro 的方法注解方式权限控制 在 spring 配置文件中开启 shiro 注解支持 12默认 切面（切点+通知） 自动 代理 创建器DefaultAdvisorAutoProxyCreator 123456789101112&lt;!--开启 shiro 的注释--&gt; &lt;!--自动代理--&gt; &lt;bean id="defaultAdvisorAutoProxyCreator" class="org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator"&gt; &lt;!--ture 强制使用 cglib 创建 Action 代理 如果 value 为 true 对目标类进行强制代理， cglib 会继承 Action 方法，因为 Action 的子类必定有需要的方法，所以不会报错； false 则使用 jdk 代理，会实现一个接口（Service 没接口则实现其父类 ModelDriven 的接口），创建接口的代理类对象，调用其方法如果该接口中没有需要的方法，则会抛出 noSuchMethodExction 异常--&gt; &lt;property name="proxyTargetClass" value="true"/&gt; &lt;/bean&gt; &lt;!--切面类--&gt; &lt;bean class="org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor"/&gt; 在 Action 方法上使用注解 123456789/** * 取派员批量删除方法 */ @RequiresPermissions("staff-delete")//执行该方法需要当前用户具有 staff-delete 权限 public String deleteBatch()&#123;// service 上加了事务注解，那么 staffService 就是一个 代理对象（proxy），走完这个方法才会提交事务 staffService.deleteBatch(ids); return LIST; &#125; 在 struts.xml 中配置全局异常捕获，当 shiro 框架抛出权限不足异常时，跳转到权限不足页面 1234567异常：21:06:44,124 DEBUG DefaultActionInvocation:76 - Executing action method = deleteBatch21:06:44,128 DEBUG AuthorizingRealm:234 - No authorizationCache instance set. Checking for a cacheManager...21:06:44,129 INFO AuthorizingRealm:248 - No cache or cacheManager properties have been set. Authorization cache cannot be obtained.21:06:44,133 DEBUG XWorkMethodAccessor:84 - Error calling method through OGNL: object: [com.itheima.bos.web.action.StaffAction@116394d] method: [deleteBatch] args: [[]]org.apache.shiro.authz.UnauthorizedException: Subject does not have permission [staff-delete]at org.apache.shiro.authz.ModularRealmAuthorizer.checkPermission(ModularRealmAuthorizer.java:323) at org.apache.shiro.mgt.AuthorizingSecurityManager.checkPermission(AuthorizingSecurityManager.java:137) 123456789&lt;!--全局 result 结果集 定义--&gt; &lt;global-results&gt; &lt;result name="login"&gt;/login.jsp&lt;/result&gt; &lt;result name="unauthorized"&gt;/unauthorized.jsp&lt;/result&gt; &lt;/global-results&gt;&lt;global-exception-mappings&gt; &lt;!--配置全局异常，将 shiro 无权限的异常捕获，跳转到权限不足页面，将其配置到全局结果集--&gt; &lt;exception-mapping exception="org.apache.shiro.authz.UnauthorizedException" result="unauthorized"&gt;&lt;/exception-mapping&gt;&lt;/global-exception-mappings&gt; 使用 shiro 的页面标签方式控制权限 在 jsp 页面引入 shiro 的标签库 1&lt;%@taglib prefix="shiro" uri="http://shiro.apache.org/tags" %&gt; 使用 shiro 标签控制页面元素展示 12345678&lt;shiro:hasPermission name="staff-list"&gt;&#123; id: 'button-delete', text: '作废', iconCls: 'icon-cancel', handler: doDelete&#125;,&lt;/shiro:hasPermission&gt; 标签的底层是 java 类，运行时运行的是 java 代码 代码级别权限控制（了解） 在方法的第一行加权限控制代码 能在刚运行方法时进行校验，如果没有权限则抛出异常 12Subject subject = SecurityUtils.getSubject();subject.checkPermission("staff-delete"); 权限数据管理 初始化权限数据 项目上线后，正常运行需要依赖一些基础数据支持，权限数据就属于基础数据，系统菜单就是从权限表查询获得的。一般提供 sql 脚本文件，导入基础数据 添加权限数据 修改父功能点对应的 combobox ，修改 URL 地址 12345&lt;td&gt;父功能点&lt;/td&gt;&lt;td&gt; &lt;input name="parentFunction.id" class="easyui-combobox" data-options="valueField:'id',textField:'info', url:'functionAction_listajax.action'"/&gt;&lt;/td&gt; 创建 FunctionAction、Service、Dao，查询所有权限，返回 json 12345678910111213141516@Controller@Scope("prototype")public class FunctionAction extends BaseAction&lt;Function&gt; &#123; @Autowired private IFunctionService functionService; /** * 查询所有权限返回 json 数据 * @return */ public String listajax()&#123; List&lt;Function&gt; list = functionService.findAll(); this.java2Json(list,new String[]&#123;"parentFunction","children","roles"&#125;); return NONE; &#125;&#125; 配置 strut.xml 为页面添加保存按钮事件 123456789/** * 查询所有权限返回 json 数据 * @return */public String listajax()&#123; List&lt;Function&gt; list = functionService.findAll(); this.java2Json(list,new String[]&#123;&quot;parentFunction&quot;,&quot;children&quot;,&quot;roles&quot;&#125;); return NONE;&#125; 权限分页查询 给 datagrid 的 url 添加地址 12345678910111213141516$(function()&#123; $("#grid").datagrid(&#123; toolbar : [ &#123; id : 'add', text : '添加权限', iconCls : 'icon-add', handler : function()&#123; location.href='$&#123;pageContext.request.contextPath&#125;/page_admin_function_add.action'; &#125; &#125; ], url : 'FunctionAction_pageQuery.action', pagination:true, fit:true, columns : [[ 在 Action 中提供查询方法 12345678910/** * 分页查询方法 */public String pageQuery()&#123; //重新手动设置属性驱动与模型驱动冲突的属性 pageBean.setCurrentPage(Integer.parseInt(model.getPage())); functionService.pageQuery(pageBean); this.java2Json(pageBean,new String[]&#123;"roles","children","parentFunction"&#125;); return NONE;&#125; struts 属性重复错误 struts 属性驱动与模型驱动的属性重复时，优先给模型驱动赋值，若要正确传入重复的属性可以自己进行设置（从模型驱动取出同名值赋给属性驱动的那个属性） 使下拉框变为层级格式 页面上使用 combotree 12345&lt;td&gt;父功能点&lt;/td&gt;&lt;td&gt; &lt;input name="parentFunction.id" class="easyui-combotree" data-options="url:'FunctionAction_listajax.action'"/&gt;&lt;/td&gt; 重写列表查询方法，使其有查询无父节点的节点功能 12345public List&lt;Function&gt; findAll()&#123; String hql = "FROM Function f WHERE f.parentFunction IS NULL"; List&lt;Function&gt; functionList = (List&lt;Function&gt;)this.getHibernateTemplate().find(hql); return functionList;&#125; 在 Function.hbm.xml 中将 children 改为立即加载，使其加载无父节点的顶级节点同时加载子类节点 123456&lt;set name="children" inverse="true" lazy="false"&gt; &lt;key&gt; &lt;column name="pid" /&gt; &lt;/key&gt; &lt;one-to-many not-found="ignore" class="com.itheima.bos.domain.Function"/&gt;&lt;/set&gt; 在 Function.java 的 bean 中添加 getText() 方法，因为 combotree 需要 id 与 text 字段来显示，getText() 方法可以使其在转换为 json 格式时添加一个 text 字段 1234//在转换 json 时加入一个 text 字段public String getText()&#123; return name;&#125; 添加角色功能 修改页面，使用 ztree 勾选效果 12345678910111213141516$(function()&#123; // 授权树初始化 var setting = &#123; data : &#123; key : &#123; title : "t" &#125;, simpleData : &#123; enable : true &#125; &#125;, //此处开启勾选效果 check : &#123; enable : true, &#125; &#125;; 修改 ajax 方法的请求 URL 路径 12345678910111213$.ajax(&#123; url : '$&#123;pageContext.request.contextPath&#125;/FunctionAction_listajax.action', type : 'POST', dataType : 'json', success : function(data) &#123; // 将 dataType 看做 text 格式，并拼接 json 字符串，因为返回的就是 josn 格式字符串，所以不需要 // var zNodes = eval("(" + data + ")"); $.fn.zTree.init($("#functionTree"), setting, data); &#125;, error : function(msg) &#123; alert('树加载异常!'); &#125;&#125;); 为保存按钮绑定事件 1234567891011121314151617181920// 点击保存$('#save').click(function()&#123; var v = $("#roleForm").form("validate"); if(v)&#123; //根据 ztree 的 id 获得 ztree 对象 var ztreeObj = $.fn.zTree.getZTreeObj("functionTree"); //获取 ztree 上选中的节点，返回数组对象 var checkedNodes = ztreeObj.getCheckedNodes(true); var array = new Array(); //遍历数组，获得权限 id,将其加入集合 for(var i=0;i&lt;checkedNodes.length;i++)&#123; var id = checkedNodes[i].id; array.push(id); &#125; //将 ids 添加到隐藏域的 name 属性上，使表单能提交 ids $("input[name=functionIds]").val(array); $("#roleForm").submit(); &#125;&#125;); 服务端实现 action 12345678910111213141516171819202122232425262728/** * 角色管理 */@Controller@Scope("prototype")public class RoleAction extends BaseAction&lt;Role&gt; &#123; //属性驱动，接受 ids private String functionIds; //get 方法只有在页面回显，用 ognl 表达式 或 struts 标签显示时 struts 才会调用 get 方法// public String getFunctionIds() &#123;// return functionIds;// &#125; //set 方法用于接受页面传过来的属性 public void setFunctionIds(String functionIds) &#123; this.functionIds = functionIds; &#125; @Autowired private IRoleService roleService; /** * 添加角色 */ public String add()&#123; roleService.save(model,functionIds); return LIST; &#125;&#125; service 1234567891011121314151617181920212223242526@Service@Transactionalpublic class RoleServiceImpl implements IRoleService &#123; @Autowired private IRoleDao roleDao; @Override /** * 保存一个角色，同时关联一个对象 */ public void save(Role model, String functionIds) &#123; roleDao.save(model); if(StringUtils.isNotBlank(functionIds))&#123; String[] fIds = functionIds.split(","); for(String functionId : fIds)&#123; //可以根据 Function id 查询 Function 对象，也可以直接创建一个 Function 对象，给他一个 id //因为有 id 所以对象为托管状态，而不是游离状态 Function function = new Function(functionId); //角色关联，持久状态对象能关联托管状态，不能关联瞬时状态, //如果 Role.hbm.xml 中设置了 inverse="true" 则不能让角色关联权限了(放弃维护关系) model.getFunctions().add(function); &#125; &#125; &#125;&#125; Hibernate 实体类三种状态 瞬时态:对象里面没有id值,对象与session没有关联 持久态:对象里面有id值,对象与session关联 托管态:对象有id值,对象与session没有关系 实体类只是瞬时态的时候,才做添加操作 实体类是持久态和托管态的时候,都做的是修改操作 用户管理 添加用户 发送 ajax 请求，获取角色数据，在回调函数中动态显示角色数据，展示为 checkbox 1234567891011121314151617181920212223&lt;tr&gt; &lt;td&gt;选择角色:&lt;/td&gt; &lt;td colspan="3" id="roleTD"&gt; &lt;script type="text/javascript"&gt; // 该页面是浏览器根据 js 代码运算获得的，在浏览器查看页面元素-查看框架源代码（查看的是服务器 tomcat 运算后传过来的代码）中只能看到 js 代码， // 但在浏览器工具可以查看元素查看运算后代码 $(function()&#123; //页面加载完成后，发送 ajax 请求，获取所有角色数据 $.post('RoleAction_listajax.action',function(data)&#123; //在 ajax 回调函数解析 json 数据，展示为 checkbox for(var i=0;i&lt;data.length;i++)&#123; var name = data[i].name; var id = data[i].id; $("#roleTD").append('&lt;input type="checkbox" id="'+id+'" name="roleIds" value="'+id+'"/&gt;&lt;label for="'+id+'"&gt;'+name+'&lt;/label&gt;'); &#125; &#125;); &#125;); &lt;/script&gt; &lt;%--添加选择框点击文字可勾选属性--%&gt; &lt;%--&lt;input type="checkbox" value="abc" id="test"/&gt;--%&gt; &lt;%--&lt;label for="test"&gt;lalala&lt;/label&gt;--%&gt; &lt;/td&gt;&lt;/tr&gt; 在 RoleAction 提供 listajax 方法，提供 json 数据 action 123456789101112//属性驱动接受多个角色 idprivate String[] roleIds;public void setRoleIds(String[] roleIds) &#123; this.roleIds = roleIds;&#125;/** * 保存用户方法 */public String add()&#123; userService.save(model,roleIds); return LIST;&#125; service 1234567891011121314151617181920/** * 添加一个用户，同时关联角色 * @param model * @param roleIds */@Overridepublic void save(User model, String[] roleIds) &#123; String password = model.getPassword(); password = MD5Utils.md5(password); model.setPassword(password); userDao.save(model); if(roleIds!=null&amp;&amp;roleIds.length&gt;0)&#123; for(String roleId : roleIds)&#123; Role role = new Role(roleId); //用户对象关联角色对象 model.getRoles().add(role); &#125; &#125;&#125; 为保存按钮绑定事件，校验并提交表单 用户管理 分页查询 action 123456789/** * 用户数据的分页查询 */public String pageQuery()&#123; userService.pageQuery(pageBean); //json 转换 Date 出现异常，将其排除并使用 getBirthdayString 添加新字段 java2Json(pageBean,new String[]&#123;"noticebills","roles","birthday"&#125;); return NONE;&#125; user bean 123456789101112131415161718//拼接 roleNamepublic String getRoleNames()&#123; String roleNames = ""; for(Role role : roles)&#123; String name = role.getName(); roleNames += name; &#125; return roleNames;&#125; //json 转换 Date 出现异常，将其排除并使用 getBirthdayString 添加新字段public String getBirthdayString()&#123; if(birthday!=null)&#123; String format = new SimpleDateFormat("yyyy-MM-dd").format(birthday); return format; &#125;else&#123; return "暂无数据"; &#125;&#125; 修改 Realm 中授权方法（查询数据库获得用户权限） BOSRealm 1234567891011121314151617181920//授权方法 protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) &#123; SimpleAuthorizationInfo info = new SimpleAuthorizationInfo(); //获得当前登录用户 2 种方法，选其一 User user = (User) principals.getPrimaryPrincipal();// User user1 = (User) SecurityUtils.getSubject().getPrincipal(); //根据当前登录用户查询数据库，获取实际对应的权限 List&lt;Function&gt; list = null; if(user.getUsername().equals("admin"))&#123;// 如果是内置管理员则查询所有权限 DetachedCriteria detachedCriteria = DetachedCriteria.forClass(Function.class); list = functionDao.findByCriteria(detachedCriteria); &#125;else&#123; list= functionDao.findFunctionByUserId(user.getId()); &#125; for(Function f : list)&#123; info.addStringPermission(f.getCode()); &#125; return info; &#125; 在 FunctionDao 扩展方法，根据用户 id 查询对应权限，用 select 选择需要查询的字段，使用 DISTINCT 去除重复的字段 12345678910111213/** * 根据用户 id 查询用户对应权限 * @param id * @return */@Overridepublic List&lt;Function&gt; findFunctionByUserId(String id) &#123; //加上 select f ，让其只查询权限表的字段，就只会封装 Object 对象。如果查询全部表的字段，hibernate 会自动封装成 object 对象 //DISTINCT 排除查询出来的重复字段 String hql = " SELECT DISTINCT f FROM Function f LEFT OUTER JOIN f.roles r LEFT OUTER JOIN r.users u WHERE u.id=?"; List&lt;Function&gt; list = (List&lt;Function&gt;) this.getHibernateTemplate().find(hql, id); return list;&#125; 未添加 Select f 选择查询的语句 1234567891011121314151617181920212223242526272829303132333435363738select function0_.id as id1_0_0_, role2_.id as id1_1_1_, user4_.id as id1_10_2_, function0_.name as name2_0_0_, function0_.code as code3_0_0_, function0_.description as descript4_0_0_, function0_.page as page5_0_0_, function0_.generatemenu as generate6_0_0_, function0_.zindex as zindex7_0_0_, function0_.pid as pid8_0_0_, role2_.name as name2_1_1_, role2_.code as code3_1_1_, role2_.description as descript4_1_1_, user4_.username as username2_10_2_, user4_.password as password3_10_2_, user4_.salary as salary4_10_2_, user4_.birthday as birthday5_10_2_, user4_.gender as gender6_10_2_, user4_.station as station7_10_2_, user4_.telephone as telephon8_10_2_, user4_.remark as remark9_10_2_ from auth_function function0_ left outer join role_function roles1_ on function0_.id=roles1_.function_id left outer join auth_role role2_ on roles1_.role_id=role2_.id left outer join user_role users3_ on role2_.id=users3_.role_id left outer join t_user user4_ on users3_.user_id=user4_.id where user4_.id=? 添加 Select f 后的查询语句 12345678910111213141516171819202122232425select function0_.id as id1_0_, function0_.name as name2_0_, function0_.code as code3_0_, function0_.description as descript4_0_, function0_.page as page5_0_, function0_.generatemenu as generate6_0_, function0_.zindex as zindex7_0_, function0_.pid as pid8_0_ from auth_function function0_ left outer join role_function roles1_ on function0_.id=roles1_.function_id left outer join auth_role role2_ on roles1_.role_id=role2_.id left outer join user_role users3_ on role2_.id=users3_.role_id left outer join t_user user4_ on users3_.user_id=user4_.id where user4_.id=? 用 ehcache 缓存权限数据ehcache 是专门的缓存插件，用来缓存 java 对象，提高系统性能 引入 ehcache 依赖 123456&lt;!-- 引入ehcache的依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;net.sf.ehcache&lt;/groupId&gt; &lt;artifactId&gt;ehcache-core&lt;/artifactId&gt; &lt;version&gt;2.6.6&lt;/version&gt;&lt;/dependency&gt; 引入 ehcache.xml maxElementsInMemory：内存存储 java 对象个数 eternal：是否永久有效 timeToIdleSeconds：最大空闲时间timeToLiveSeconds：存活时间，生命周期 overflowToDisk：溢出到磁盘，查询多出来的 java 对象个数存放到磁盘 diskStore path=”java.io.tmpdir” 下 maxElementsOnDisk：磁盘存放最大个数 diskPersistent：tomcat 重启后是否保存磁盘上的数据 diskExpiryThreadIntervalSeconds：线程启动时间 memoryStoreEvictionPolicy：淘汰策略：1.LRU最近利用率最低的优先淘汰; 2.FIFO.先进先出 12345678910111213141516&lt;ehcache xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="../config/ehcache.xsd"&gt; &lt;diskStore path="java.io.tmpdir"/&gt; &lt;defaultCache maxElementsInMemory="10000" eternal="false" timeToIdleSeconds="120" timeToLiveSeconds="120" overflowToDisk="true" maxElementsOnDisk="10000000" diskPersistent="false" diskExpiryThreadIntervalSeconds="120" memoryStoreEvictionPolicy="LRU" /&gt;&lt;/ehcache&gt; 在 spring 配置文件配置缓存管理器，并注入给安全管理器对象 12345678910111213&lt;!--注册安全管理器对象--&gt;&lt;bean id="securityManager" class="org.apache.shiro.web.mgt.DefaultWebSecurityManager"&gt; &lt;!--根据 DefaultWebSecurityManager 父类的 setRealm 方法注入--&gt; &lt;property name="realm" ref="bosRealm"/&gt; &lt;!--注入缓存器--&gt; &lt;property name="cacheManager" ref="cacheManager"/&gt;&lt;/bean&gt;&lt;!--注册缓存管理器--&gt;&lt;bean id="cacheManager" class="org.apache.shiro.cache.ehcache.EhCacheManager"&gt; &lt;!--注入 ehcache 配置文件--&gt; &lt;property name="cacheManagerConfigFile" value="classpath:ehcache.xml"/&gt;&lt;/bean&gt; 根据登录用户动态显示系统菜单 修改 index.jsp 页面中 ajax 方法的请求地址 12345678910111213// 基本功能菜单加载$.ajax(&#123; url : '$&#123;pageContext.request.contextPath&#125;/FunctionAction_findMenu.action', type : 'POST', dataType : 'text', success : function(data) &#123; var zNodes = eval("(" + data + ")"); $.fn.zTree.init($("#treeMenu"), setting, zNodes); &#125;, error : function(msg) &#123; alert('菜单加载异常!'); &#125;&#125;); action 12345678/** * 根据当前登录用户查询对应菜单数据，并返回 json */public String findMenu()&#123; List&lt;Function&gt; list = functionService.findMenu(); this.java2Json(list,new String[]&#123;"parentFunction","roles","children"&#125;); return NONE;&#125; service 1234567891011121314151617/** * 根据当前登录用户查询对应菜单数据，并返回 json */ @Override public List&lt;Function&gt; findMenu() &#123; User user = BOSUtils.getLoginUser(); List&lt;Function&gt; list = null; if(user.getUsername().equals("admin"))&#123; //如果是超级管理员则返回所有菜单 list = functionDao.findAllMenu(); &#125; else&#123;// 根据用户查询菜单 list = functionDao.findMenuByUserId(user.getId()); &#125; return list; &#125; dao DESC 是descend 降序asc 是ascend 升序 ORDER BY xxx DESC :根据 xxx 字段逆序排序，默认升序 123456789101112131415161718192021222324/** * 查询所有菜单 * @return */ @Override public List&lt;Function&gt; findAllMenu() &#123; String hql = "FROM Function f WHERE f.generatemenu = '1' ORDER BY f.zindex DESC"; List&lt;Function&gt; list = (List&lt;Function&gt;) this.getHibernateTemplate().find(hql); return list; &#125; /** * 根据用户 id 查询菜单 * @param id * @return */ @Override public List&lt;Function&gt; findMenuByUserId(String id) &#123; String hql = " SELECT DISTINCT f FROM Function f LEFT JOIN f.roles r LEFT JOIN r.users u WHERE u.id=? " + " AND f.generatemenu = '1' ORDER BY f.zindex DESC "; List&lt;Function&gt; list = (List&lt;Function&gt;) this.getHibernateTemplate().find(hql,id); return list; &#125; domian 添加 json 返回 123456public String getpId()&#123; if(parentFunction==null)&#123; return "0"; &#125; return parentFunction.getId();&#125; 使用 quartz 与 javaMail 定时发送邮件 引入依赖 123456789101112131415161718&lt;!--引入 quartz 对应依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;org.quartz-scheduler&lt;/groupId&gt; &lt;artifactId&gt;quartz&lt;/artifactId&gt; &lt;version&gt;2.2.3&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.quartz-scheduler&lt;/groupId&gt; &lt;artifactId&gt;quartz-jobs&lt;/artifactId&gt; &lt;version&gt;2.2.3&lt;/version&gt;&lt;/dependency&gt;&lt;!--引入 javaMail 依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;javax.mail&lt;/groupId&gt; &lt;artifactId&gt;mail&lt;/artifactId&gt; &lt;version&gt;1.4&lt;/version&gt;&lt;/dependency&gt; 提供一个作业类，为系统管理员发送邮件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182/** * 发送邮件的作业 * @author zhaoqx * */public class MailJob &#123; @Resource private IWorkbillDao workbillDao; private String username;//发件人邮箱账号 private String password;//密码 private String smtpServer;//服务器 public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public void execute() &#123; System.out.println("要发邮件了。。。" + new Date()); try &#123; //查询工单类型为新单的所有工单 List&lt;Workbill&gt; list = workbillDao.findAll(); if(null != list &amp;&amp; list.size() &gt; 0)&#123; final Properties mailProps = new Properties(); mailProps.put("mail.smtp.host", this.getSmtpServer()); mailProps.put("mail.smtp.auth", "true"); mailProps.put("mail.username", this.getUsername()); mailProps.put("mail.password", this.getPassword()); // 构建授权信息，用于进行SMTP进行身份验证 Authenticator authenticator = new Authenticator() &#123; protected PasswordAuthentication getPasswordAuthentication() &#123; // 用户名、密码 String userName = mailProps.getProperty("mail.username"); String password = mailProps.getProperty("mail.password"); return new PasswordAuthentication(userName, password); &#125; &#125;; // 使用环境属性和授权信息，创建邮件会话 Session mailSession = Session.getInstance(mailProps, authenticator); for(Workbill workbill : list)&#123; // 创建邮件消息 MimeMessage message = new MimeMessage(mailSession); // 设置发件人 InternetAddress from = new InternetAddress(mailProps.getProperty("mail.username")); message.setFrom(from); // 设置收件人 InternetAddress to = new InternetAddress("test@itcast.cn"); message.setRecipient(RecipientType.TO, to); // 设置邮件标题 message.setSubject("系统邮件：新单通知"); // 设置邮件的内容体 message.setContent(workbill.toString(), "text/html;charset=UTF-8"); // 发送邮件 Transport.send(message); &#125; &#125; &#125; catch (Exception ex) &#123; ex.printStackTrace(); &#125; &#125; public String getSmtpServer() &#123; return smtpServer; &#125; public void setSmtpServer(String smtpServer) &#123; this.smtpServer = smtpServer; &#125;&#125; 配置 spring bean 12345678910111213141516171819202122232425262728293031323334&lt;!-- 注册自定义作业类,注入邮箱账号密码及属性 --&gt;&lt;bean id="myJob" class="com.itheima.bos.jobs.MailJob"&gt; &lt;property name="username" value="crowsong@126.com"/&gt; &lt;property name="password" value="63509363"/&gt; &lt;property name="smtpServer" value="smtp.126.com"/&gt;&lt;/bean&gt;&lt;!-- 配置JobDetail --&gt;&lt;bean id="jobDetail" class="org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean"&gt; &lt;!-- 注入目标对象 --&gt; &lt;property name="targetObject" ref="myJob"/&gt; &lt;!-- 注入目标方法 --&gt; &lt;property name="targetMethod" value="execute"/&gt;&lt;/bean&gt;&lt;!-- 配置触发器 --&gt;&lt;bean id="myTrigger" class="org.springframework.scheduling.quartz.CronTriggerFactoryBean"&gt; &lt;!-- 注入任务详情对象 --&gt; &lt;property name="jobDetail" ref="jobDetail"/&gt; &lt;!-- 注入cron表达式，通过这个表达式指定触发的时间点 --&gt; &lt;property name="cronExpression"&gt; &lt;value&gt;0/5 * * * * ?&lt;/value&gt; &lt;/property&gt;&lt;/bean&gt;&lt;!-- 配置调度工厂 --&gt;&lt;bean id="schedulerFactoryBean" class="org.springframework.scheduling.quartz.SchedulerFactoryBean"&gt; &lt;!-- 注入触发器 --&gt; &lt;property name="triggers"&gt; &lt;list&gt; &lt;ref bean="myTrigger"/&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt; Highcharts基于 jQuery 开发的一个图形报表工具插件 纯 javascript 编写的一个图标库，不需要 flash java 可以运行 在项目中展示区域分布图 在 subarea.jsp 中引入 资源文件 .js 添加显示图表按钮,并提供一个 div 窗口 123456789// 图表分区$('#showSubareaWindow').window(&#123; width: 600, modal: true, shadow: true, closed: true, height: 400, resizable: false&#125;); 定义 function 123456789101112131415// 显示饼状图function doShowHighcharts() &#123; $("#showSubareaWindow").window("open"); $.post('SubareaAction_findSubareasGroupByProvince.action',function(data)&#123; $('#test').highcharts(&#123; title: &#123; text: '区域分区分布图' &#125;, series: [&#123; type: 'pie', name: '区域分区分布图', data: data &#125;] &#125;); &#125;); 在服务端提供方法 action，service dao 12345@Overridepublic List&lt;Object&gt; findSubareasGroupByProvince() &#123; String hql = "SELECT r.province,count(*) FROM Subarea s LEFT JOIN s.region r GROUP BY r.province"; return (List&lt;Object&gt;) this.getHibernateTemplate().find(hql);&#125; 在 Linux 下部署应用 Linux 的 mysql 下创建表，并创建一个用户，给他权限 创建表：create database bos32 character set utf8; 创建用户密码：create user joker identified by &#39;1234&#39;; 给用户操作表的所有权限：grant all on bos32.* to joker; 查询数据库的用户 showdatabases;：查看所有的数据库名称 use mysql;：使用 mysql 库 show tables;：查看 mysql 库的所有表，可以看到 mysql 中有 user 项 desc user;：查看 user 数据表结构，跟 show columns from user; 效果相同 select host,user from user ：查看 user 表中的 host 与 user 属性值 host 为 % 表示必须指定连接的 ip 地址（用于远程连接），即使是本地连接的也要指定；host 为 localhost 用于本地连接 desc 用法 mysql 连接到 Linux 服务器 导入 bos 项目的表 改变数据库访问地址，使用 idea 导出项目 war 包 whereis tomcat 查看软件安装路径，将 war 包导入到 tomcat 的 webapps 路径下 在 tomcat/logs 目录下 tail -f catalina.out 打开日志记录文件，查看动态日志 在 tomcat/bin 目录下 sh startup.sh 开启 tomcat tomcat 报错端口被占用，jps 查看已启动的服务 [root@localhost bin]# jps2818 Bootstrap4516 Bootstrap 全部 kill 掉 [root@localhost bin]# kill -9 2818[root@localhost bin]# kill -9 4516 再次重启 tomcat 访问地址 linux ip:8080/发布项目文件夹名/ 192.168.171.128:8080/bos-web-1.0-SNAPSHOT/ 访问出错的可能是 Linux 的 tomcat 、jdk 版本与 idea 的不一致 freemark 模板技术 codemachine 代码生成器，提供静态代码模板，将数据放入模板生成静态页面，用来生成重复量大的静态页面 ExtJS是一个纯粹的JavaScript应用程序框架（英语：application framework），用于使用Ajax、DHTML和DOM脚本构建交互式跨平台网络应用程序。 POI 导出 Execel 文件 IText 导出 PDF 文件 Q&amp;AQ: 数据库查询错误Could not open JDBC Connection for transaction; nested exception is java.sql.SQLException: No suitable driver found for jdbc:mysql///crm A: jdbc:mysql 后没加 : Q: SQL 查询错误StatementCallback; bad SQL grammar [select * from t_customer]; nested exception is java.sql.SQLException: Column ‘telphone’ not found A: bean 中字段错误，tel + e + phone Q：SQL 查询错误，显示全为 not defined null1String sql = "select * from t_customer where decidedzone_id = ?;"; 将 id=? 写成了 id is ?,查询错误 Q:表单提交数据错误customerIds: 小黑(13722222222) \A: &lt;select>\&lt;option value=’”+id+”‘>“+name+”\&lt;/option>\&lt;/select> 中的值 value 是表单会提交的参数 如果将 value 写作 id，那么表单会提交 name 所在位置的值 Q: hibernate 查询数据库错误Caused by: org.apache.cxf.binding.soap.SoapFault: PreparedStatementCallback; SQL [update t_customer set decidedzone_id = null where decidedzone_id = 12;]; Parameter index out of range (1 &gt; number of parameters, which is 0).; nested exception is java.sql.SQLException: Parameter index out of range (1 &gt; number of parameters, which is 0) A：You will get this error when you call any of the setXxx() methods on PreparedStatement, while the SQL query string does not have any placeholders ? for this. 大意是准备的 sql 语句中 ？ 占位符数与传入参数数量 不匹配 Q: 录入信息时，只有某几个值无法录入A：idea 逆向工程生成 hbm.xml 文件时，没有将这几个值正确设置为 多对一的外键，导致无法录入 Q:创建数据库时无法将一个表外键关联到另一个表的主键上MySQL error 1452 - Cannot add or update a child row: a foreign key constraint fails 将一个表外键关联到另一表主键时一直报错，经搜索发现是子表外键所要关联的其他表主键数据不存在，或者是两张表的属性不都是 InoDB，但都不是我的问题所在。 最后终于找到了一个方法:将子表的外键所在字段删除，重新创建，即可关联上其他表的主键 删除要成为外键的列。 再次创建它，但将其默认值设置为NULL。 尝试再次将其设置为外键。 参考：https://cloud.tencent.com/developer/ask/60529 第一条回答 Q：TOMCAT 严重: Error filterStart启动 tomcat 过滤器错误 A:1、试着把tomat/server/lib目录下的commons-digester.jar,commons-beanutils.jar拷贝到common/lib/目录 －－经测试不行2、里有个文章说tomcat里的bug,没有实现javax.servlet.Filter的Filter会报这样的错误，看来tomcat在启动就初始化Filter实例，但是在filter中又没有看到那段代码没有实现Filter，或者有代码在启动时没有实例化。－－没发现问题。 3、web.xml 初始化参数少了 自己的解决问题：注册安全管理器对象错误。少写了一个 web 正确： 1&lt;bean id="securityManager" class="org.apache.shiro.web.mgt.DefaultWebSecurityManager"/&gt; 错误： 1&lt;bean id="securityManager" class="org.apache.shiro.mgt.DefaultSecurityManager"/&gt; 参考：TOMCAT 严重: Error filterStart Q:嵌套错误org.springframework.beans.factory.BeanCreationException: Error creating bean with name ‘shiroFilter’ defined in class path resource [applicationContext.xml]: Cannot resolve reference to bean ‘securityManager’ while setting bean property ‘securityManager’; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name ‘securityManager’ defined in class path resource [applicationContext.xml]: Cannot resolve reference to bean ‘bosRealm’ while setting bean property ‘realm’; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name ‘bosRealm’: Injection of autowired dependencies failed; nested exception is org.springframework.beans.factory.BeanCreationException: Could not autowire field: private com.itheima.bos.dao.IUserDao com.itheima.bos.realm.BOSRealm.userDao; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name ‘userDaoImpl’: Injection of resource dependencies failed; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name ‘sessionFactory’ defined in class path resource [applicationContext.xml]: Invocation of init method failed; nested exception is org.hibernate.MappingException: An association from the table user_role refers to an unmapped class: com.itheima.bos.reverse.User A: 因为复制过来的 Role.hbm.xml 错误引用了另一个文件夹的 User 导致加载失败 Q: hibernate 实体错误 Unknown entity: com.itheima.bos.domain.Function Unknown entity: com.itheima.bos.domain.Function; nested exception is org.hibernate.MappingException: Unknown entity: com.itheima.bos.domain.Function Q: bean 复制时没有将 hbm.xml 中的路径修改 Q：easyui 的 combotree 下拉列表有结构，但数据为空A：combotree 需要的字段是 id 跟 text，自己返回的 json 数据只有数据库里有的字段类型，所以需要添加一个 text 字段进 json 在需要添加的 bean 中加入 get 方法 ,返回需要的属性值，此时 json 就会多一个 “text”: “name” 的字段 12345//在转换 json 时加入一个 text 字段public String getText()&#123; //text 等于那个属性的值 return name;&#125; 可以参考的其他方法： 使用easyui comboTree加载菜单时,后台字段和规定字段不一致无法加载问题 Q：tomcat 启动报错 hibernate 错误nested exception is org.hibernate.boot.InvalidMappingException: Could not parse mapping document: null (INPUT_STREAM) 一连串的 nested A：经过查询应该是映射文件错误，修改 hbm.xml 文件中的错误即可 Q: Unknown entity 异常nested exception is org.hibernate.boot.InvalidMappingException: Could not parse mapping document: null (INPUT_STREAM) A：又是一个 hbm.xml 移动文件夹位置后没有修改其中路径的问题 Q：空指针异常java.lang.NullPointerException 123com.itheima.bos.service.impl.RoleServiceImpl.save(RoleServiceImpl.java:31)sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) A:需要在调用 Functions 前先创建 Set 集合 1model.getFunctions().add(function); 或者直接在 Function Bean 中直接创建好 Set 1private Set&lt;Function&gt; functions = new HashSet(0);//当前角色对应的多个权限 Q：保存角色后只执行了一个 insertA：model 中存放的 Role 实体类的 hbm.xml 文件中，添加了 inverse=“true” ,表示反转，放弃维护外键，从而无法添加外键 Function 12345678&lt;set name="functions" /**inverse="true"**/ table="role_function" schema="bos32" &gt; &lt;key&gt; &lt;column name="role_id"/&gt; &lt;/key&gt; &lt;many-to-many not-found="ignore" class="com.itheima.bos.domain.Function"&gt; &lt;column name="function_id"/&gt; &lt;/many-to-many&gt;&lt;/set&gt; 123//角色关联，持久状态对象能关联托管状态，不能关联瞬时状态,//如果 Role.hbm.xml 中设置了 inverse="true" 则不能让角色关联权限了(放弃维护关系)model.getFunctions().add(function); Q:java.lang.reflect.InvocationTargetExceptionA：json 转换 Date 会出现问题 方案一：不使用 Date 转换，将 birthday 排除转换，并使用 birthdayString，在页面也使用此属性接受 1java2Json(pageBean,new String[]&#123;"noticebills","roles","birthday"&#125;); 12345678public String getBirthdayString()&#123; if(birthday!=null)&#123; String format = new SimpleDateFormat("yyyy-MM-dd").format(birthday); return format; &#125;else&#123; return "暂无数据"; &#125;&#125; 或者其他方式（未尝试） https://blog.csdn.net/ye1992/article/details/17436765 Q:使用 ehcache 缓存后会出现异常 java.io.NotSerializableExceptionA:对于需要缓存的类需要加上 Serializable 接口 1public class User implements java.io.Serializable]]></content>
      <tags>
        <tag>java</tag>
        <tag>web</tag>
        <tag>ssh</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BOS_former]]></title>
    <url>%2F2019%2F02%2F14%2Fbos%2F</url>
    <content type="text"><![CDATA[主流软件系统管理： OA 系统（Office automation）办公自动化，将现代化办公和计算机网络结合的新型办公方式 CRM 系统（Customer Relationship Management）客户关系管理，企业用 CRM 技术来管理与客户间的关系 ERP 系统（Enterprise Resource Planning）企业资源计划，针对物资管理（物流）、人力资源管理（人流）、财务资源管理（财流）、信息资源管理（信息流）集成一体的企业管理软件 Maven 项目环境使用 maven 工具可以进行 依赖管理 和 项目构建 bos-parent：父工程，统一管理依赖，是一个聚合工程（可以简化操作，只需要在聚合中执行一次，其子工程可以一起执行） bos-web bos-service bos-dao bos-domain bos-utils struts 配置文件中，action 中不写 class=“” ，就会访问org/apache/struts/struts2-core/2.3.24/struts2-core-2.3.24.jar!/struts-default.xml 下的默认 class&lt;default-class-ref class=&quot;com.opensymphony.xwork2.ActionSupport&quot; /&gt; ActionSupport 的默认方法 execute(){return SUCCESS}，当restult 中没有 name 属性，默认为 success，直接跳转到 WEB-INF 下 pages/xxx/yyy.jsp。因为 WEB-INF 下的页面收到保护不能直接访问，只能通过 action 跳转 123&lt;action name="page_*_*"&gt; &lt;result type="dispatcher"&gt;/WEB-INF/pages/&#123;1&#125;/&#123;2&#125;.jsp&lt;/result&gt;&lt;/action&gt; easyui 页面布局 layout 12345678&lt;body class="easyui-layout"&gt; &lt;div title="东部菜单" style="height:100px" data-options="region:'north'"&gt;北部区域 &lt;/div&gt; &lt;div style="width:200px" data-options="region:'west'"&gt;西部区域&lt;/div&gt; &lt;div data-options="region:'center'"&gt;中部区域&lt;/div&gt; &lt;div style="width:200px" data-options="region:'east'"&gt;东部区域&lt;/div&gt; &lt;div style="height:50px" data-options="region:'south'"&gt;南部区域&lt;/div&gt;&lt;/body&gt; 折叠面板 accordion 12345678910111213141516&lt;body class="easyui-layout"&gt;&lt;div title="管理系统" style="height:100px" data-options="region:'north'"&gt;北部区域&lt;/div&gt;&lt;div title="系统菜单" style="width:200px" data-options="region:'west'"&gt; &lt;%--fit:自适应，填充父容器--%&gt; &lt;%--arrordion 折叠面板--%&gt; &lt;div class="easyui-accordion" data-options="fit:true"&gt; &lt;div title="面板一"&gt;aaa&lt;/div&gt; &lt;div title="面板二"&gt;bbb&lt;/div&gt; &lt;div title="面板三"&gt;ccc&lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;div data-options="region:'center'"&gt;中部区域&lt;/div&gt;&lt;div style="width:200px" data-options="region:'east'"&gt;东部区域&lt;/div&gt;&lt;div style="height:50px" data-options="region:'south'"&gt;南部区域&lt;/div&gt;&lt;/body&gt; 选项卡面板 tabs 1234567891011121314&lt;body class="easyui-layout"&gt;&lt;div title="管理系统" style="height:100px" data-options="region:'north'"&gt;北部区域&lt;/div&gt;&lt;div title="系统菜单" style="width:200px" data-options="region:'west'"&gt;&lt;/div&gt;&lt;/div&gt;&lt;%--tabs选项卡面板--%&gt;&lt;div class="easyui-tabs" data-options="region:'center'"&gt; &lt;div data-options="iconCls:'icon-cut',closable:true" title="面板一"&gt;aaa&lt;/div&gt; &lt;div data-options="closable:true" title="面板二"&gt;bbb&lt;/div&gt; &lt;div title="面板三"&gt;ccc&lt;/div&gt;&lt;/div&gt;&lt;div style="width:200px" data-options="region:'east'"&gt;东部区域&lt;/div&gt;&lt;div style="height:50px" data-options="region:'south'"&gt;南部区域&lt;/div&gt;&lt;/body&gt; jquery 动态添加 tabs12345678910111213141516171819202122&lt;div class="easyui-accordion" data-options="fit:true"&gt; &lt;div data-options="iconCls:'icon-cut'" title="面板一"&gt; &lt;a id="but1" class="easyui-linkbutton"&gt;添加选项卡&lt;/a&gt; &lt;script type="text/javascript"&gt; $(function()&#123; // 页面加载完成，为按钮添加绑定事件 $("#but1").click(function()&#123; // 调用 tabs 对象的 add 方法 if($("#mytabs").tabs("exists","系统管理"))&#123; $("#mytabs").tabs("select","系统管理"); &#125;else&#123; $("#mytabs").tabs("add",&#123; title:'系统管理', iconCls:'icon-edit', closable:true, content:'&lt;iframe frameborder="0" height="100%" width="100%" src="http://www.baidu.com"&gt;&lt;/iframe&gt;' &#125;); &#125; &#125;); &#125;); &lt;/script&gt; &lt;/div&gt; Ztree 的使用方法一（了解）：利用 json 嵌套 1234567891011121314151617181920212223&lt;div title="面板二"&gt; &lt;%--展示 ztree--%&gt; &lt;%-- 这里 class 必须为 ztree，不然展开样式会无法应用 --%&gt; &lt;ul id="ztree1" class="ztree"&gt;&lt;/ul&gt; &lt;script type="text/javascript"&gt; $(function()&#123; // 页面加载后执行这段代码，表示创建 stree 属性全部为默认值 var setting = &#123;&#125;; // 构造节点数组 var zNodes = [ // 每个 json 对象表示一个节点数据 &#123;"name":"节点一","children":[ &#123;"name":"子节点一"&#125;, &#123;"name":"子节点二"&#125; ]&#125;, &#123;"name":"节点二"&#125;, &#123;"name":"节点三"&#125; ]; // 调用 api 初始化 ztree $.fn.zTree.init($("#ztree1"),setting,zNodes); &#125;); &lt;/script&gt;&lt;/div&gt; 方法二（重要）：利用简单 json 构建子节点 1234567891011121314setting 的区别，将 simpleDate enable 设置为 truevar setting2 = &#123; data: &#123; simpleData: &#123; enable: true &#125; &#125;&#125;;节点数组的区别var zNodes2 = [ // 每个 json 对象表示一个节点数据 &#123;"id":1,"pId":0,"name":"节点一"&#125;, &#123;"id":2,"pId":1,"name":"节点二"&#125;, &#123;"id":3,"pId":2,"name":"节点三"&#125;]; idea 下反向工程生成 entity 及其 hbm.xml 为模块添加 hibernate（不然后面会找不到 persistence 选项） 右侧 （或者 view tool windows） database 点击 + 号，选择 DataSource、Mysql，添加用户密码数据库 左侧（或者 view tool windows）persistence，选择右键 Generate Persistence Mapping - By DataBase Schema 添加 hibernate 持久层支持，生成实体 Bean 、配置文件 选择数据库和要存放 bean 的包，选择需要生成的 DataBase Schema 可以选择不添加 Session Factory，但需要手动添加 选择 Xml per Entity（hbm.xml）或者 JPA Annotation（注释） idea 逆向工程实践 idea hibernate 反向工程 代码抽取持久层代码抽取 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273package com.itheima.bos.dao.base.impl;import com.itheima.bos.dao.base.IbaseDao;import org.hibernate.SessionFactory;import org.springframework.orm.hibernate5.support.HibernateDaoSupport;import javax.annotation.Resource;import java.io.Serializable;import java.lang.reflect.ParameterizedType;import java.lang.reflect.Type;import java.util.List;public class BaseDaoImpl&lt;T&gt; extends HibernateDaoSupport implements IbaseDao&lt;T&gt; &#123;// 代表某个实体类型 private Class&lt;T&gt; entityClass; public BaseDaoImpl()&#123; /**在该类的构造方法中获得调用它的子类的实体类型 * this 代表调用 BaseDaoImpl 的子类,getClass 获得 BaseDaoImpl 子类的类类型， * getGenericSuperclass 表示获得 BaseDaoImpl 子类的父类的类类型，即 BaseDaoImpl 本身 * 为了获取运行时 BaseDaoImpl&lt;T&gt; 中 T 的值,需要用到 Type 的子接口的方法， * 所以将其强转成 ParameterizedType, * 使用 getActualTypeArguments 可以获得父类声明的泛型数组的值,&lt;T,a,b,c&gt; 中可以为多个值 */ ParameterizedType superclass = (ParameterizedType)this.getClass().getGenericSuperclass(); Type[] types = superclass.getActualTypeArguments(); entityClass = (Class) types[0]; &#125; /** * 因为 spring 中使用了注解的方式，没有配置 * &lt;bean id="userDao" class="xxxUserImpl"&gt; * &lt;property name="sessionFactory" ref="sessionFactory"&gt;&lt;/property&gt; * &lt;/bean&gt; * 所以 userDao 无法获得 sessionFactory 对象，需要自己配置注入方法 * 随便创建一个方法，给予 SessionFactory 对象 * spring 中已经配置了 SessionFactory，所以 mySessionFactory可以获得 SessionFactory 参数 * 利用 @Resource 注解注入到 spring * 调用 父类也就是 HibernateDaoSupport 的 * this.hibernateTemplate = createHibernateTemplate(sessionFactory);方法 * 创建 hibernateTemplate 模板对象，然后用 @Resource 注解注入到 spring * @param sessionFactory */ @Resource public void mySessionFactory(SessionFactory sessionFactory)&#123; super.setSessionFactory(sessionFactory); &#125; @Override public void save(T entity) &#123; this.getHibernateTemplate().save(entity); &#125; @Override public void delete(T entity) &#123; this.getHibernateTemplate().delete(entity); &#125; @Override public void update(T entity) &#123; this.getHibernateTemplate().update(entity); &#125; @Override public T findById(Serializable id) &#123; return this.getHibernateTemplate().get(entityClass,id); &#125; @Override public List&lt;T&gt; findAll(T entity) &#123; String hql = "FROM " + entityClass.getSimpleName(); return (List&lt;T&gt;)this.getHibernateTemplate().find(hql); &#125;&#125; 表现层代码抽取 1234567891011121314151617181920212223242526272829303132333435package com.itheima.bos.web.action;import com.opensymphony.xwork2.ActionSupport;import com.opensymphony.xwork2.ModelDriven;import java.lang.reflect.ParameterizedType;import java.lang.reflect.Type;public class BaseAction&lt;T&gt; extends ActionSupport implements ModelDriven&lt;T&gt; &#123; private T model; @Override public T getModel() &#123; return model; &#125; /** * 构造方法动态获取实体类型 * 通过反射获得子类的类类型，然后用 反射 实例化（创建 model 对象） */ public BaseAction()&#123;// 为了使用子类的方法，强转 ParameterizedType genericSuperclass = (ParameterizedType) this.getClass().getGenericSuperclass();// 获得 BaseAction &lt;T&gt; 中 T 的值（获得范型数组&lt;T&gt;) Type[] actualTypeArguments = genericSuperclass.getActualTypeArguments(); Class&lt;T&gt; entityClass = (Class&lt;T&gt;) actualTypeArguments[0];// 通过反射创建对象 try &#123; model = entityClass.newInstance(); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; &#125;&#125; easyUI 的一些方法123456789101112信息提示框$.messager.alert（title, msg, icon, fn）确认方法$.messager.confirm（title, msg, fn）右下角的信息窗$.messager.show(&#123; title:'标题', msg:'内容', timeout:3000, // 表示滑动出现跟消失 showType:'slide' &#125;)； 菜单制作 1234567891011&lt;%--制作菜单--%&gt;&lt;a data-options="iconCls:'icon-help',menu:'#mm'" class="easyui-menubutton" &gt;控制面板&lt;/a&gt;&lt;%--使用 div 创建下拉菜单--%&gt;&lt;div id="mm"&gt; &lt;%--添加修改图标--%&gt; &lt;div onclick="alert('点击事件')" data-options="iconCls:'icon-edit'"&gt;修改密码&lt;/div&gt; &lt;div&gt;联系管理员&lt;/div&gt; &lt;%--分隔符 separate 的缩写，添加分割线--%&gt; &lt;div class="menu-sep"&gt;&lt;/div&gt; &lt;div&gt;退出系统&lt;/div&gt;&lt;/div&gt; 设置拦截器将未登录用户跳转到登录页面编写拦截器，继承 struts2 框架的 MethodFilterInterceptor 类 12345678910111213141516171819public class BOSLoginInterceptor extends MethodFilterInterceptor&#123; /** * 自定义拦截器，实现未登录用户自动跳转到登录页面 * @param actionInvocation * @return * @throws Exception */ @Override protected String doIntercept(ActionInvocation actionInvocation) throws Exception &#123;// 用工具类 从 session 获取登录对象 User user = BOSUtils.getLoginUser(); if(user==null)&#123;// 没登录，跳转到登录页面,LOGIN 等常量来自于 Action 接口，拦截器没有实现 action 接口，所以无法使用，只能自己写字符串 “login” return "login"; &#125;// 放行 return invocation.invoke(); &#125;&#125; 工具类 123456789101112131415161718192021package com.itheima.bos.utils;import com.itheima.bos.domain.User;import org.apache.struts2.ServletActionContext;import javax.servlet.http.HttpSession;/** * BOS 项目的工具类 */public class BOSUtils &#123;// 获取 session 对象 public static HttpSession getSession()&#123; return ServletActionContext.getRequest().getSession(); &#125;// 获取 登录用户对象 public static User getLoginUser()&#123; return (User) BOSUtils.getSession().getAttribute("loginUser"); &#125;&#125; struts2.xml 配置拦截器 123456789101112131415&lt;interceptors&gt; &lt;!--注册自定义拦截器--&gt; &lt;interceptor name="bosLoginInterceptor" class="com.itheima.bos.web.interceptor.BOSLoginInterceptor"&gt; &lt;!--排除登录方法拦截--&gt; &lt;param name="excludeMethods"&gt;login&lt;/param&gt; &lt;/interceptor&gt; &lt;!--定义拦截器栈--&gt; &lt;interceptor-stack name="myStack"&gt; &lt;interceptor-ref name="bosLoginInterceptor"/&gt; &lt;!--struts2 自带的拦截器栈--&gt; &lt;interceptor-ref name="defaultStack"/&gt; &lt;/interceptor-stack&gt;&lt;/interceptors&gt;&lt;!--配置拦截器--&gt;&lt;default-interceptor-ref name="myStack"/&gt; 使用 validatabox 进行非空校验和长度校验 12345678910&lt;tr&gt; &lt;td&gt;新密码：&lt;/td&gt; &lt;%--使用 easyui-valudatebox 属性需要 class 中填写该值，然后可以使用 required=“true”/"required" 进行非空判断，data-optoins="validType:'length[4,6]'"，进行输入密码的长度判断--%&gt; &lt;td&gt;&lt;input required="true" data-options="validType:'length[4,6]'" id="txtNewPass" type="Password" class="txt01 easyui-validatebox" /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt; &lt;td&gt;确认密码：&lt;/td&gt; &lt;td&gt;&lt;input required="true" data-options="validType:'length[4,6]'" id="txtRePass" type="Password" class="txt01 easyui-validatebox" /&gt;&lt;/td&gt; &lt;/tr&gt; 为 jsp 页面方法添加 onclick 事件校验输入密码是否一致 1234567891011121314151617181920212223&lt;script type="text/javascript"&gt;$("#btnEp").click(function()&#123; var isValid = $("#editPasswordForm").form('validate'); if(isValid)&#123; //两次输入是否一致 var v1 = $("#txtNewPass").val(); var v2 = $("#txtRePass").val(); if(v1==v2)&#123; // 一致 $.post("UserAction_editPassword.action",&#123;"password":v2&#125;,function(data)&#123; if(data=="1")&#123; // 提示成功，关闭窗口 $("#editPwdWindow").window("close"); &#125;else&#123; $.messager.alert("提示","修改密码失败") &#125; &#125;); &#125;else&#123; $.messager.alert("提示","两次输入密码不一致"); &#125; &#125;&#125;);&lt;/script&gt; UserAction 的密码校验方法 12345678910111213141516/** * 用户修改密码方法 */ public String editPassword() throws IOException &#123; String flag="1";// 修改当前用户密码 User user = BOSUtils.getLoginUser(); try &#123; userService.editPassword(user.getId(),model.getPassword()); &#125; catch (Exception e) &#123; flag="0"; e.printStackTrace(); &#125; ServletActionContext.getResponse().getWriter().write(flag); return NONE; &#125; UserDao 的密码校验方法,使用 executeUpdate 增加复用性，传入 queryName 参数表示在 hbm.xml 的 hibernate 映射文件中配置的 query 语句名，objects 表示多个参数 123456789101112131415@Override public void executeUpdate(String queryName, Object... objects) &#123; Session currentSession = this.getSessionFactory().getCurrentSession(); Query query = currentSession.getNamedQuery(queryName);// 为 HQL 中 ？ 赋值 int i =0; int length = objects.length; for(Object obj : objects)&#123; query.setParameter(i++,obj); &#125;// 执行更新 query.executeUpdate(); &#125; hibernate 实体 bean 的 映射文件中定义更新语句 1234567891011121314151617181920212223&lt;?xml version='1.0' encoding='utf-8'?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN" "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd"&gt;&lt;hibernate-mapping&gt; &lt;class name="com.itheima.bos.domain.User" table="t_user" schema="bos32"&gt; &lt;id name="id" column="id"/&gt; &lt;property name="username" column="username"/&gt; &lt;property name="password" column="password"/&gt; &lt;property name="salary" column="salary"/&gt; &lt;property name="birthday" column="birthday"/&gt; &lt;property name="gender" column="gender"/&gt; &lt;property name="station" column="station"/&gt; &lt;property name="telephone" column="telephone"/&gt; &lt;property name="remark" column="remark"/&gt; &lt;/class&gt;&lt;%--query 语句--%&gt; &lt;query name="user.editPassword"&gt; UPDATE User SET password = ? WHERE id = ? &lt;/query&gt;&lt;/hibernate-mapping&gt; idea hibernate 映射关系配置 idea hibernae 映射关系配置 添加手机号码校验jsp 端 1234567891011121314151617181920212223242526272829&lt;tr&gt; &lt;td&gt;手机&lt;/td&gt; &lt;td&gt; &lt;script type="text/javascript"&gt; // 扩展手机号校验规则 $(function()&#123; // 为保存按钮添加保存功能 $("#save").click(function()&#123; var v = $("#addStaffForm").form("validate"); if(v)&#123; $("#addStaffForm").submit(); &#125; &#125;); var reg = /^1[3|4|5|7|8][0-9]&#123;9&#125;$/; $.extend($.fn.validatebox.defaults.rules, &#123; telephone:&#123; validator:function(value,param)&#123; return reg.test(value); &#125;, message:'手机号输入格式错误' &#125; &#125;); &#125;); &lt;/script&gt; &lt;input type="text" data-options="validType:'telephone'" name="telephone" class="easyui-validatebox" required="true"/&gt;&lt;/td&gt;&lt;/tr&gt; easyui-datagrid 创建12345678910111213141516171819202122232425262728293031323334&lt;%--使用插件提供的 api 动态创建 datagrid--%&gt;&lt;table id="mytable"&gt;&lt;/table&gt;&lt;script type="text/javascript"&gt; $(function()&#123; $("#mytable").datagrid(&#123; // 指定 ajax 发送请求地址 url:'$&#123;pageContext.request.contextPath&#125;/json/datagrid_data.json', //定义标题行所有的列 columns:[[ &#123;title:'编号',field:'id',checkbox:true&#125;, &#123;title:'姓名',field:'name'&#125;, &#123;title:'性别',field:'age'&#125;, &#123;title:'住址',field:'address'&#125; ]], rownumbers:true, singleSelect:true, // 定义工具栏 toolbar:[ &#123;text:"添加",iconCls:"icon-add", //为按钮绑定单击事件 handler:function()&#123; alert("点击添加"); &#125;&#125;, &#123;text:"删除",iconCls:"icon-remove"&#125;, &#123;text:"修改",iconCls:"icon-edit"&#125;, &#123;text:"查询",iconCls:"icon-search"&#125; ], // 显示分页条 pagination:true &#125;); &#125;);&lt;/script&gt; dao 查询分页方法 123456789101112131415161718192021222324252627/** * 通用查询分页方法 * @param pageBean */ @Override public void pageQuery(PageBean pageBean) &#123; int currentPage = pageBean.getCurrentPage(); int pageSize = pageBean.getPageSize(); DetachedCriteria detachedCriteria = pageBean.getDetachedCriteria(); //查询 pageBean 的 total （总记录数）// 指定 hibernate 发出 sql 语句的形式，rowCount 会发出 count(*) 的 sql detachedCriteria.setProjection(Projections.rowCount()); List&lt;Long&gt; countList = (List&lt;Long&gt;) this.getHibernateTemplate().findByCriteria(detachedCriteria);// 获得 list 集合的第一个数据，因为只有一个数据所以就是 记录数 Long count = countList.get(0);// 将总条数放入 pageBean pageBean.setTotal(count.intValue()); //查询 rows（当前页需要展示的数据集合）// 将 hibernate 发出 sql 语句的形式改回来，select * from xxx 的形式 detachedCriteria.setProjection(null); int firstResult = (currentPage-1)*pageSize; int maxResults = pageSize; List rows = this.getHibernateTemplate().findByCriteria(detachedCriteria, firstResult, maxResults); pageBean.setRows(rows); &#125; web 层分页查询方法 1234567891011121314151617181920212223242526272829/** * 分页查询方法 */ public String pageQuery() throws IOException &#123; PageBean pageBean = new PageBean(); pageBean.setCurrentPage(page); pageBean.setPageSize(rows);// 创建提交离线查询对象，告诉 hibernate 该查哪张表 DetachedCriteria detachedCriteria = DetachedCriteria.forClass(Staff.class); pageBean.setDetachedCriteria(detachedCriteria); staffService.pageQuery(pageBean);// 使用 json-lib 将 pageBean 转化为 json 对象，通过输出流返回页面// jsonObject 用于将单一对象转换成 josn// jsonArray 用于将数组集合转换成 json JsonConfig jsonConfig = new JsonConfig();// 指定不需要转为 josn 的属性 jsonConfig.setExcludes(new String[]&#123;"currentPage","detachedCriteria","pageSize"&#125;); String json = JSONObject.fromObject(pageBean,jsonConfig).toString();// 该方法有重载方法，可以选择是否传入 jsonConfig// String json = JSONObject.fromObject(pageBean).toString();// 将 json 用输出流写回页面 ServletActionContext.getResponse().setContentType("text/json;charset=utf-8"); ServletActionContext.getResponse().getWriter().write(json); return NONE; &#125; response.getWriter()返回的是PrintWriter，这是一个打印输出流。response.getWriter().print(),不仅可以打印输出文本格式的（包括html标签），还可以将一个对象以默认的编码方式转换为二进制字节输出 response.getWriter().write() 和 print 区别 数组集合区别 派件员批量删除按钮添加事件1234567891011121314151617181920212223242526272829&lt;script type="text/javascript"&gt;function doDelete()&#123; // 获得数据表格中选中的行，返回数组对象,如果没有选择则返回空数组 var rows = $("#grid").datagrid("getSelections"); if(rows.length==0)&#123; //没有选中记录，弹出信息 $.messager.alert("提示信息","请选择需要删除的取派员","warning"); &#125;else&#123; //选中了取派员，弹出确认框，是否删除 $.messager.confirm("确认提醒","是否需要删除选中的取派员", function(r)&#123; if(r)&#123; var array = new Array(); //确认删除，发送请求，获取所有选中取派员的 id for(var i=0;i&lt;rows.length;i++)&#123; var staff = rows[i]; var id = staff.id; array.push(id); &#125; // alert(array.join(",")); var ids = array; // location.href = "staffAction_deleteBatch.action?ids="+ids; $.post("staffAction_deleteBatch.action?ids="+ids); &#125; &#125;); &#125;&#125;&lt;/script&gt; 使用 array.join(“,”); 可以指定 array 各个数组间的分割类型，如果不用 array.join(),默认为 , 分隔符 表单回显 12345function doDblClickRow(rowIndex, rowData)&#123; $(&quot;#editStaffWindow&quot;).window(&quot;open&quot;); // 自动回显表单，rowData 参数是一个 json 字段，里面的 name 与表单名一致，所以可以回显 $(&quot;#editStaffForm&quot;).form(&quot;load&quot;,rowData);&#125; web 层表单修改 1234567891011121314151617 /** * 修改取派员信息 * @return */ public String edit()&#123;// 一般表之间有关联关系，直接用 model 数据覆盖会造成其他关联表误操作// 根据 id 查询查询原始数据 Staff staff = staffService.findById(model.getId()); //使用页面提交的数据覆盖原始数据 staff.setName(model.getName()); staff.setTelephone(model.getTelephone()); staff.setHaspda(model.getHaspda()); staff.setStation(model.getStation()); staff.setStandard(model.getStandard()); staffService.update(staff); return LIST; &#125; 文件上传页面不刷新（伪）12345&lt;iframe style="display:none" name="abc"&gt;&lt;/iframe&gt;&lt;form target="abc" action="xxx" method="post" enctype="multipart/form-data"&gt; &lt;input type="file" name="myfile"/&gt; &lt;input type="submit" value="upload"/&gt;&lt;/form&gt; easyui 中 $(&quot;#form&quot;).form(&quot;submit&quot;) 也是采用了隐藏的 iframe 来达到页面不刷新的效果，需要刷新需要使用 $(&quot;#form&quot;).submit() ocupload 的 upload 方法实现文件上传不刷新底层也是 iframe 原理，利用 jquery 页面加载完毕时修改 div 属性，创建一个 div 块来包裹代码，创建一个文件上传的 form 表单，target 提交到 iframe ，创建 type=”file” 的 input 来覆盖在原来的按钮上，点击原来的按钮时，会上传文件并且刷新隐藏的 iframe 页面 不需要点击提交按钮自动提交文件：按钮绑定一个 onchange 事件，选完文件触发 submit() 123456789&lt;script type="text/javascript"&gt; $(function()&#123; $("#myButton").upload(&#123; action:'xxx.action', name:'myFile' &#125;); &#125;);&lt;/script&gt;&lt;input id="myButton" type="button" value="上传"/&gt; hidden 是 style 的 visibility 属性，能让元素不可见，但是还是占据空间 display ：none 是将元素不再渲染，不会占据空间 我们有几种方式可以隐藏一个元素： CSS display的值是none。 type=”hidden”的表单元素。 宽度和高度都显式设置为0。 一个祖先元素是隐藏的，该元素是不会在页面上显示 CSS visibility的值是hidden CSS opacity的指是0 hidden 与 display:none 区别 display:none、visibility:hidden 区别总结 12345//页面加载完成后加载 OCUpload 插件方法$("#button-import").upload(&#123; action:'RegionAction_importXls.action', name:'regionFile'&#125;); 区域导入action 类 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * 区域导入 */ public String importXls() throws Exception &#123; System.out.println(regionFile); List&lt;Region&gt; regionList = new ArrayList&lt;Region&gt;(); //使用 POI 解析 Excel 文件 HSSFWorkbook hssfWorkbook = new HSSFWorkbook(new FileInputStream(regionFile)); HSSFSheet hssfSheet = hssfWorkbook.getSheet("Sheet1"); for(Row row : hssfSheet)&#123; if(row.getRowNum()==0)&#123; continue; &#125; String id = row.getCell(0).getStringCellValue(); String province = row.getCell(1).getStringCellValue(); String city = row.getCell(2).getStringCellValue(); String district = row.getCell(3).getStringCellValue(); String postcode = row.getCell(4).getStringCellValue();// 包装成区域对象 Region region = new Region(id,province,city,district,postcode,null,null,null);// 去除 河北省的 的 省、石家庄市 的 市、桥西区 的 区，等字符串最后一个字符 province = province.substring(0,province.length()-1); city = city.substring(0,city.length()-1); district = district.substring(0,district.length()-1);// 拼接 河北 石家庄 桥西 String info = province + city + district;// 获取各个中文字的首字母 String[] head = PinYin4jUtils.getHeadByString(info);// 把字符数组拼接成字符串 String shortcode = StringUtils.join(head);// 城市编码 shijiazhuang// 将汉字转换成拼音 String cityPY = PinYin4jUtils.hanziToPinyin(city, ""); region.setShortcode(shortcode); region.setCitycode(cityPY); regionList.add(region); &#125; regionService.saveBatch(regionList); return NONE; &#125; 分页类的重构抽取1234567891011121314151617181920212223242526272829303132333435363738//原 action 中定义的属性抽取protected PageBean pageBean = new PageBean(); public void setPage(int page) &#123; pageBean.setCurrentPage(page); &#125; public void setRows(int rows) &#123; pageBean.setPageSize(rows); &#125; DetachedCriteria detachedCriteria = null;/** * 将指定 java 对象转换为 josn，并响应到客户端 * 使用 json-lib 将 pageBean 转化为 json 对象，通过输出流返回页面 * jsonObject 用于将单一对象转换成 josn * jsonArray 用于将数组集合转换成 json * JSONObject.fromObject方法有重载方法，可以选择是否传入 jsonConfig * String json = JSONObject.fromObject(pageBean).toString(); * @param o * @param excludes */public void java2Json(Object o,String [] excludes)&#123; JsonConfig jsonConfig = new JsonConfig(); //指定不需要转为 josn 的属性 jsonConfig.setExcludes(excludes); String json = JSONObject.fromObject(o,jsonConfig).toString(); ServletActionContext.getResponse().setContentType("text/json;charset=utf-8"); try &#123; //将 json 用输出流写回页面 ServletActionContext.getResponse().getWriter().write(json); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; 分区添加功能1234//给 Region bean 添加 name get 方法。在 Region 对象转换为 json 时会增加一个 name 字段public String getName()&#123; return province + " " + city + " " + district;&#125; 模糊查询 jsp 页面 12345678&lt;td&gt;选择区域&lt;/td&gt;&lt;td&gt; &lt;input class="easyui-combobox" name="region.id" data-options="valueField:'id', textField:'name', url:'RegionAction_listajax.action', mode:'remote'" /&gt;&lt;/td&gt; 模糊查询分区 Action 12345678910111213141516171819202122/** *查询所有区域，写回 json 数据 */public String listajax()&#123; List&lt;Region&gt; list =null; if (StringUtils.isNotBlank(q)) &#123; list = regionService.findListByQ(q); &#125;else&#123; list = regionService.findAll(); &#125; this.java2Json(list,new String[]&#123;"province","city","district","postcode","shortcode","citycode","subareas"&#125;); return NONE;&#125;/** * 页面 model = 'remote' 查询条件 q */private String q;public void setQ(String q) &#123; this.q = q;&#125; 模糊查询 dao 12345public List&lt;Region&gt; findListByQ(String q) &#123; String hql = "FROM Region r WHERE r.shortcode LIKE ? OR r.citycode LIKE ? OR r.city LIKE ? OR r.province LIKE ? OR r.district LIKE ?"; List&lt;Region&gt; list = (List&lt;Region&gt;) this.getHibernateTemplate().find(hql, "%" + q + "%", "%" + q + "%", "%" + q + "%", "%" + q + "%", "%" + q + "%"); return list;&#125; 分区组合条件分页查询定义一个 json 转换方法 1234567891011121314151617//定义一个工具方法，用于将指定的表单 form 所有输入项转化为 json 数据 $.fn.serializeJson=function()&#123; var serializeObj=&#123;&#125;; var array=this.serializeArray(); $(array).each(function()&#123; if(serializeObj[this.name])&#123; if($.isArray(serializeObj[this.name]))&#123; serializeObj[this.name].push(this.value); &#125;else&#123; serializeObj[this.name]=[serializeObj[this.name],this.value]; &#125; &#125;else&#123; serializeObj[this.name]=this.value; &#125; &#125;); return serializeObj; &#125;; 方法的调用,为查询窗口的查询按钮绑定事件 123456789$("#btn").click(function()&#123; //调用工具方法，将其转换成 json 格式 var json = $("#searchForm").serializeJson(); //调用数据表格的 load 方法，重新提交一次 ajax 请求，并提交参数 $("#grid").datagrid("load",json); console.info(json); // 关闭查询窗口 $("#searchWindow").window("close");&#125;); 分区组合条件分页查询 Action 123456789101112131415161718192021222324252627282930313233343536/** * 分页列表 */ public String pageQuery()&#123; DetachedCriteria dc = pageBean.getDetachedCriteria(); String addresskey = model.getAddresskey(); if(StringUtils.isNotBlank(addresskey))&#123; // 动态添加过滤条件 dc.add(Restrictions.like("addresskey","%"+addresskey+"%")); &#125; Region region = model.getRegion(); if(region !=null)&#123; String province = region.getProvince(); String city = region.getCity(); String district = region.getDistrict(); dc.createAlias("region","r"); //根据 市、城、区 模糊查询 if(StringUtils.isNotBlank(province))&#123;// 参数一：分区对象中关联区域的属性对象名称// 参数二：任意的一个别称// dc.createAlias("region","r"); dc.add(Restrictions.like("r.province","%"+province+"%")); &#125; if(StringUtils.isNotBlank(city))&#123; dc.add(Restrictions.like("r.city","%"+city+"%")); &#125; if(StringUtils.isNotBlank(district))&#123; dc.add(Restrictions.like("r.district","%"+district+"%")); &#125; &#125; subareaService.pageQuery(pageBean); this.java2Json(pageBean,new String[]&#123;"currentPage","detachedCriteria","pageSize","decidedzone","subareas"&#125;); return NONE; &#125; dao 需要增加语句 //指定 hibernate 封装对象的方式detachedCriteria.setResultTransformer(DetachedCriteria.ROOT_ENTITY); 为了使查询两个表的结果封装到一个 Subarea 下带另一个表结构 Subarea[ {key:value}, {key:value}… [{key:value},{key:value}] ] 1234567891011121314151617181920212223242526272829 /** * 通用查询分页方法 * @param pageBean */ @Override public void pageQuery(PageBean pageBean) &#123; int currentPage = pageBean.getCurrentPage(); int pageSize = pageBean.getPageSize(); DetachedCriteria detachedCriteria = pageBean.getDetachedCriteria(); //查询 pageBean 的 total （总记录数）// 指定 hibernate 发出 sql 语句的形式，rowCount 会发出 count(*) 的 sql detachedCriteria.setProjection(Projections.rowCount()); List&lt;Long&gt; countList = (List&lt;Long&gt;) this.getHibernateTemplate().findByCriteria(detachedCriteria);// 获得 list 集合的第一个数据，因为只有一个数据所以就是 记录数 Long count = countList.get(0);// 将总条数放入 pageBean pageBean.setTotal(count.intValue()); //查询 rows（当前页需要展示的数据集合）// 将 hibernate 发出 sql 语句的形式改回来，select * from xxx 的形式 detachedCriteria.setProjection(null); //指定 hibernate 封装对象的方式 detachedCriteria.setResultTransformer(DetachedCriteria.ROOT_ENTITY); int firstResult = (currentPage-1)*pageSize; int maxResults = pageSize; List rows = this.getHibernateTemplate().findByCriteria(detachedCriteria, firstResult, maxResults); pageBean.setRows(rows); &#125; 定区添加定区添加 jsp 页面 12345678&lt;tr&gt; &lt;td&gt;选择取派员&lt;/td&gt; &lt;td&gt; &lt;input class="easyui-combobox" name="staff.id" data-options="valueField:'id', textField:'name', url:'staffAction_listajax.action'"/&gt; &lt;/td&gt;&lt;/tr&gt; action 123456789/** * 查询所有未删除的取派员，返回 json */public String listajax()&#123; List&lt;Staff&gt; list = staffService.findListNotDelete(); this.java2Json(list,new String[]&#123;"decidedzones"&#125;); return NONE;&#125; service 12345678910/** * 查询所有未删除的取派员 */@Overridepublic List&lt;Staff&gt; findListNotDelete() &#123; DetachedCriteria detachedCriteria = DetachedCriteria.forClass(Staff.class); //添加过滤条件，deltag = 0 detachedCriteria.add(Restrictions.eq("deltag","0")); return staffDao.findByCriteria(detachedCriteria);&#125; dao 1234@Overridepublic List&lt;T&gt; findByCriteria(DetachedCriteria detachedCriteria) &#123; return (List&lt;T&gt;) this.getHibernateTemplate().findByCriteria(detachedCriteria);&#125; 定区添加功能 如果提交有多个 id （输入框定区 id 与 field 分区 id），则将 data-options=”field:’id’” 改为 data-options=”field:’subareaid’”; 这样提交的分区 id 就为 subareaid 了，但是会因为后台数据转 json 没有该字段导致结果 json 中没有该数据，需要手动添加 bean 中获得该字段的方法 123public String getSubareaid()&#123; return id;&#125; 这样 json 转换过程中就能加入该字段 action 1234567891011121314151617181920212223/** * 定区管理 */@Controller@Scope("prototype")public class DecidedzoneAction extends BaseAction&lt;Decidedzone&gt;&#123; //属性驱动，接受多个分区 id private String[] subareaid; public void setSubareaid(String[] subareaid) &#123; this.subareaid = subareaid; &#125; @Autowired private IDecidedzoneService decidedzoneService; /** * 添加定区 */ public String add()&#123; decidedzoneService.add(model,subareaid); return LIST; &#125;&#125; service 123456789101112131415161718192021@Service@Transactionalpublic class DecidedzoneServiceImpl implements IDecidedzoneService &#123; @Autowired private IDecidedzoneDao decidedzoneDao; @Autowired private ISubareaDao subareaDao; @Override public void add(Decidedzone model, String[] subareaid) &#123;// 添加定区 decidedzoneDao.save(model);// 同时关联分区 for(String id:subareaid)&#123; //hbm.xml 一的一方 decidedzone 放弃了维护，需要多的一方 subarea 来维护 Subarea subarea = subareaDao.findById(id);// model.getSubareas().add(subarea);//定区关联分区，但是一的一方放弃了维护，所以不合适 subarea.setDecidedzone(model);//分区关联定区，维护外键 &#125; &#125;&#125; 定区分页查询 123456789101112/** * 分页查询 */ public String pageQuery()&#123; decidedzoneService.pageQuery(pageBean); //设置 立即加载关联的 一的一方的 staff(在 decidedzone.hbm.xml 的 staff many-to-one 中选择 lazy="false") //并且反过来关闭 加载的 staff 中的 decidedzones this.java2Json(pageBean,new String[]&#123;"currentPage","detachedCriteria","pageSize","subareas","decidedzones"&#125;);// this.java2Json(pageBean,new String[]&#123;"currentPage","detachedCriteria","pageSize","subareas"&#125;); return NONE; &#125; 分页查询死循环问题页面不需要展示关联对象时： 将关联对象属性排除 页面需要展示关联对象时： 将关联对象改为立即加载，并且将关联对象中的属性排除 WebService 使用WebService 是两个系统之间的 远程调用技术，可以实现跨语言调用，因为调用的是 http 协议，传输数据格式为 xml，使用 post 方式接受用户请求 SOAP （Simple Object Access Protocol）简单对象访问协议 SOAP = 在 HTTP 基础上 加上 XML 数据 组成 \&lt;Encolope> - 必须以 XML 根元素出现 \&lt;Body> 必须在 body 部分包含必要执行的服务器方法，和发送到服务器的数据 WSDL （WebService Description Language）Web 服务描述语言 用于描述当前服务的一些信息（服务名称、服务的发布地址、服务提供的方法、方法的参数类型、方法的返回类型等） 基于 WebService 创建的服务 创建一个 Java 项目 创建一个类，加入 WebService 注解 提供一个方法 在 main 函数中调用 jdk 提供的发布服务方法 访问服务的 wdsl 文档，（服务的发布地址+wdsl） wsimport 是 jdk 自带的根据 wsdl 文档生成客户端调用代码的工具，无论什么语言的服务器端的 WebService 都会在客户端生成 java 代码 使用 wsimport 命令解析 wsdl 文件生成本地代码：wsimport -s . http://192.168.0.100/one?wsdl -s 后有个 . 用于指定源码生成目录，. 指代当前目录 使用 -s 会在目录下生成两份代码，一份 class 一份 java，class 打包后可用，java 可以拷贝到自己的项目运行 通过本地代码创建一个代理对象 通过代理对象实现远程调用 web 项目环境配置 第一步：创建动态web项目 第二步：导入CXF相关jar包 第三步：配置web.xml 12345678910111213141516171819202122232425262728293031&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd" version="3.1"&gt; &lt;!--配置让其寻找 cxf.xml--&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:cxf.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;!--项目启动时发布服务,默认找 web-inf /applicationcontext.xml--&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!--配置 CXF 框架提供的 Servlet--&gt; &lt;servlet&gt; &lt;servlet-name&gt;cxf&lt;/servlet-name&gt; &lt;servlet-class&gt;org.apache.cxf.transport.servlet.CXFServlet&lt;/servlet-class&gt; &lt;!--通过初始化参数指定CXF框架的配置文件路径,已经在监听器中配置，项目启动时加载--&gt; &lt;!--&lt;init-param&gt;--&gt; &lt;!--&lt;param-name&gt;config-location&lt;/param-name&gt;--&gt; &lt;!--&lt;param-value&gt;classpath:cxf.xml&lt;/param-value&gt;--&gt; &lt;!--&lt;/init-param&gt;--&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;cxf&lt;/servlet-name&gt; &lt;url-pattern&gt;/service/*&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 第四步：在类路径下（src 同路径）提供cxf.xml，并设置为 root Source 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:jaxws="http://cxf.apache.org/jaxws" xmlns:soap="http://cxf.apache.org/bindings/soap" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://cxf.apache.org/bindings/soap http://cxf.apache.org/schemas/configuration/soap.xsd http://cxf.apache.org/jaxws http://cxf.apache.org/schemas/jaxws.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd"&gt; &lt;!-- 引入CXF Bean定义如下,早期的版本中使用 --&gt; &lt;import resource="classpath:META-INF/cxf/cxf.xml" /&gt; &lt;import resource="classpath:META-INF/cxf/cxf-extension-soap.xml" /&gt; &lt;import resource="classpath:META-INF/cxf/cxf-servlet.xml" /&gt; &lt;!--配置数据源--&gt; &lt;bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource"&gt; &lt;property name="driverClassName" value="com.mysql.jdbc.Driver"/&gt; &lt;property name="url" value="jdbc:mysql///crm_heima32"/&gt; &lt;property name="username" value="root"/&gt; &lt;property name="password" value="root"/&gt; &lt;/bean&gt; &lt;!--配置事务管理器--&gt; &lt;bean name="txManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource"/&gt; &lt;/bean&gt; &lt;!--支持事务注解--&gt; &lt;tx:annotation-driven transaction-manager="txManager"/&gt; &lt;!--注入模板--&gt; &lt;bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate"&gt; &lt;property name="dataSource" ref="dataSource"/&gt; &lt;/bean&gt; &lt;bean id="customerService" class="com.itheima.crm.service.impl.CustomerServiceImpl"&gt; &lt;property name="jdbcTemplate" ref="jdbcTemplate"/&gt; &lt;/bean&gt; &lt;!--注册服务--&gt; &lt;jaxws:server id="myService" address="/customer"&gt; &lt;jaxws:serviceBean&gt; &lt;ref bean="customerService"/&gt; &lt;/jaxws:serviceBean&gt; &lt;/jaxws:server&gt;&lt;/beans&gt; 第五步：针对t_customer表创建一个Customer客户实体类 第六步：开发一个接口和实现类 1234567891011121314151617181920212223242526272829303132333435363738package com.itheima.crm.service.impl;import com.itheima.crm.domain.Customer;import com.itheima.crm.service.ICustomerService;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.jdbc.core.RowMapper;import org.springframework.transaction.annotation.Transactional;import java.sql.ResultSet;import java.sql.SQLException;import java.util.List;@Transactionalpublic class CustomerServiceImpl implements ICustomerService &#123; private JdbcTemplate jdbcTemplate; public void setJdbcTemplate(JdbcTemplate jdbcTemplate) &#123; this.jdbcTemplate = jdbcTemplate; &#125; @Override public List&lt;Customer&gt; findAll() &#123; String sql = "select * from t_customer"; List&lt;Customer&gt; list = jdbcTemplate.query(sql, new RowMapper&lt;Customer&gt;() &#123; @Override public Customer mapRow(ResultSet resultSet, int i) throws SQLException &#123; int id = resultSet.getInt("id");//根据字段名从结果集获取对应的值 String name = resultSet.getString("name"); String station = resultSet.getString("station"); String telphone = resultSet.getString("telphone"); String address = resultSet.getString("address"); String decidedzone_id = resultSet.getString("decidedzone_id"); return new Customer(id, name, station, telphone, address, decidedzone_id); &#125; &#125;); return list; &#125;&#125; 第七步：配置cxf.xml，见第四步 解析 wdsl 文件，生成客户端本地代码：（带 s 是有 java 跟 class 类，不带 s 的只有 class 类） wsimport -s . http://192.168.171.1:8080/service/customer?wsdl 访问地址 http://192.168.171.1:8080/(url-pattern 中配置的路径名） 1234&lt;servlet-mapping&gt; &lt;servlet-name&gt;cxf&lt;/servlet-name&gt; &lt;url-pattern&gt;/service/*&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; Q&amp;AQ:idea 的 maven 项目部署后，无法显示 css 等样式谷歌浏览器报错：easyui.css:1 Failed to load resource: the server responded with a status of 404 (Not Found） 提示各种 css 未找到 A:idea 应该会默认忽视 jsp 页面的 el 表达式，所以以下这种 绝对路径方式会失效 1&lt;link rel="stylesheet" type="text/css" href="$&#123;pageContext.request.contextPath&#125;/js/easyui/themes/default/easyui.css"&gt; 需要在 1&lt;%@ page contentType="text/html;charset=UTF-8" language="java" isELIgnored="false" %&gt; 添加最后的 isELIgnored=”false” ，来使得不忽视 el 表达式 Q:点击 ztree callback 中的 onClick 方法无反应A:callback 应该是跟 date 同级的属性，如果将其放在 date 属性中则无效 Q:idea 多模块 maven 项目给模块添加 hibernate 时出现报错 Module must not contain source root. The root already belongs to module idea 多模块项目报错 A:在 project Structure 中选择 module - Sources 选择父模块，将右侧的红色 content root 路径删除（一般是父模块拥有了 src、resources 等路径） Q: hibernate 错误，网页报错 500HTTP Status 500 - User is not mapped [FROM User u WHERE u.username=? AND u.password=?]; nested exception is org.hibernate.hql.internal.ast.QuerySyntaxException: User is not mapped [FROM User u WHERE u.username=? AND u.password=?] nested exception is org.hibernate.hql.internal.ast.QuerySyntaxException: User is not mapped A:配置 application.xml 中 hibernate 的映射文件注入错误 将如下配置的 / 写成了 . （com.itheima.bos.domain.*.xml） 12345&lt;property name="mappingLocations"&gt; &lt;list&gt; &lt;value&gt;classpath:com/itheima/bos/domain/*.xml&lt;/value&gt; &lt;/list&gt;&lt;/property&gt; ssh 整合报错 Q:hibernate 报错 Exception sending context initialized event to listener instance of class org.springframework.web.context.ContextLoaderListenerorg.springframework.beans.factory.BeanCreationException: Error creating bean with name ‘sessionFactory’ defined in class path resource [applicationContext.xml]: Invocation of init method failed; nested exception is org.hibernate.HibernateException: Errors in named queries: user.editPassword A: hbm.xml 中的 query 语句错误，语句最后加了一个 ； 123&lt;query name="user.editPassword"&gt; UPDATE User SET password = ? WHERE id = ?&lt;/query&gt; Q:sturts2 model 提交乱码问题A:form 表单的 method 没有写 post 方法，导致 get 提交了 Q: 500 错误HTTP Status 500 - not-null property references a null or transient value : com.itheima.bos.domain.Staff.haspda; nested exception is org.hibernate.PropertyValueException: not-null property references a null or transient value : com.itheima.bos.domain.Staff.haspda A: hibernate 映射文件中（hbm.xml）的字段属性生成时为 not null=“true”，将其改为 false Q:java.lang.NoSuchMethodExceptionjava.lang.NoSuchMethodException: com.itheima.bos.web.action.StaffAction.deleteBatch() A: 修改了 hbm.xml 文件，没有重启，修改 xml 后无法热部署，而且修改了 hbm.xml 中的 hql 语句错误 Q:hibernate 报错严重: Exception sending context initialized event to listener instance of class org.springframework.web.context.ContextLoaderListenerorg.springframework.beans.factory.BeanCreationException: Error creating bean with name ‘sessionFactory’ defined in class path resource [applicationContext.xml]: Invocation of init method failed; nested exception is org.hibernate.HibernateException: Errors in named queries: staff.deleteCaused by: org.hibernate.HibernateException: Errors in named queries: staff.delete at org.hibernate.internal.SessionFactoryImpl.(SessionFactoryImpl.java:493) at org.hibernate.boot.internal.SessionFactoryBuilderImpl.build(SessionFactoryBuilderImpl.java:444) at org.hibernate.cfg.Configuration.buildSessionFactory(Configuration.java:708) at org.hibernate.cfg.Configuration.buildSessionFactory(Configuration.java:724) at org.springframework.orm.hibernate5.LocalSessionFactoryBean.buildSessionFactory(LocalSessionFactoryBean.java:416) at org.springframework.orm.hibernate5.LocalSessionFactoryBean.afterPropertiesSet(LocalSessionFactoryBean.java:401) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeInitMethods(AbstractAutowireCapableBeanFactory.java:1637) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1574) … 22 more A:HQL 语句 “1” 用了双引号会报错，改为单引号 ‘1’ 123&lt;query name=&quot;staff.delete&quot;&gt; UPDATE Staff SET deltag=&quot;1&quot; WHERE id=?&lt;/query&gt; Q:前台传递了参数但是无法修改数据库A:struts2 属性驱动没有加 get ，set 方法，导致取到 id 为空 Q:InstantiationException 无法实例化 beanjava.lang.InstantiationException: com.itheima.bos.domain.Region at java.lang.Class.newInstance(Class.java:427) at com.itheima.bos.web.action.base.BaseAction.(BaseAction.java:32) at com.itheima.bos.web.action.RegionAction.(RegionAction.java:23) at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method) ​ at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)​ at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)​ at java.lang.reflect.Constructor.newInstance(Constructor.java:423)​ at org.springframework.beans.BeanUtils.instantiateClass(BeanUtils.java:147) A:无法实例化 InstantiationException 错误，用反射类实例化某个对象时，如果内部只有有参构造函数那么会无法实例化（没有有参构造函数时会有默认隐藏的无参构造方法），那么只要手动添加一个无参构造方法就行了 关于InstantiationException错误的原因 Q: 从 excel 表保存取派员数组方法执行，没有报错，但是也没有写进数据库堆栈跟踪 发现如下问题： InvocationTargetException InvocationTargetException是因为反射调用的方法和构造器中出现的异常导致， 继续跟踪发现： turn off your session into flushMode.commit auto or remove ‘readOnly’ marker for transcation defintion 发现应该是事务提交设置了 readOnly 或者 自动提交，于是查看自己的 serviceImpl 发现注释上只写了 @Service 没有 @Transcational，忘记写事务注释了… 因为是 List\&lt;Region> 多个 Region 的保存操作，需要添加事务。 Q: sturts2 服务端 action 返回 NONE，页面为空白无法显示 json 回显数据A: 页面响应 HTTP Status 404 - result ‘null’ not found The requested resource is not available. 堆栈跟踪发现 return NONE 抛出 IOException， 但是另一个相同的 action return NONE 确可以正确返回 json 数组。 因为在 struts.xml 中配置了 \&lt;result name=”none”/> 导致拦截器拦截，然后重定向到一个不存在的页面，导致异常。 return NONE 代表 Action 正确执行，但并不返回任何视图。然后 struts.xml 的 result 的默认配置是 dispatcher，调用 RequestDispatcher，转发页面 result 的 name 和 type 属性 Q: json 转换错误（对象互相引用错误）DEBUG DefaultDispatcherErrorHandler:84 - Exception occurred during processing request: There is a cycle in the hierarchy!net.sf.json.JSONException: There is a cycle in the hierarchy! at net.sf.json.util.CycleDetectionStrategy$StrictCycleDetectionStrategy.handleRepeatedReferenceAsObject(CycleDetectionStrategy.java:97) A: 一个对象 A 中引用了另一个的集合对象 B，B 中又含有对 A 的引用 1this.java2Json(pageBean,new String[]&#123;"currentPage","detachedCriteria","pageSize"&#125;); json 转换时忽略其循环引用的字段 如果循环嵌套的字段是需要在需要展示的字段，那么就需要将该对象的 hbm.xml 中的展示字段属性,懒加载关闭 lazy = ‘false’ Q：java.lang.Integer cannot be cast to java.lang.StringA: Restrictions.eq(“xxx”,0); 查询语句出错，0 应该改为 “0” 字符串]]></content>
      <tags>
        <tag>java</tag>
        <tag>web</tag>
        <tag>ssh</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ssh_crm]]></title>
    <url>%2F2019%2F01%2F30%2Fssh-crm%2F</url>
    <content type="text"><![CDATA[使用 SSH 搭建 crm 项目数据库内部数据库内部分为库和服务两部分，库负责存储硬盘上的文件（表的存储方式），服务用来操作库。 JDBC （客户端）连接数据库就是连接服务部分，客户端用 sql 语句告诉服务该做什么，服务负责在库中读写数据（用 Input/OutPut）。服务从库中获得数据，将其转换成结果集（ResultSet）返回给客户端。 计算总页数： 临界值法： totalPage（总页数） totalCount（总条数） pageSize（每页显示条数） totalPage = （totalCount）+（pageSize-1））/pageSize 123&lt;%--隐藏域用来获得表单中 currentPage 的值，传入服务器--%&gt;&lt;input type="hidden" name="currentPage" id="currentPageInput" value="&lt;s:property value="#pageBean.currentPage"/&gt;"/&gt;&lt;input type="hidden" name="pageSize" id="pageSizeInput" value="&lt;s:property value="#pageBean.pageSize"/&gt;"/&gt; 123&lt;bean name="userAction" class="cn.itcast.web.action.UserAction" scope="prototype"&gt; &lt;property name="userService" ref="userService"/&gt;&lt;/bean&gt; 注入 property 的 name 值，是由 userAction 类中的 UserService 的 set 方法为准的（虽然 UserService 对象的名字一般与 set 方法一致，若出现不一致则按 set 方法命名 name 属性） 12345&lt;id name="dict_id" &gt; &lt;!-- generator:主键生成策略(用 varchar 作为主键生成策略的7种里只有2种：uuid 与 assigned--手动指定) 企业中数据字典表的维护，直接修改表维护，一般不会根据项去修改表，所以此时主键生成策略是用不到的--&gt; &lt;generator class="native"&gt;&lt;/generator&gt;&lt;/id&gt; struts2 文件上传前台： &lt;%–文件上传要求：表单 Post 提交，提交类型 enctype=”multipart/form-data” 文件需要 input type=”file”–%&gt; 后台： 1234567891011121314private File photo;//上传的文件自动上传,需要在后台提供一个与前台 input 的 type=file name 相同的属性//文件名,在提交键名后加后缀FileName，文件名会自动封装private String photoFileName;//文件 MIME 类型（text/html）（image/png）private String photoContentType;public String add() throws Exception &#123; //文件上传 photo.renameTo(new File("D:/upload/aa.jpg")); System.out.println(photoFileName); System.out.println(photoContentType); return "toList"; &#125; struts2 文件上传原理： 拦截器 FileUploadInterceptor 中判断是否多段请求，是就处理，提取 photo，photoFileName，photoContentType 的信息，封装到对应 Map 的键值对中，然后放行。参数的赋值交给后续拦截器 param 拦截器。 添加联系人列表点击按钮打开新窗口 1window.open('','','width=200,height=100') 第一个参数 url ，选填，打开新窗口路径 第二个参数 name ，选填，打开的新窗口名称 URL=&#39;${pageContext.request.contextPath}/CustomerAction_list?select=ture&#39; 在按钮提交中添加一个参数，让其在提交到 jsp 页面后可以判断是否显示 选择按钮（context 部分有一个 parameters 键值对，存放有提交的所有参数的 map，key:parameters,value:{select={Ljava.lang.String;@3926ec}}） 让翻页跟查询后都保留选择按钮，需要在进行这些操作时保留参数值，使用隐藏域将参数保留下来 1&lt;input type="hidden" name="select" value="&lt;s:property value="#parameter.select"/&gt;"/&gt; 点击 add.jsp 中选择客户按钮弹出的 list.jsp 中选择按钮将选择的 Customer 对象添加到 add.jsp 的 所属客户栏 123456&lt;%--id 用于后台查询 联系人 getById(),用 name 属性值自动传递参数到后台（struts2）。但是不需要让用户看到，设置隐藏域。id 便于前台获得 input，在打开选择窗口点击选择按钮后，获得客户选择的客户 id，赋值给 input 的 id--%&gt;&lt;input type="hidden" id="cust_id" name="cust_id" style="WIDTH: 180px"/&gt; &lt;%--客户名称不传递到后台，只用于前台显示名称,不用设置 name 属性。 id 便于前台获得 input，在打开选择窗口点击选择按钮后，获得客户选择的客户 name，赋值给 input 的 name--%&gt;&lt;input type="text" id="cust_name" style="WIDTH: 180px"/&gt; window.opener 用于获得打开该窗口的 父类的 window 对象，例如 A 窗口中点击 button 打开了 B 窗口，那么 B 窗口调用 window.opener 即可获得 A 窗口的 window 对象。用来对 A 窗口的各种 input 等 value 值进行赋值或其他操作。 1234567891011function selectCustomer(cust_id,cust_name) &#123; //获得添加页面 window 对象 var win = window.opener; //获得添加页面的 doucument 对象 var doc = win.document; //获得隐藏域和文本框 doc.getElementById("cust_id").value=cust_id; doc.getElementById("cust_name").value=cust_name; window.close(); &#125; 让不同方法的异常跳转到不同的错误页面 使用自定义异常，继承 RunTimeException，在 struts.xml 中配置各种自定义异常（需要定义异常类过多，较繁琐） 使用 try catch 包裹可能抛出异常代码，进行异常的收集与页面重定向到错误页面 service 的实现类中，对查询返回了 Customer 对象的用户名进行异常处理 1234//如果返回了对象抛出异常if(existU!=null)&#123; throw new RuntimeException("该用户名已存在");&#125; Action 中进行try catch 123456789try &#123; userService.saveUser(user); &#125; catch (Exception e) &#123; e.printStackTrace();// 将错误信息放到 request 域，传递给错误页面 ActionContext.getContext().put("error",e.getMessage());// 返回到注册页面 return "register"; &#125; struts.xml 的 Action 中 result 配置 1&lt;result name="error" &gt;/login.jsp&lt;/result&gt; jsp 页面进行异常信息的输出 1&lt;TD style="HEIGHT: 18px" colspan="2" &gt;&lt;font color="red" &gt;&lt;s:property value="#error" /&gt; &lt;/font&gt;&lt;/TD&gt; 添加登录拦截器123456789101112131415161718192021222324252627package cn.itcast.web.interceptor;import cn.itcast.domain.User;import com.opensymphony.xwork2.ActionContext;import com.opensymphony.xwork2.ActionInvocation;import com.opensymphony.xwork2.interceptor.MethodFilterInterceptor;import java.util.Map;public class PrivilegeInterceptor extends MethodFilterInterceptor&#123; @Override //不校验登录注册方法 protected String doIntercept(ActionInvocation actionInvocation) throws Exception &#123;// 获得 session Map&lt;String, Object&gt; session = ActionContext.getContext().getSession();// 获得登录标示 User user = (User) session.get("user");// 判断标记是否存在，存在就放行，不存在就重定向到登录页面 if(user!=null)&#123; //放行 return actionInvocation.invoke(); &#125;else&#123; return "toLogin"; &#125; &#125;&#125; 1234&lt;!--如果没有登录则跳转到登录页面，因为在 CustomerAction 与 LinkManAction 中都要使用，所以配置全局 result--&gt;&lt;global-results&gt; &lt;result name="toLogin" &gt;/login.jsp&lt;/result&gt;&lt;/global-results&gt; 回显就是将本身 input 的 name 属性值赋给 value 隐藏域 id 回显 1&lt;input type="hidden" id="cust_id" name="customer.cust_id" style="WIDTH: 180px" value="&lt;s:property value="#linkMan.customer.cust_id"/&gt;"/&gt; 客户名称回显： 1&lt;input type="text" id="cust_name" style="WIDTH: 180px" value="&lt;s:property value="#linkMan.customer.cust_name"/&gt;"/&gt; 性别回显判断（判断性别的值 1 与 2 要加引号）： 1&lt;input type="radio" value="1" name="lkm_gender" &lt;s:property value="#linkMan.lkm_gender=='1'?'checked':''"/&gt;&gt;男 原生 sql 查询123456789101112131415161718@Override @SuppressWarnings("all") public List&lt;Object[]&gt; getIndustryCount() &#123;// 原生 sql 查询 List&lt;Object[]&gt; list = getHibernateTemplate().execute(new HibernateCallback&lt;List&gt;() &#123; String sql=" select dict_item_name,count(*) total " + " from cst_customer c,base_dict bd where " + " c.cust_industry=bd.dict_id " + " group by " + " c.cust_industry "; @Override public List doInHibernate(Session session) throws HibernateException &#123; SQLQuery query = session.createSQLQuery(sql); return query.list(); &#125; &#125;); return list; &#125; Spring 注解spring 配置文件 application.xml 配置 12345678910111213141516171819202122232425262728293031323334353637 &lt;!--读取配置文件--&gt; &lt;context:property-placeholder location="classpath:db.properties"/&gt; &lt;!--将 dataSource 放入 spring 容器--&gt; &lt;bean name="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;property name="jdbcUrl" value="$&#123;jdbc.jdbcUrl&#125;"/&gt; &lt;property name="driverClass" value="$&#123;jdbc.driverClass&#125;"/&gt; &lt;property name="user" value="$&#123;jdbc.user&#125;"/&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"/&gt; &lt;/bean&gt; &lt;!--核心事务管理器--&gt; &lt;bean name="transactionManager" class="org.springframework.orm.hibernate5.HibernateTransactionManager"&gt; &lt;property name="sessionFactory" ref="sessionFactory"/&gt; &lt;/bean&gt; &lt;!--开启组件扫描类中的注解 component-组件，scan-扫描 --&gt; &lt;context:component-scan base-package="cn.itcast"&gt;&lt;/context:component-scan&gt; &lt;!--开启注解事务--&gt; &lt;tx:annotation-driven transaction-manager="transactionManager"/&gt; &lt;bean name="sessionFactory" class="org.springframework.orm.hibernate5.LocalSessionFactoryBean"&gt; &lt;!--将连接池注入到 sessionFactory,hibernate 会通过连接池获得连接--&gt; &lt;property name="dataSource" ref="dataSource"/&gt; &lt;!--加载配置方案2：在 spring 配置中放置 hibernate 配置信息--&gt; &lt;!--配置 hibernate 基本信息--&gt; &lt;property name="hibernateProperties"&gt; &lt;props&gt; &lt;prop key="hibernate.dialect"&gt;org.hibernate.dialect.MySQLDialect&lt;/prop&gt; &lt;!--可选配置--&gt; &lt;prop key="hibernate.show_sql"&gt;true&lt;/prop&gt; &lt;prop key="hibernate.format_sql"&gt;true&lt;/prop&gt; &lt;prop key="hibernate.hbm2ddl.auto"&gt;update&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;!--引入元数据--&gt; &lt;property name="mappingDirectoryLocations" value="classpath:cn/itcast/domain"/&gt; &lt;/bean&gt;&lt;/beans&gt; dao 注入，需要在每个 dao 的实现类中，用 @Repository(“baseDao”) 将该 dao 托管到 spring。用 @Resource(name=”sessionFactory”) ，在一个 set 上用 父类的 setSessionFactory 将 sessionFactory 注入到每个 dao 实现类中，以便能使用 getHibernateTemplate() 提供的方法完成基本的增删改查功能。 12345678@Repository("baseDao")public class BaseDaoImpl&lt;T&gt; extends HibernateDaoSupport implements BaseDao&lt;T&gt; &#123; private Class clazz;//用于接受运行期泛型类型// 注入 sessionFactory @Resource(name="sessionFactory") public void setSF(SessionFactory sf)&#123; super.setSessionFactory(sf); &#125; service 注入 在每个 service 实现类上注释 @Service ，将该 Service 交给 spring 管理。@Transactional 用来开启事务，具体方式与 xml 配置一样。@Resource(name=”baseDictDao”) 用来在 调用的 dao 定义上注释，来表示从 spring 获得被托管的 dao（spring 帮助创建该 dao 的实例对象） 12345@Service("baseDictService")@Transactional(isolation= Isolation.REPEATABLE_READ,propagation = Propagation.REQUIRED,readOnly = false)public class BaseDictServiceImpl implements BaseDictService &#123; @Resource(name="baseDictDao") private BaseDictDao baseDictDao; action 注入 在每个 action 上注释 @Controller(“baseDictAction”)，将该 action 交给 spring 管理，@Scope(“prototype”) 表示多例方法，struts 必须是多例创建才行，因为每个 访问都要创建一个 ActionContext，不是多例会出现问题。 用 @Resource(name=”baseDictService”)，表示从 spring 获得托管在 spring 上的 Service ，让其帮助创建对应的 Service 对象。 1234567@Controller("baseDictAction")@Scope("prototype")public class BaseDictAction extends ActionSupport &#123; private String dict_type_code; @Resource(name="baseDictService") private BaseDictService baseDictService; Q&amp;AA: HTML 为红色报错：Element HTML must be declareddtd是定义html标记的规则的，不兼容这一个dtd 123&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;!--&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3c.org/TR/1999/REC-html401-19991224/loose.dtd"&gt;--&gt;&lt;HTML xmlns="http://www.w3.org/1999/xhtml"&gt; 将第一个 DOCTYPE 注释掉，或换成第二个 A: applicationContext.xml 配置错误，12345678910&lt;filter&gt; &lt;!--在视图 jsp 中 session 还是打开的--&gt; &lt;filter-name&gt;openSessionInView&lt;/filter-name&gt; &lt;!--OpenSessionInViewFilter 下红色波浪线--&gt; &lt;filter-class&gt;org.springframework.orm.hibernate5.support.OpenSessionInViewFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;openSessionInView&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; Error:(24, 23) ‘org.springframework.orm.hibernate5.support.OpenSessionInViewFilter’ is not assignable to ‘javax.servlet.Filter’ 12345678910&lt;!--struts2 核心过滤器--&gt;&lt;filter&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;!--StrutsPrepareAndExecuteFilter 下红色波浪线--&gt; &lt;filter-class&gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; Error:(34, 23) ‘org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter’ is not assignable to ‘javax.servlet.Filter’ A: 没有导入 servlet 包，在 module 中选中项目点击右侧绿色 + 号， libraries 选择 tomcat 的 lib 添加即可。 如果 OpenSessionInViewFilter、StrutsPrepareAndExecuteFilter 等类的文字是红色，则需要导入 lib 目录下 jar 包 Q: 从 svn 下载的项目导入路径全为红色，但运行没问题xml &lt;context:property-placeholder location=&quot;classpath:db.properties&quot;/&gt; &lt;hibernate-mapping package=&quot;cn.itcast.domain&quot; &gt; 等配置路径都为红色。 A: 在 module 将当前项目 src 目录标记为 Sources 即可解决问题，亦或是多模块项目则将该模块添加到 project 中，在 module 中导入下载 模块的的 iml 文件 多模块错误 Q: jsp action 页面报错 Module “” must not contain source root . The root already belongs to module “*”.多模块错误 A:A: 在 module 将当前项目 src 目录标记为 Sources 即可解决问题，亦或是多模块项目则将该模块添加到 project 中，在 module 中导入下载 模块的的 iml 文件 Q:No result defined for action cn.itcast.web.action.CustomerAction and result errorHibernate: select count(*) as y0_ from cst_customer this_ A: 12//计算总页数(加上临界值)this.totalPage = (this.totalCount + pageSize - 1) / this.pageSize; 此处的 pageSize 没有加 this 导致 pageBean 构造函数错误 Q:404 error No result defined for action cn.itcast.web.action.CustomerAction and result error A: action 中配置的 result 应与 action 中 返回的值一致 return “edit” 123&lt;action name="CustomerAction_*" class="customerAction" method="&#123;1&#125;" &gt; &lt;result name="edit" &gt;/jsp/customer/add.jsp&lt;/result&gt;&lt;/action&gt; Q：数据字典下拉列表(整个列表)不显示，1234loadSelect("009","source","cust_source.dict_id" &lt;s:if test="#customer.cust_source!=null"&gt;, &lt;s:property value='#customer.cust_source.dict_id'/&gt; &lt;/s:if&gt;); A:在 \&lt;s:if> 前多加了一个 , Q：数据字典下拉列表没有回显A：录入时 typeCode 与 调用 loadSelect 函数时查询所得 customer 传入的 typeCode 不一致，重新录入正确的 Customer 对象 1234567891011121314151617181920212223242526function loadSelect(typeCode,positionId,selectName,selectedId)&#123; //创建 select 对象，指定其 name 属性 var $select = $("&lt;select name="+selectName+"&gt;&lt;/select&gt;"); //提示选项，请选择 $select.append($("&lt;option value=''&gt;---请选择---&lt;/option&gt;")); //使用 jquery 的 ajax 访问后台 action $.get("$&#123;pageContext.request.contextPath&#125;/BaseDictAction", &#123; dict_type_code:typeCode &#125;, //返回 json 数组对象，对其遍历。遍历中创建的 option 对象，判断是否回显，添加到 select 中 function(data)&#123; // alert(data); $.each( data, function(i, json)&#123; var $option = $("&lt;option value='"+json['dict_id']+"'&gt;"+json['dict_item_name']+"&lt;/option&gt;"); if(json['dict_id']==selectedId)&#123; // 判断是否要回显 $option.attr("selected","selected"); &#125; $select.append($option); // alert(json["dict_item_name"] ); &#125;); &#125;, type="json" ); //将组装好的 select 放到页面指定位置 $("#"+positionId).append($select);&#125; Q:No result defined for action cn.itcast.web.action.LinkManAction and result errorA: 打断点发现 1pageBean pb = lms.getPageBean(dc,currentPage,pageSize); 中的 lms 值为 cust_name like %…% 的查询语句,应该是之前的修改没有生效,重启 intellj idea 即可解决 为什么会发生 error result 这种错误:在 sturts.xml 中配置了如下出现异常就跳转错误页面的设置 1234&lt;!--开启运行时异常--&gt;&lt;global-exception-mappings&gt; &lt;exception-mapping exception="java.lang.RuntimeException" result="error"&gt;&lt;/exception-mapping&gt;&lt;/global-exception-mappings&gt; 可以在 LinkManAction 下配置如下 result 在跳转页面 list.jsp 中添加 \&lt;s:debug>\&lt;s:debug> 1&lt;result name=&quot;error&quot; &gt;/jsp/linkman/list.jsp&lt;/result&gt; Q:进行双条件框条件查询无结果A: 后台采用 id 查询,前台用选择框进行客户名称的选择,并自动填入 名称 与 id，如果进行手动输入名称，该页面会无法获得 customer.cust_id ，从而后台无法查询到该条件的对应结果。 123if((linkMan.getCustomer()!=null))&#123; dc.add(Restrictions.eq("customer.cust_id",linkMan.getCustomer().getCust_id()));&#125; 1234567891011function selectCustomer(cust_id,cust_name) &#123; //获得添加页面 window 对象 var win = window.opener; //获得添加页面的 doucument 对象 var doc = win.document; //获得隐藏域和文本框 doc.getElementById("cust_id").value=cust_id; doc.getElementById("cust_name").value=cust_name; window.close(); &#125; Q: 拦截器登录页面跳转异常No result defined for action cn.itcast.web.action.LinkManAction and result toLogin A:修改 ctruts.xml 的 Action result 为全局 result 1234&lt;!--如果没有登录则跳转到登录页面，因为在 CustomerAction 与 LinkManAction 中都要使用，所以配置全局 result--&gt;&lt;global-results&gt; &lt;result name="toLogin" &gt;/login.jsp&lt;/result&gt;&lt;/global-results&gt; Q：500 异常 400 异常500问题： ​ Unable to instantiate Action, saleVisitAction, defined for ‘SaleVisitAction_add’ in namespace ‘/‘saleVisitAction ​ description The server encountered an unexpected condition that prevented it from fulfilling the request. A: spring 配置文件 application.xml 中的 action name 与 struts2 配置文件 struts 中的 action class 不一致 400问题： ​ No result defined for action cn.itcast.web.action.SaleVisitAction and result error A: struts 配置文件中 ，result 的 name 应该与 action 中 return 的值相同，表示返回的是什么页面 1&lt;result name="toList" type="redirectAction"&gt; debug 显示 ActionMapping{name=’SaleVisitAction_add’, namespace=’/‘, method=’null’, extension=’null’, params=null, result=null} Q:hibernate 错误提示Unable to evaluate the expression Method threw ‘org.hibernate.LazyInitializationException’ exception. A: 多表的关系问题，经查询应该跟级联操作有关，删除数据库相关数据表，让其自动重新创建。 [http-nio-8080-exec-4] ERROR org.hibernate.internal.SessionImpl - HHH000346: Error during managed flush [object references an unsaved transient instance - save the transient instance before flushing: cn.itcast.domain.Customer] A：级联操作问题： 在页面上写了子表ID的隐藏表单域，传到后面的时候value=”” ,不是value=null，所以执行的时候hibernate判断为更新，所以报错了 用来回显 visit_id 的 input 隐藏域，如果使用了 hibernate 的 saveOrUpdate 方法，则会自动根据 visit_id 是否为null 判断是添加还是升级操作，但是后台根据此隐藏域获得无 visit_id 时，是空字符串 “”，根据 hibernate 判断依旧为升级操作，所以会出现异常。 1&lt;input type="hidden" name="visit_id" value="&lt;s:property value="#saleVisit.visit_id" /&gt;" /&gt; 参考：https://blog.csdn.net/ailaojie/article/details/82689536]]></content>
      <categories>
        <category>SSH</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>SSH</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ssh]]></title>
    <url>%2F2019%2F01%2F15%2Fssh%2F</url>
    <content type="text"><![CDATA[hibernateidea 下 hibernate 的创建 idea 创建 bean.hbm.xml 与 hibernate.cfg.xml 在配置 javaBean.hbm.xml 时，column 如果不配，自动根据属性名 name 填写，如果表的 列名 与 代码的属性名 相同，则不需要配置 column hibernate 中对象的状态 瞬时状态：没有 id，没有在 session 缓存中 持久化状态：有 id ，在 session 缓存中 游离/托管状态：有 id ，没有在 session 缓存中 save 方法实质是将 瞬时状态的转变成持久化状态 执行 save 方法时，为了将对象转换成持久化状态必须生成 id 值，如果需要的话会执行 insert 语句来生成：主键自增的情况下 如果是 increament ：查询数据库 id 最大值作为主键的情况下会执行查询数据库 id 最大值的 sql 语句 持久化对象的特点：持久化对象的任何变化都会自动同步到数据库 save/update ：将瞬时/游离状态的对象转变为持久化状态（saveOrupdate 方法可以通用） delete/close：将持久化状态的对象转变为 瞬时/游离状态 get 直接获得一个持久化状态的对象 hibernate 的作用：把希望持久化到数据库的数据，其对应的对象状态变为持久化 hibernate 事务sf.getCurrentSession();//获得当前与 Thread 绑定的 session（多次获得都是同一个 session） 需要配置 hibernate.cfg.xml 中的&lt;property name=&quot;hibernate.connection.isolation&quot;&gt;4&lt;/property&gt;才能使用 通过 getCurrentSession() 获得的 session 事务提交后，session 会自动关闭，不需要 close HQL 语句只有对象名和属性名，没有数据库的任何表名和属性名 hibernate 一级缓存+缓存快照作用：可以提高查询效率，可以减少不必要的修改语句的发送 程序–&gt;get 方式查询时–&gt;hibernate 先从缓存中查看是否有相同 id 的对象，如果有直接返回缓存中；如果没有，发送 sql 语句查询数据库–&gt;数据库返回一个 ResultSet–&gt;hibernate 将 resultSet 中的数据组装成两个对象，并存入 session 缓存中，另一个存入缓存快照–&gt;session 中的对象返回程序–&gt; 如果程序修改了对象进行事务提交–&gt;hibernate 会比对缓存中对象和快照，如果有变化会同步到数据库，如果没变化则不修改 所以在执行多条 相同 get 语句查询相同 id 对象时，只会执行一次查询数据库操作，其余的都在缓存中查找。 inverse（反转） 属性：inverse 属性为空时，默认 false 表示维护当前外键关系，true 表示放弃维护 一对多时，一的一方放弃维护 当遇到多对多关系时，必须有一方放弃维护关系，具体放弃方由业务决定 例：员工入职时需要指定职位，此时由员工维护，职位放弃维护 cascade （级联操作）属性：save-update:级联保存更新 delete：级联删除 all：级联保存更新+删除 用来简化代码书写，一般只用 save-update，delete 在多对多表中容易多张表关联删除 主键生成策略increment：代理主键，适合于所有数据库，由hibernate维护主键自增，和底层数据库无关，但是不适合于2个或以上hibernate进程。 identity：代理主键，适合于Mysql或ms sql server等支持自增的dbms，主键值不由hibernate维护。 sequence：代理主键，适合于oracle等支持序列的dbms，主键值不由hibernate维护，由序列产生。（Oracle中很常用） native：代理主键，根据底层数据库的具体特性选择适合的主键生成策略，如果是mysql或sqlserver，选择identity，如果是oracle，选择sequence。（推荐） hilo：代理主键，hibernate把特定表的字段作为hign值，生成主键值 uuid.hex：代理主键，hibernate采用uuid 128位算法生成基于字符串的主键值 assigned：适合于应用程序维护的自然主键。 用 varchar 作为主键生成策略的7种里只有2种：uuid 与 assigned–手动指定， 企业中数据字典表的维护，直接修改表维护，一般不会根据项去修改表，所以此时主键生成策略是用不到的。 Hibernate主键生成策略 Hibernate各种主键生成策略与配置详解 123&lt;id name=&quot;dict_id&quot; &gt; &lt;generator class=&quot;native&quot;&gt;&lt;/generator&gt;&lt;/id&gt; 一对多，多对一ORM O:对象 一的一方使用集合，多的一方直接引用一的一方 R:关系型数据库 多的一方使用外键引用一的一方的主键 M:映射文件 12345678一：&lt;set name=""&gt; &lt;key column="外键"&gt; &lt;one-to-many class=""/&gt;&lt;/set&gt;多：&lt;many-to-one name="" column="" class=""&gt; 在一张表的外键访问另一张表的主键时，外键字段的值是多个的，也就是多条记录，是多的一方。另一张表因为是主键，所以只有一个，是一的一方。 在配置时，如果多的一方需要通过数据字典访问一的一方，那么多的一方需要配置多对一关系。如果一的一方不需要通过数据字典反过来访问多的一方，则在数据字典实体中不需要配置一对多关系 多对多ORM O:对象 两方都使用集合 R:关系型数据库 使用中间表，至少两列，作为外键引用两张表的主键 M:映射文件 12345多：&lt;set name="" table="中间表名"&gt;&lt;key column="外键,别人引用我的"/&gt;&lt;many-to-many class="" column="我引用别人的"/&gt;&lt;/set&gt; Hibernate 中 detached 分离的 Criteria 标准，规则 detachedCriteria restriction 限制 格式 serviceImpl 1234//创建语句，给与返回类型DetachedCriteria detachedCriteria = DetachedCriteria.forClass(Staff.class);//给予限定条件detachedCriteria.add(Restrictions.eq("deltag",0)); Hibernate Restrictions 方法 说明 Restrictions.eq ＝ Restrictions.allEq 利用Map来进行多个等于的限制 Restrictions.gt ＞ Restrictions.ge ＞＝ Restrictions.lt ＜ Restrictions.le ＜＝ Restrictions.between BETWEEN Restrictions.like LIKE Restrictions.in in Restrictions.and and Restrictions.or or Restrictions.sqlRestriction 用SQL限定查询 全称： QBC常用限定方法 Restrictions.eq –&gt; equal,等于. Restrictions.allEq –&gt; 参数为Map对象,使用key/value进行多个等于的比对,相当于多个Restrictions.eq的效果 Restrictions.gt –&gt; great-than &gt; 大于 Restrictions.ge –&gt; great-equal &gt;= 大于等于 Restrictions.lt –&gt; less-than, &lt; 小于 Restrictions.le –&gt; less-equal &lt;= 小于等于 Restrictions.between –&gt; 对应SQL的between子句 Restrictions.like –&gt; 对应SQL的LIKE子句 Restrictions.in –&gt; 对应SQL的in子句 Restrictions.and –&gt; and 关系 Restrictions.or –&gt; or 关系 Restrictions.isNull –&gt; 判断属性是否为空,为空则返回true Restrictions.isNotNull –&gt; 与isNull相反 Restrictions.sqlRestriction –&gt; SQL限定的查询 Order.asc –&gt; 根据传入的字段进行升序排序 Order.desc –&gt; 根据传入的字段进行降序排序 MatchMode.EXACT –&gt; 字符串精确匹配.相当于”like ‘value’” MatchMode.ANYWHERE –&gt; 字符串在中间匹配.相当于”like ‘%value%’” MatchMode.START –&gt; 字符串在最前面的位置.相当于”like ‘value%’” MatchMode.END –&gt; 字符串在最后面的位置.相当于”like ‘%value’” Restrictions 用法 懒加载get 方法，立即加载，执行方法时执行 sql 语句查询结果 load 方法（默认）：在执行时，不发送任何 sql 语句，返回一个对象，使用该对象时才执行查询（懒加载/延迟加载：只是获得没有使用，使用时查询）。可以在 class 元素上配置 lazy 属性控制，默认 lazy=true 实行懒加载，改为 lazy=false 则不执行懒加载。 load 方法使用了代理 ，使 返回的代理对象能够在使用属性时，根据关联 session 查询数据库，加载数据 打印对象中 $ 符号，指代理对象，可以对方法进行改造或增强 关联级别查询 为了提高效率，fetch 选择 select ，lazy 取 true，全部为默认值 no-session-Exception:因为在代理对象被放到页面时，session 一定关闭了，所以需要扩大 session 作用域 Struts2用来代替 servlet 层进行处理访问服务器的请求的 servlet 线程安全问题servlet 的线程不安全问题 servlet 只创建一个对象实例，所以只有一个成员变量（它随着对象的创建而创建），多个用户访问 servlet 只修改一个成员变量，可能会有覆盖问题，会导致线程安全问题 struts2 的 Action 在每次请求时都会创建一个新的 Action 实例对象，所以是线程安全的，可以定义成员变量接收参数 struts1 基于 servlet，servlet 有线程不安全问题 struts2 基于 filter 过滤器 struts2 的核心是拦截器（inteceptor） 拦截器封装了很多功能，且用了可插拔设计，使用了 aop 思想（将纵向重复代码，横向抽取），在调用 action 前先调用 inteceptor struts2 Result 详解 i18n:国际化：配置多国语言，根据浏览器发送的不同编码，读取不同语言版本的配置文件，动态将配置文件信息显示到页面。解决 post 提交乱码问题 reload 热加载 redeploy 热部署 动态配置方法调用：通配符方式 POJO：不用继承任何父类，也不需要实现任何接口的类 tomcat 没有 artifact 的配置 idea 项目配置简介 struts 的数据中心：ActionContext（它是一个 Map）用来获得原生 ServletAPI 生命周期：每次请求都会创建一个对应的 ActionContext 对象，请求处理完，ActionContext 销毁。ActionContext 中只是获得 各个域 及对象（request,response,sevletContext 等）的引用，不会影响其生命周期。 request 域 与 session 域 application 域，实质就是在 HttpRequest/HttpSession/servletContext 的一块空间中创建了 Map，用 set/getAttribute 来存取值（param 参数存取也是一个 Map） ActionContext 与 request 的生命周期相同，所以官方推荐使用 ActionContext 代替 requestScope struts2 的 ActionContext 加强了 request 的方法，使其在取值时仍旧使用原有的方法。调用的就是 request.getAttribute() 方法， 先去 request 域中找，也去 ActionContext 的域中找。存值用 ActionContext ； struts 结果集：转发、重定向、转发 Action、重定向 Action Struts mvcc:Filter m:Action v:Result 获得参数的方式有 struts2 的话，表单参数会自动封装到栈顶对象 属性驱动 - Action 准备与参数建同名属性，创建参数的 set 方法 对象驱动 - Action 准备与参数建同名属性（页面属性名需要改为 Obj.property），将属性封装到对象中，模型对象驱动栈顶对象（ModelDriven\&lt;栈顶对象>）不能生成 get set 方法 模型驱动 - 实现 ModelDriven 接口 - 实现 getModel 方法，返回需要封装参数的对象（可以直接返回对象，页面属性名跟 servlet 一样，但返回多对象麻烦） 复杂参数封装 List 集合：提交键：list list[index] Map 集合： 提交键：map[‘key’] 为什么使用模型驱动： 当我们使用params拦截器完成数据自动封装的时候，如果要封装的是JavaBean对象，那么在web表单中就必须的name写上javaBean.属性名…. 这样的话，web层和Action层就耦合了…因为在web层必须要知道封装的JavaBean对象是什么才能够实现自动封装！ 而模型驱动就解决了这个问题！即时不知道Action层的JavaBean对象是什么，也能够完成数据自动封装！ struts2 模型驱动理解 实现方式：参数拦截器 &lt;interceptor name=&quot;params&quot;class=&quot;com.opensymphony.xwork2.interceptor.ParametersInterceptor&quot;/&gt; 数据自动封装获得参数 struts2 获得参数 OGNL 与 Struts2OGNL：Object-Graph Navigation Language 对象视图导航语言 OGNL 与 struts2 没关系，是一种独立的表达式语言 el 表达式 ${user.addr.name} 等表达式是 对象视图导航 OGNL 本质跟 el 表达式差不多，但添加了许多功能 OGNL 包含在 struts2 的包中，包名为：”ognl-var.jar” el表达式的取值范围为 11 大内置对象 OGNL 的取值范围是 OGNLContext：OGNL上下文对象 OGNLContext 内部有两部分组成：root/context root 中可以放置任何对象 context 中需要存放 map （键值对） OGNL 可以调用静态方法（不需要对象） OGNL 表达式要运行先要准备一个 OGNLContext，struts2 准备了一个 ValueStack（值栈） 作为 OGNLCOntext， OGNLContext 由两部分构成，一部分叫 Root，放置的是一个栈，一部分叫 Context，将 AcitonContext （数据中心）放入 默认情况下 Root（栈）中放置当前访问的 Action 对象 ActionContext 下放的是：request、response、servletContext、requestScope、sessionScope、applicationScope、parameters、attrs… list 集合制作栈结构容器 push ：压栈：list.add(0,obj); list 的索引一定是连续的，如果 list 中添加了 0 索引的值，之后的索引会往后延续 pop：弹栈：list.remove(0); list remove 方法会移除 0 索引的值，并返回该值，后续的索引会往前移 在栈中取属性时，从栈顶开始，找不到就往下找，直到找到停止。 struts2 中参数接受由 OGNL 引擎完成 属性驱动:从 Root 中拿到 name 属性值，并赋值为 tom — name = tom 对象驱动：从栈顶对象中获得 user 属性，再获得 user 属性的 name 属性，赋值为 tom – user.name = tom 模型驱动：从栈顶对象获得 name 属性，并赋值为 tom — name = tom 因为实现模型驱动需要在 赋值前，将接受的参数压入栈顶，不然无法赋值。 但是默认的 拦截器中，赋值的 param 拦截器运行比 action（压栈）早，所以需要自己去实现 Preparable 接口,实现 prepare 方法，把 action 的压栈代码放到 prepare 方法。 1234//获得栈值ValueStack vs = ActionContext.getContext().getValueStack();//将 User u 压入栈顶vs.push(u); 或者可以使用 ModelDriven 接口，实现 public User getModel( return u){} 方法，将压栈方法放入其中，实现原理跟 prepare 一致。 拦截器生命周期：随项目启动而创建，随项目关闭而销毁，类似 filter idea 查看源码没有注释的原因及解决方法 idea 直接查看源码是 jar 包反编译 .class 文件得到的，注释不会存在于 .class 文件中， 若需要注释则需要导入 .java 的 jar 包，即 -sources.jar 后缀的文件 。 idea 查看 jar 包没有注释 拦截器放行则调用 invoke() 方法，如果不想放行直接返回一个页面则 return 一个字符串，赋值给 resultCode(源码中)，使其不再递归调用 invoke() 就不会调用后续拦截器及 action 123456window.onload=function()&#123; if(window.parent != window)&#123;//如果页面再框架中 //让框架页面跳转到登陆页面 window.parent.location.href="$&#123;pageContext.request.contextPath&#125;/login.jsp"; &#125; &#125; 解决登录页跳转在框架中的方法 Struts2 xml 配置1234567891011121314151617181920212223242526&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE struts PUBLIC "-//Apache Software Foundation//DTD Struts Configuration 2.3//EN" "http://struts.apache.org/dtds/struts-2.3.dtd"&gt;&lt;struts&gt; &lt;!-- 配置常量 --&gt; &lt;!-- 字符集 --&gt; &lt;constant name="struts.i18n.encoding" value="UTF-8"&gt;&lt;/constant&gt; &lt;!-- 开发模式 --&gt; &lt;constant name="struts.devMode" value="true"&gt;&lt;/constant&gt; &lt;!-- 主题 --&gt; &lt;constant name="struts.ui.theme" value="simple"&gt;&lt;/constant&gt; &lt;!-- 扩展名 --&gt; &lt;constant name="struts.action.extension" value="action"&gt;&lt;/constant&gt; &lt;!-- 通用package --&gt; &lt;package name="customer" namespace="/" extends="struts-default"&gt; &lt;!--如果struts2 没有被 spring 代理时，需要在 class 中填写完整类名，method 表示访问 action 中的某个方法，name 是一个返回的名称，与项目名路径拼接成一个访问路径。如果被 spring 代理则填写 spring 配置的 action 名即可--&gt; &lt;action name="findById" class="cn.itcast.crm.action.CustomerAction" method="findCustomerById"&gt; &lt;result name="success"&gt;/info.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; action 中 name 是访问时根据 项目名+name+.action 来拼接访问网址用的，class 是该类的完整类名（由 spring 管理 struts2 时，spring 的 application.xml 文件中会配置该 action，所以那时只需要填写 spring 中配置的 action 的 name 属性即可），method 表示该 action 中要访问哪个方法，result 表示访问该方法后，return 了 success 后的跳转页面 如果配置扩展名的 constant，则在网站访问时，必须是 actionName.action 等有后缀的方式，具体后缀名根据配置改变 Springspring 管理项目中所有对象 Spring 框架是容器性质的，容器中有什么对象就有什么功能，是一站式框架 创建 idea web项目 创建 spring xml 配置文件： 先创建一个项目，然后配置好spring依赖，随后新建xml文件就可以看到Spring Config选项了，选择它，然后输入配置文件名（applicationContext），建好了spring的配置文件。 spring 导包：4个核心包，2个日志包，1个 web 整合包 控制反转（Inversion of Control，缩写为IOC） 反转控制就是反转对象的创建方式，由我们自己创建反转成 spring（容器）创建 依赖注入（Dependency Injection，简称DI） 依赖注入就是实现 IOC 思想的方式 注入方式： set 方法注入 构造方法注入 字段注入 注入类型： 值注入：8 大数据类型都是值注入，可以将在一个 name 创建时给与值 “三爷” 引用类型注入：将依赖对象注入，将 dao 注入到 service 或将 service 注入到 action BeanFactory spring 的原始接口，针对其接口的功能比较单一，BeanFactory 接口实现类的容器在获得对象时才会创建 AppicationContext Spring 比较末端的接口，每次启动时创建容器中所有配置对象，并提供更多功能 从类路径加载配置文件:classPathXmlApplicationContext web 开发用 AppicationContext，手机等资源匮乏的地方用 BeanFactory spring 配置Bean 元素 name 属性 与 id 属性都是用来给被管理对象起名，在获得对象时根据这个名字来获得。 name 属性是为了解决 id 属性不能使用特殊字符规则而创造出来的 class 属性用来获得 对象完整类名 scope 属性 singleton（单例模式）：单例模式的对象在 Spring 容器中只会存在一个实例 prototyte（多例原型）：多例原型的对象每次在获得时才会创建，每次创建都是新的对象 request：web 环境下，对象与 request 生命周期一致（不用） session：web 环境下，对象与 session 生命周期一致（不用） 一般情况都是用默认配置 singleton，但与 struts2 整合时，给 action 的 bean 必须声明多例（struts 每个请求都会创建一个新的 action） 创建方式 空参构造创建（对象创建必须通过构造函数）(推荐) &lt;bean name=&quot;user&quot; class=&quot;com.xxx.bean.User&quot;&gt;&lt;/bean&gt; 静态工厂 实例工厂 分模块配置 将一个配置文件导入另一个配置文件中 &lt;import resource=&quot;cn.xxx.applicationContext.xml&quot;/&gt; spring 定义 bean 的三种方式 属性注入 12345678910111213&lt;bean name="user" class="cn.xxx.bean.User"&gt; &lt;!--set 注入 ，为 User 对象 name，age 属性 注入值--&gt; &lt;property name="name" value="zhangsan"&gt;&lt;/property&gt; &lt;property name="age" value="11"&gt;&lt;/property&gt; &lt;!--引用类型注入用 ref ，对象注入,将下方配置的 Car 注入到 User--&gt; &lt;property name="car" ref="car"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- 将 Car 配置到容器,注入到其他对象 --&gt;&lt;bean name="car" class="cn.xxx.bean.Car"&gt; &lt;property name="name" value="迈巴赫"&gt;&lt;/property&gt; &lt;property name="cloor" value="黑"&gt;&lt;/property&gt;&lt;/bean&gt; 构造函数注入 123456&lt;!-- index 属性指定构造函数参数的索引地址， type 指定参数类型 --&gt;&lt;bean name="user" class="cn.xxx.bean.User"&gt; &lt;constructor-arg name="name" value="lisi" index="0" type="java.lang.Integer"&gt;&lt;/constructor-arg&gt; &lt;!--引用类型注入用 ref ，对象注入,将上方配置的 Car 注入到 User--&gt; &lt;constructor-arg name="car" ref="car"&gt;&lt;/constructor-arg&gt;&lt;/bean&gt; p名称注入 先导入xmlns:p=&quot;http://www.springframework.org/schema/p&quot; &lt;bean name=&quot;user3&quot; class=&quot;cn.xxx.bean.User&quot; p:name=&quot;jack&quot; p:age=&quot;18&quot; p:car-ref=&quot;car&quot;&gt;&lt;/bean&gt; 本质还是走 set 构造，用来简化 property 配置方式。 spel 注入：spring Expression Language， spring 表达式语言 复杂类型注入 12345678910111213141516171819202122232425262728&lt;bean name="cb" class="cn.itheima.bean.CollectionBean"&gt; &lt;property name="arr"&gt; &lt;!--多元素 array 注入--&gt; &lt;array&gt; &lt;value&gt;tom&lt;/value&gt; &lt;value&gt;jim&lt;/value&gt; &lt;ref bean="car"/&gt; &lt;/array&gt; &lt;/property&gt; &lt;!--map 类型注入--&gt; &lt;property name="map"&gt; &lt;map&gt; &lt;entry key="url" value="jdbc:mysql///hibernate"&gt;&lt;/entry&gt; &lt;entry key="carName" value-ref="car"&gt;&lt;/entry&gt; &lt;entry key-ref="user" value-ref="user"&gt;&lt;/entry&gt; &lt;/map&gt; &lt;/property&gt; &lt;!--property 类型注入--&gt; &lt;property name="prop"&gt; &lt;props&gt; &lt;prop key="driverClass"&gt;com.jdbc.com.Driver&lt;/prop&gt; &lt;prop key="userName"&gt;root&lt;/prop&gt; &lt;prop key="password"&gt;1234&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt; tomcat jar 包导入，并且应用到 mudeule 先在右上角点击 Edit Configurations，选择 tomcat ，设置名称，点击 Application server 右侧的 configure，选择左侧的 tomcat 版本（记住这个版本号），点击第一个 + 号，选择 tomcat 下的 lib 目录。点击确定。 然后 ctrl + alt + shift + s 打开 project structure ，选择 module，选中当前 module。点击右侧 + 号，选择 libraries，选择刚才配置的 tomcat 版本号。完成 Spring 使用注解替代 xml 为主配置导入新的命名空间（约束），导包（4+2+spring-aop) 开启注解代理配置文件 12&lt;!--指定扫描 该 package 下所有类中的注解，扫描时会连带其包下的子孙包一起扫描--&gt; &lt;context:component-scan base-package="cn.xxx.domain"&gt;&lt;/context:component-scan&gt; 在类中使用注解 @Component(“user”) @Service(“user”);（service 层） @Controller(“user”);（web 层，action/servlet） @Repository(“user”);（dao 层，仓库） 四个注解功能相同，下面 3 个更容易区分功能层级（可读性高） 修改对象作用范围： @Scope(ScopeName=”prototype”) 设置为多例，默认为单例(singleton) 值类型注入： @Value(“name”); 可以加在 成员变量上，通过反射的 Field 赋值，破坏封装性 也可以加载 set 方法上，通过 set 方法赋值 @Autowired//自动装配 如果由多个一致类型的对象，则无法选择具体哪一个 @Autowired @Qualifier(&quot;car2&quot;) 有多个一致类型的对象，使用这两条注释，用来选择具体哪个对象 或者直接使用@Resource(name=&quot;car2&quot;) 12345678@PostConstruct//对象创建（被构造）后调用-就是 init-method public void init()&#123; System.out.println("初始化"); &#125; @PreDestroy//对象销毁前调用-destory-method public void destory()&#123; System.out.println("销毁"); &#125; ApplicationContext 没有 close 方法，需要用它的子类 ClassPathXmlApplicationContext spring aop:Spring 能为我们管理的对象动态生成代理对象， 自己创建代理对象需要创建方法 : Proxy.newProxyInstance(classLoader,Interface[] arr,InvocationHandler handler); spring 实现 aop 原理（Spring 混合 2 种代理） 动态代理：被代理对象必须实现接口，才能产生代理对象，如果没有接口就不能使用动态代理技术（有接口时优先使用） cglib 代理：第三方代理技术，可以对任何类生成代理，代理的原理是对目标对象进行继承代理，如果目标对象被 final 修饰，则无法被 cglib 代理（没有接口时使用） aop 名词Joinpoint（连接点）：目标对象中所有可以增强的方法 Pointcut（切入点）：目标对象中已经增强的方法 Advice（通知/增强）：增强的代码（需要添加在 被增强方法 前后的代码） Target（目标对象）：被代理对象 Weaving（织入）：将通知应用到切入点这个过程 Proxy（代理）：将通知织入到目标对象后形成代理 aspect（切面）：切入点+通知 aop 导包： 4个基本包+ spring-aop-5.0.8.RELEASE.jar com.springsource.org.aopalliance-1.0.0.jar com.springsource.org.aspectj.weaver-1.6.8.RELEASE.jar spring-aspects-5.0.8.RELEASE.jar 动态代理 通过动态代理可以实现 aop 思想 对目标对象中方法增强 spring aop 配置 xml aop:config &lt;aop:pointcut expression=”execution( cn.itcast.service.ServiceImpl.*(..))” id=”pc”/&gt; &lt;aop:aspect ref=”myAdvice” &gt; &lt;aop:before method=”before” pointcut-ref=”pc” /&gt; &lt;aop:after-returning method=”afterReturning” pointcut-ref=”pc” /&gt; &lt;aop:around method=”around” pointcut-ref=”pc” /&gt; &lt;aop:after-throwing method=”afterException” pointcut-ref=”pc”/&gt; &lt;aop:after method=”after” pointcut-ref=”pc”/&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt; spring jdbc 配置1234567891011121314151617181920212223242526&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:util="http://www.springframework.org/schema/util" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd"&gt;&lt;context:property-placeholder location="classpath:db.properties"/&gt; &lt;!--将 dataSource 放入 spring 容器--&gt; &lt;bean name="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;property name="jdbcUrl" value="$&#123;jdbc.jdbcUrl&#125;"&gt;&lt;/property&gt; &lt;property name="driverClass" value="$&#123;jdbc.driver&#125;"&gt;&lt;/property&gt; &lt;property name="user" value="$&#123;jdbc.user&#125;"&gt;&lt;/property&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--将 jdbcTemplate 放入 spring 容器--&gt; &lt;!--&lt;bean name="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate"&gt;--&gt; &lt;!--&lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt;--&gt; &lt;!--&lt;/bean&gt;--&gt; &lt;!--将 UserDao 放入 spring容器--&gt; &lt;bean name="userDao" class="cn.itcast.jdbctemplate.UserDaoImpl"&gt; &lt;!--&lt;property name="jt" ref="jdbcTemplate"&gt;&lt;/property&gt;--&gt; &lt;!--直接把 jdbc 连接池注入给 dao --&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; Spring 事务操作事务操作对象：PlatFormTransactionManager 接口 最核心的就是 TransactionManager 对象，给各个数据库操作对象提供不同的接口 Spring 事务属性 事务的隔离级别：1-读已提交，2-读未提交，4-可重复度，8-串行化 是否只读：true（只读）/false（可操作） 事务传播行为：业务（Service）方法之间互相（平行）调用时，事务该如何处理 默认行为：PROPAGATION_REQUIRED 支持当前事务，如果不存在则新建一个（基本只用这个） Spring 事务管理方式 编码式（了解） xml 配置（aop） 123456789101112131415&lt;!--事务核心管理器配置，封装了所有事务操作，依赖于连接池--&gt; &lt;bean name="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;!--配置事务通知--&gt; &lt;tx:advice id="txAdvice" transaction-manager="transactionManager"&gt; &lt;tx:attributes&gt; &lt;tx:method name="transfer" isolation="READ_COMMITTED" propagation="REQUIRED" read-only="false"/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!--配置织入--&gt; &lt;aop:config&gt; &lt;aop:pointcut id="txPc" expression="execution(* cn.itcast.service.impl.*ServiceImpl.*(..))"/&gt; &lt;aop:advisor advice-ref="txAdvice" pointcut-ref="txPc"/&gt; &lt;/aop:config&gt; 注解配置（aop） 123456&lt;!--事务核心管理器配置，封装了所有事务操作，依赖于连接池--&gt;&lt;bean name="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!--开启注解事务--&gt;&lt;tx:annotation-driven/&gt; 类上的注解配置： @Transactional(isolation = Isolation.REPEATABLE_READ,propagation = Propagation.REQUIRED,readOnly = false) 如果想要一个类中所有方法都使用该注解配置，则将其放在类名上，如果其中有个别方法需要额外配置，则另填加注释再该方法上。 SSH 框架整合WEB 层：struts2 + jsp Service 层：javaBean JavaBeans 是Java中一种特殊的类，可以将多个对象封装到一个对象（bean）中。 特点是可序列化，提供无参构造器，提供getter方法和setter方法访问对象的属性。 Dao 层：hibernate struts2 与 spring 整合：将 Action 对象交给 spring 容器来创建 hibernate 与 spring 整合：将 sessionFactory 交给 spring 负责维护，并将 session 的维护以及 aop 事务都交给 spirng 导包： hibernate 包 \hibernate-release-5.0.7.Final\hibernate-release-5.0.7.Final\lib\required 下全部包 \hibernate-release-5.0.7.Final\hibernate-release-5.0.7.Final\lib\jpa\ hibernate-entitymanager-5.0.7.Final.jar mysql-connector-java-5.1.7-bin.jar struts2:包 \struts-2.3.24-all\struts-2.3.24\apps\struts2-blank\WEB-INF\lib 下全部包 \struts-2.3.24-all\struts-2.3.24\lib\ struts2-spring-plugin-2.3.24.jar struts2-spring-plugin-2.3.24.jar 这个包会让 struts2 在项目启动时会去寻找 spring 容器，如果找不到就会报错，单独使用 struts2 项目时不能导入 spring 包 4+2(核心包): \spring-framework-5.0.8.RELEASE-dist\spring-framework-5.0.8.RELEASE\libs 下4个核心包 beans、comtext、core、expression \spring-framework-3.0.2.RELEASE-dependencies\org.apache.log4j\com.springsource.org.apache.log4j\1.2.15 下的 com.springsource.org.apache.log4j-1.2.15.jar \spring-framework-3.0.2.RELEASE-dependencies\org.apache.commons\com.springsource.org.apache.commons.dbcp\1.2.2.osgi 下的 com.springsource.org.apache.commons.dbcp-1.2.2.osgi.jar 整合 web 的包(spring-web)： \spring-framework-5.0.8.RELEASE-dist\spring-framework-5.0.8.RELEASE\libs 下的 spring-web-5.0.8.RELEASE.jar 整合 aop （4个）(spring-aop|spring-aspect|aopalliance|aopweaving) \spring-framework-5.0.8.RELEASE-dist\spring-framework-5.0.8.RELEASE\libs 下的 spring-aop-5.0.8.RELEASE.jar spring-aspects-5.0.8.RELEASE.jar \spring-framework-3.0.2.RELEASE-dependencies\org.aopalliance\com.springsource.org.aopalliance\1.0.0 下的 com.springsource.org.aopalliance-1.0.0.jar \spring-framework-3.0.2.RELEASE-dependencies\org.aspectj\com.springsource.org.aspectj.weaver\1.6.8.RELEASE com.springsource.org.aspectj.weaver-1.6.8.RELEASE.jar 整合 hibernate 事务的（4个）（spring-jdbc|spring-tx|c3p0|spring-orm） \spring-framework-5.0.8.RELEASE-dist\spring-framework-5.0.8.RELEASE\libs 下的 spring-jdbc-5.0.8.RELEASE.jar spring-orm-5.0.8.RELEASE.jar spring-tx-5.0.8.RELEASE.jar \spring-framework-3.0.2.RELEASE-dependencies\com.mchange.c3p0\com.springsource.com.mchange.v2.c3p0\0.9.1.2 下的 com.springsource.com.mchange.v2.c3p0-0.9.1.2.jar junit4 测试包 \SSH\spring-framework-5.0.8.RELEASE-dist\spring-framework-5.0.8.RELEASE\libs 下的 spring-test-5.0.8.RELEASE.jar 单独配置 springweb.xml 123456789&lt;!--让 spring 随 web 启动而创建的监听器--&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!--配置 spring 配置文件位置参数--&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt; 单独配置 struts2struts.xml（sturts2 主配置文件） 1234567891011121314&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE struts PUBLIC "-//Apache Software Foundation//DTD Struts Configuration 2.3//EN" "http://struts.apache.org/dtds/struts-2.3.dtd"&gt;&lt;struts&gt; &lt;constant name="struts.objectFactory" value="spring"&gt;&lt;/constant&gt; &lt;package name="crm" namespace="/" extends="struts-default" &gt; &lt;action name="UserAction_*" class="cn.itcast.web.action.UserAction" method="&#123;1&#125;"&gt; &lt;result name="success"&gt;/success.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; 将 action 的创建（obj 工厂 ）交给 spring 管理struts.objectFactory = spring spring 负责装配 Action 的依赖属性（将 action 中需要创建的 servie 交给 spring 管理）struts.objectFactory.spring.autoWire = name method={1} 代表该方法代表 name 中第几个通配符（*） struts2 核心过滤器 123456789&lt;!--struts2 核心过滤器--&gt; &lt;filter&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;filter-class&gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 整合方案1（不推荐）1234567&lt;!--方案1：class 属性仍然配置 action 完整类名，--&gt; &lt;!--struts2仍然修饰 action ，由 spring 负责组装 Action 中依赖关系--&gt; &lt;package name="crm" namespace="/" extends="struts-default" &gt; &lt;action name="UserAction_*" class="cn.itcast.web.action.UserAction" method="&#123;1&#125;"&gt; &lt;result name="success"&gt;/success.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt; 整合方案2：spring 负责创建 action 及组装applicationContext.xml 123456&lt;!--Action 作用对象一定是多例的--&gt; &lt;bean name="userAction" class="cn.itcast.web.action.UserAction" scope="prototype"&gt; &lt;property name="us" ref="userService"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean name="userService" class="cn.itcast.service.impl.UserServiceImpl"&gt;&lt;/bean&gt; struts.xml 12345&lt;package name="crm" namespace="/" extends="struts-default" &gt; &lt;action name="UserAction_*" class="userAction" method="&#123;1&#125;"&gt; &lt;result name="success"&gt;/success.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt; 单独配置 hibernate导入orm元数据 与 实体类 配置文件 12345678910111213141516171819202122232425262728293031323334&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE hibernate-configuration PUBLIC "-//Hibernate/Hibernate Configuration DTD 3.0//EN" "http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd"&gt;&lt;hibernate-configuration&gt; &lt;session-factory&gt; &lt;!-- 数据库驱动 --&gt; &lt;property name="hibernate.connection.driver_class"&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;!-- 数据库url --&gt; &lt;property name="hibernate.connection.url"&gt;jdbc:mysql:///crm_32&lt;/property&gt; &lt;!-- 数据库连接用户名 --&gt; &lt;property name="hibernate.connection.username"&gt;root&lt;/property&gt; &lt;!-- 数据库连接密码 --&gt; &lt;property name="hibernate.connection.password"&gt;root&lt;/property&gt; &lt;!-- 数据库方言--&gt; &lt;property name="hibernate.dialect"&gt;org.hibernate.dialect.MySQLDialect&lt;/property&gt; &lt;!-- 将hibernate生成的sql语句打印到控制台 --&gt; &lt;property name="hibernate.show_sql"&gt;true&lt;/property&gt; &lt;!-- 将hibernate生成的sql语句格式化(语法缩进) --&gt; &lt;!-- auto schema export 自动导出表结构. 自动建表--&gt; &lt;property name="hibernate.hbm2ddl.auto"&gt;update&lt;/property&gt; &lt;!-- 引入orm元数据 路径书写: 填写src下的路径 --&gt; &lt;mapping resource="cn/itcast/domain/Customer.hbm.xml" /&gt; &lt;mapping resource="cn/itcast/domain/LinkMan.hbm.xml" /&gt; &lt;mapping resource="cn/itcast/domain/User.hbm.xml" /&gt; &lt;/session-factory&gt;&lt;/hibernate-configuration&gt; spring 整合 hibernate方案一：spring 中配置 sessionFactory（不重要） applicationContext.xml 12345&lt;!--将 SessionFactory 配置到 spring 容器中--&gt; &lt;bean name="sessionFactory" class="org.springframework.orm.hibernate5.LocalSessionFactoryBean"&gt; &lt;!--加载配置方案1：仍然使用外部 hibernate.cfg.xml 配置信息--&gt; &lt;property name="configLocation" value="hibernate.cfg.xml"&gt;&lt;/property&gt; &lt;/bean&gt; 方案二：将 hibernate 配置文件放到 spring 的配置文件中（使用该方法） 123456789101112131415161718192021&lt;bean name="sessionFactory" class="org.springframework.orm.hibernate5.LocalSessionFactoryBean"&gt; &lt;!--加载配置方案2：在 spring 配置中放置 hibernate 配置信息--&gt; &lt;!--配置 hibernate 基本信息--&gt; &lt;property name="hibernateProperties"&gt; &lt;props&gt; &lt;!--必选配置--&gt; &lt;prop key="hibernate.connection.driver_class"&gt;com.mysql.jdbc.Driver&lt;/prop&gt; &lt;prop key="hibernate.connection.url"&gt;jdbc:mysql:///crm_32&lt;/prop&gt; &lt;prop key="hibernate.connection.username"&gt;root&lt;/prop&gt; &lt;prop key="hibernate.connection.password"&gt;root&lt;/prop&gt; &lt;prop key="hibernate.dialect"&gt;org.hibernate.dialect.MySQLDialect&lt;/prop&gt; &lt;!--可选配置--&gt; &lt;prop key="hibernate.show_sql"&gt;true&lt;/prop&gt; &lt;prop key="hibernate.format_sql"&gt;true&lt;/prop&gt; &lt;prop key="hibernate.hbm2ddl.auto"&gt;update&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;!--引入元数据--&gt; &lt;property name="mappingDirectoryLocations" value="cn/itcast/domain"&gt;&lt;/property&gt; &lt;/bean&gt; spring 整合 c3p0 连接池 配置 db.properties ，放入用户密码等键值对 引入连接池到 spring 123456789&lt;!--开启 session 连接池--&gt; &lt;context:property-placeholder location="classpath:db.properties"/&gt; &lt;!--将 dataSource 放入 spring 容器--&gt; &lt;bean name="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;property name="jdbcUrl" value="$&#123;jdbc.jdbcUrl&#125;"&gt;&lt;/property&gt; &lt;property name="driverClass" value="$&#123;jdbc.driver&#125;"&gt;&lt;/property&gt; &lt;property name="user" value="$&#123;jdbc.user&#125;"&gt;&lt;/property&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt; 将连接池注入到 sessionFactory,hibernate 会通过连接池获得连接 spring 整合 hibernate 操作数据库dao 类创建继承 HibernateDaoSupport 模板操作 ：execute / findByCriteria 1234567891011121314151617181920212223242526272829303132//hibernateDaoSupport 使用 需要为 dao 注入 sessionFactorypublic class UserDaoImpl extends HibernateDaoSupport implements UserDao &#123; @Override //匿名内部类引用外部变量必须设置为 final public User getByUserCode(final String usercode) &#123; //HQL// return getHibernateTemplate().execute(new HibernateCallback&lt;User&gt;() &#123;// @Override// public User doInHibernate(Session session) throws HibernateException &#123;// String hql = " from User where user_code=? ";// Query query = session.createQuery(hql);// query.setParameter(0,usercode);// User user = (User) query.uniqueResult();// return user;// &#125;// &#125;); //Criteria DetachedCriteria dc = DetachedCriteria.forClass(User.class); dc.add(Restrictions.eq("user_code",usercode)); List&lt;User&gt; list = (List&lt;User&gt;) getHibernateTemplate().findByCriteria(dc); if(list!=null &amp;&amp; list.size()&gt;0)&#123; return list.get(0); &#125;else&#123; return null; &#125; &#125;&#125; applicationContext.xml 注入 sessioFactory 1234&lt;bean name="userDao" class="cn.itcast.dao.impl.UserDaoImpl"&gt; &lt;!--模板操作需要注入 sessionFactory--&gt; &lt;property name="sessionFactory" ref="sessionFactory"&gt;&lt;/property&gt; &lt;/bean&gt; spring AOP 事务配置核心事务管理器 1234&lt;!--核心事务管理器--&gt;&lt;bean name="transactionManager" class="org.springframework.orm.hibernate5.HibernateTransactionManager"&gt; &lt;property name="sessionFactory" ref="sessionFactory"&gt;&lt;/property&gt;&lt;/bean&gt; xml 配置 aop 事务 配置通知 12345678910111213&lt;!--配置通知--&gt; &lt;tx:advice id="txAdvice" transaction-manager="transactionManager"&gt; &lt;tx:attributes&gt; &lt;tx:method name="save*" isolation="REPEATABLE_READ" propagation="REQUIRED" read-only="false" /&gt; &lt;tx:method name="persist*" isolation="REPEATABLE_READ" propagation="REQUIRED" read-only="false" /&gt; &lt;tx:method name="update*" isolation="REPEATABLE_READ" propagation="REQUIRED" read-only="false" /&gt; &lt;tx:method name="modify*" isolation="REPEATABLE_READ" propagation="REQUIRED" read-only="false" /&gt; &lt;tx:method name="delete*" isolation="REPEATABLE_READ" propagation="REQUIRED" read-only="false" /&gt; &lt;tx:method name="remove*" isolation="REPEATABLE_READ" propagation="REQUIRED" read-only="false" /&gt; &lt;tx:method name="get*" isolation="REPEATABLE_READ" propagation="REQUIRED" read-only="true" /&gt; &lt;tx:method name="find*" isolation="REPEATABLE_READ" propagation="REQUIRED" read-only="true" /&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; 配置织入 1234567&lt;!--配置将通知织入目标对象--&gt; &lt;aop:config&gt; &lt;!--配置切点--&gt; &lt;aop:pointcut id="txPc" expression="execution(* cn.itcast.service.impl.*ServiceImpl.*(..))"/&gt; &lt;!--配置切面--&gt; &lt;aop:advisor advice-ref="txAdvice" pointcut-ref="txPc"/&gt; &lt;/aop:config&gt; 注解事务开启注解事务 &lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;&gt;&lt;/tx:annotation-driven&gt; 在类或方法上添加注释（类上加的话，类中方法全部使用该注释，特例的方法上可以单独加注释覆盖类注释） @Transactional(isolation= Isolation.REPEATABLE_READ,propagation = Propagation.REQUIRED,readOnly = true) 扩大 session 作用域避免使用懒加载时出现 no-session 问题（session 在到达 jsp 前已经关闭），需要扩大 session 作用域 123456789101112&lt;!--扩大 session 作用范围 该 filter 一定要在 struts 的 filter 之前 struts 过滤器没有 放行代码，所有过滤器都要在 struts 前--&gt; &lt;filter&gt; &lt;!--在视图 jsp 中 session 还是打开的--&gt; &lt;filter-name&gt;openSessionInView&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.orm.hibernate5.support.OpenSessionInViewFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;openSessionInView&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; maven 的使用maven 的用途 maven 能统一管理依赖（管理项目的 jar 包），从而节省项目空间 能一键构建项目：mvn tomcat:run 能不依靠 tomcat 直接运行项目 可以跨平台（因为是 java 开发的，专门用于 java 项目的，而 java 是跨平台的） 用于大型开发项目，可以提高开发效率（将一个项目分成多个小项目，分模块开发）（按业务分或按层分：dao、web、service） maven 仓库它有三种仓库： 本地仓库：自己维护，需要修改 C:\Users\用户名.m2 下 setting.xml 文件的 属性&lt;localRepository&gt;C:\repository&lt;/localRepository&gt; 远程仓库：公司维护，本地仓库没有 jar 包时去这里下载 中央仓库：maven 团队维护，2亿 jar 包，如果远程仓库没有会去这里下载，也可以直接下载到本地仓库。 maven 项目目录结构maven-helloworld src main：主目录 java：放置 java 代码 resource：放置 xml 以及 properties 等原来 src 目录下的配置文件 webapp test：测试目录 java：java 代码，junit 测试调用 resources：junit 测试用到的配置文件，如果内部没有测试文件，默认从 main 中找 meven 常用命令 mvn tomcat:run 一键启动运行 mvn clean 删除编译的文件（target 文件夹） mvn compile 编译主目录文件 mvn test 编译并运行 测试目录的文件（test 目录） mvn package 打包项目成 war 包（包名，后缀名都是在 pom.xml 中配置的） mvn install 将项目发布到配置的本地仓库 三种生命周期clean 生命周期：clean Default 生命周期：Compile、test、package、install、deploy（按顺序） Set 生命周期：site（用来生成项目的站点文档，用来描述项目） 同一生命周期的顺序靠后的命令执行时会同时顺序执行在前的命令 不同生命周期的命令可以同时执行（mvn clean package，这样会执行 clean 后执行 package） Intellj IDEA 创建 maven 项目 创建 project - maven project（作为 parent）勾选 create from archetype 选项，选择下方的 maven-archetype-site，这样该项目就可以成为父工程，聚合子模块，让其他模块继承。 创建继承父工程的前台管理模块 portal_manager，在 parent 的工程上右键 new module，同样勾选 create from archetype 选项，选择下方的 maven-archetype-site，下一步。为了只是让改模块管理版本，而不是成为 parent 子模块，需要在上方 Add As module to 的右侧，点击 ··· 按钮，选择 none，取消继承 parent。取名（名字中间的分隔符建议使用 _ ，如果使用 - 会被 idea 自动忽略，需要下一步手动添加），下一步选择路径，去掉 parent 路径，让其与 parent 在同一路径下。完成。 创建继承 manager 的子模块 dao，勾选 create from archetype 选项，选择 maven-archetype-quickstart，下一步，取名，下一步目录指定为 manager 路径下，完成， service 同上，给 service 添加一个 dao 模块的 dependency 依赖 创建继承 manager 的 web 模块，勾选 create from archetype 选项，选择下方的 org.apache.maven.archetype-maven-archetype-webapp（有2个 web 模块，注意别选错），其余同上。完成后手动创建 src/main/java 目录，将 java 文件夹变为 source，给其添加 service 依赖。 后台创建同以上 2-5 步 back_manager，然后需要让前台的 service 依赖后台 dao，前台的 web 依赖后台 service 右键创建类没有 servlet 的话，在 maven 的 pom.xml 下 dependencies 中配置 servlet 即可，如果还是没有就刷新 maven 的 pom 文件 idea 配置 maven 项目入门 创建 maven 项目无 src 目录 IntelliJ IDEA创建maven多模块项目 maven dependency 机制 b站 idea 教程视频 jar 包依赖范围：Compile：编译时需要，测试时需要，运行时需要(struts2-core) Provided：编译时需要，测试时需要，打包时不需要（jsp-api.jar，servlet-api.jar） Runtime：编译时不需要，运行时不需要，打包时需要（数据库驱动包） Test：编译时不需要，测试时需要，打包时不需要（junit.jar） pom.xml1234567891011121314151617181920212223242526272829303132333435&lt;!--约束的版本信息--&gt;&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;&lt;!--坐标 GAV--&gt;&lt;groupId&gt;cn.itcast&lt;/groupId&gt;&lt;artifactId&gt;ssh&lt;/artifactId&gt;&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&lt;!--打包方式 jar war pom--&gt;&lt;packaging&gt;war&lt;/packaging&gt;&lt;name&gt;ssh Maven Webapp&lt;/name&gt;&lt;!-- FIXME change it to the project's website --&gt;&lt;url&gt;http://www.example.com&lt;/url&gt;&lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.7&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.7&lt;/maven.compiler.target&gt;&lt;/properties&gt;&lt;!--jar 包依赖--&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.struts&lt;/groupId&gt; &lt;artifactId&gt;struts2-core&lt;/artifactId&gt; &lt;version&gt;2.3.24&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;!--内部配置了多个插件--&gt;&lt;build&gt;&lt;plugins&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-clean-plugin&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;/plugin&gt;&lt;/plugins&gt;&lt;/build&gt; 依赖版本冲突解决调节原则： 路径近者优先原则 第一申明者优先原则 排除原则 版本锁定 idea 使用 maven 分模块开发[使用IDEA创建maven项目整合SSH(多模块聚合) 使用IDEA创建maven项目 依赖传递在 scope 为 test 时会无法传递到下一个模块，可以在下一个模块中再添加一个同样 scope 为 test 的依赖 聚合运行：在 parent 项目上 tomcat：run，最终打的 package 中是 web 中的 jar 包，所以不会出现 jar 包冲突 pom 文件中配置的路径为 网页访问路径 123456789101112&lt;!-- maven内置 的tomcat6插件 --&gt;&lt;plugin&gt; &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt; &lt;artifactId&gt;tomcat-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.1&lt;/version&gt; &lt;configuration&gt; &lt;!-- 可以灵活配置工程路径 --&gt; &lt;path&gt;/ssh&lt;/path&gt; &lt;!-- 可以灵活配置端口号 --&gt; &lt;port&gt;8080&lt;/port&gt; &lt;/configuration&gt;&lt;/plugin&gt; 分模块测试 junit 123456789101112131415161718192021222324package cn.itcast.crm.service.impl;import cn.itcast.crm.entity.Customer;import cn.itcast.crm.service.CustomerService;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;//@ContextConfiguration(locations=&#123;"classpath:applicationContext-service.xml","classpath:applicationContext-dao.xml"&#125;)//表示 从jar包中获得 xml 时需要加上 classpath*，applicationContext-* 表示任何后缀都获取（service/dao....）@ContextConfiguration(locations=&#123;"classpath*:applicationContext-*.xml"&#125;)@RunWith(SpringJUnit4ClassRunner.class)public class CustomerServiceImplTest &#123; @Autowired private CustomerService customerService; @Test public void findById() &#123; Customer customer = customerService.findById(1l); System.out.println(customer.getCustName()); &#125;&#125; 私服 nexus登录 用户名：admin 密码：admin123 Virtual：虚拟仓库 central M1 shadow ：影子仓库，没实际用处 Proxy：代理仓库 Apache Snapshots （阿帕奇 快照）：作为一个非正式仓库，代理跳转到 阿帕奇 的一个仓库 Central ：代理跳转到 阿帕奇中央仓库 Hosted：宿主仓库，本地仓库 3rd party：其他公司自己开发的工程 Releases：自己做的工程是 Release 会提交到此处 Snapshots：自己做的工程属性 是 Snapshots 时，提交到私服时会自动放到此处 group public Respositories：不知道是 release 还是 snaphots 则从此处下载工程 Q&amp;AQ:Field ‘id’ doesn’t have a default value 错误提示。A:删除原本的数据库，让其自动创建 Q:java.lang.NoClassDefFoundError: Could not initialize class com.itheima.utils.HibernateUtilsA：参考：https://www.cnblogs.com/chenjfblog/p/7904024.html 配置了 xml 与 注释，删掉其中一个就好了 Q:修改 jsp 内容后页面标签属性 href 不变化因为删除了原先的 menu.htm 页面，没有将标签的 src 属性 变成新的 menu.jsp，修改 href 无效，重启 idea ，再发布网页会显示 网页 menu 部分 404 异常： HTTP Status 404 – Not Found Q:org.hibernate.HibernateException: No CurrentSessionContext configured!解决的办法就是根据需求在hibernate.cfg.xml文件中加上 &lt;property name=&quot;hibernate.current_session_context_class&quot;&gt;thread&lt;/property&gt; 或 &lt;property name=&quot;hibernate.current_session_context_class&quot;&gt;jta&lt;/property&gt; 添加第一种报错： 1org.hibernate.HibernateException: createCriteria is not valid without active transaction 将 thread 改为 jta 参考：https://blog.csdn.net/yinjian520/article/details/8666695 修改后出现问题： 1org.hibernate.HibernateException: No TransactionManagerLookup specified 将 service 中的 openSession 改为 getCurrentSession 参考：https://blog.csdn.net/xlgen157387/article/details/39801967 出错原因：需要把两个方法中用的sesiion一致，因为混用了所以报错， 要么同时写session=HibernateSessionFactory.getSession()来获取session 然后hibernate中配置为 jta 要不就是用session=HibernateSessionFactory.getSessionFactory().getCurrentSession();来获取session 然后hibernate中的配置为：thread 出处：https://blog.csdn.net/tarataotao/article/details/9376693 Q:配置文件报错：不允许有匹配 “[xX][mM][lL]” 的处理指令目标。A: 规范 XML格式 &lt;?xml version=”1.0” encoding=”UTF-8”?&gt; 必须是XML文件的第一个元素且前面不能空格。 参考：https://blog.csdn.net/niubaofeng2011/article/details/39007693 Q:IDEA DTD 文件引入报错错误信息：URI is not registered (Settings | Languages &amp; Frameworks | Schemas and DTD IDEA解决URI is not registered (Settings | Languages &amp; Frameworks | Schemas and DTD Q:idea 的 tomcat 不能正常关闭问题报错： org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [ROOT] appears to have started a thread named [pool-2-thread-1] but has failed to stop it. This is very likely to create a memory leak. Stack trace of thread: sun.misc.Unsafe.park A: https://stackoverflow.com/questions/28105803/tomcat8-memory-leak Q:Error:(2, 17) java: 程序包org.junit不存在A:导入 com.springsource.org.junit-4.7.0.jar 的 junit jar 包即可 Q: bean 重复配置org.springframework.beans.factory.parsing.BeanDefinitionParsingException: Configuration problem: Bean name ‘user’ is already used in this elementOffending resource: class path resource [applicationContext.xml] A: 在 Spring 配置文件重复配置相同 name 属性的 bean 会产生错误 Q:NullPointerExceptionjava.lang.NullPointerException at cn.itheima.service.impl.UserServiceImpl.login(UserServiceImpl.java:19) at cn.itheima.web.action.UserAction.login(UserAction.java:16) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source) at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source) at java.lang.reflect.Method.invoke(Unknown Source) at spring 容器注入，需要由 spring 创建 UserService 对象，自己创建就会为空 Q:Spring Junit4 @RunWith 为红色A: 在 Module 中 Libraries 中，点击左侧 + 号，选择 java 添加 idea lib 包下的 junit 添加到该项目 Q:程序包org.junit.runner不存在idea 使用 springJunit4 出现问题 : 程序包org.junit.runner不存在 12@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(&quot;classpath:applicationContext.xml&quot;) 程序包org.junit.runner不存在 File -&gt; Project Struct… -&gt; Libraies -&gt; 点击绿色的加号 -&gt; Java -&gt; 找到 IDEA 安装路径下的 Lib 中的junit-4.12 -&gt; 确定就行了，点击OK就出去了 Q:Spring 整合的 Junit4 错误java.lang.NoSuchMethodError: org.springframework.test.context.junit4.SpringJUnit4ClassRunner.runLeaf (Lorg/junit/runners/model/Statement;Lorg/junit/runner/Description;Lorg/junit/runner/notification/RunNotifier;) A:Junit4 包冲突了，删除自己导入 lib 下的 com.springsource.org.junit-4.7.0.jar，在红色的 @Test 上选择第一个修复方法 Q:unnamed spring confirguration files found A:shift + ctrl + alt + s 进入 Project Structure–&gt; modules–&gt;选择未配置 Spring Configuration 的项目–&gt;（如果没有 相应的 spring ,点击左侧 + 号,选择 spring）–&gt;选中需要添加的spring 项目 –&gt; 点击右侧 + 号–&gt; 选择需要的 Spring Application Context xml 文件，点击确认 Facets 表示这个module有什么特征，比如 Web，Spring和Hibernate等； Artifact：项目产生物，主要有jar, war, maven插件 idea facet 及 artifact 理解 Q: Spring 配置 jdbc c3p0 异常org.springframework.jdbc.CannotGetJdbcConnectionException: Could not get JDBC Connection; nested exception is java.sql.SQLException: Connections could not be acquired from the underlying database! A: class 与 url 填反了 参考：以上问题可能有以下原因造成： 1，驱动配置有误：driver=com.mysql.jdbc.Driver2，数据库连接地址有误：url=jdbc:mysql://localhost:3306/test?3useUnicode=true&amp;characterEncoding=utf83，密码或帐号有误：username=root， password=root 4，数据库未启动或无权访问 5，项目未引入对应的驱动jar包mysql-connector-java-5.1.6-bin.jar 6,mysql root没有远程访问的权限，需要增加权限，增加权限的步骤如下：进入mysql数据库：grant all privileges on . to ‘root‘@’%’ identified by ‘root’ with grant option;flush privileges; A:Spring 异常 Junit4，.NoClassDefFoundError: org/hamcrest/SelfDescribingException in thread “main” java.lang.NoClassDefFoundError: org/hamcrest/SelfDescribing Caused by: java.lang.ClassNotFoundException: org.hamcrest.SelfDescribing A: 删除Mudle 里的 Junit4 lib 包，在 @Test 上 alt+enter 选择添加 junit4，再选择第一个选项即可，idea 会自动添加 junit4 与 hamcrest-core 的 jar 包 A: java.lang.IllegalStateException: Failed to load ApplicationContext缺少包 com.springsource.org.aopalliance-1.0.0.jar Caused by: org.springframework.beans.factory.BeanDefinitionStoreException: Unexpected exception parsing XML document from class path resource [applicationContext.xml]; nested exception is java.lang.NoClassDefFoundError: org/aopalliance/intercept/MethodInterceptor Caused by: java.lang.NoClassDefFoundError: org/aopalliance/intercept/MethodInterceptor Caused by: java.lang.ClassNotFoundException: org.aopalliance.intercept.MethodInterceptor Q: 启动 tomcat 报错 xml 错误Error creating bean with name ‘transactionManager’ defined in class path resource [applicationContext.xml]: Cannot resolve reference to bean ‘sessionFactory’ while setting bean property ‘sessionFactory’ A：proerties 文件下参数配置错误，导致无法获得 dataSource,后续无法将 dataSource 注入 sessionFactory， 致使 sessionFactory 无法注入到 transactionManager 核心事务管理器，出现错误 1234567891011121314151617&lt;!--将 dataSource 放入 spring 容器--&gt; &lt;bean name="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;property name="jdbcUrl" value="$&#123;jdbc.jdbcUrl&#125;"&gt;&lt;/property&gt; &lt;property name="driverClass" value="$&#123;jdbc.driverClass&#125;"&gt;&lt;/property&gt; &lt;property name="user" value="$&#123;jdbc.user&#125;"&gt;&lt;/property&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;!--将 SessionFactory 配置到 spring 容器中--&gt; &lt;bean name="sessionFactory" class="org.springframework.orm.hibernate5.LocalSessionFactoryBean"&gt; &lt;!--核心事务管理器--&gt; &lt;bean name="transactionManager" class="org.springframework.orm.hibernate5.HibernateTransactionManager"&gt; &lt;property name="sessionFactory" ref="sessionFactory"&gt;&lt;/property&gt; &lt;/bean&gt; Q:idea 项目配置文件 class 都为红色A: 在 module 中设置项目的 src 路径 Q:配置 MAVEN 运行后出现异常[ERROR] Failed to execute goal org.codehaus.mojo:tomcat-maven-plugin:1.1:run (default-cli): Goal requires a project to execute but there is no POM in this directory (). Please verify you invoked Maven from the correct directory A: 需要在运行文件的 src 同级目录放有 pom.xml 文件，并且内部有相应的配置信息。 需要在 C:\Users\用户名.m2 中放置 配置 maven 的 settings.xml 而不是在 maven 解压目录的 conf 目录下 参考：https://stackoverflow.com/questions/16230666/failed-to-execute-goal-org-codehaus-mojotomcat-maven-plugin1-1deploy-default Q:intellj IDEA 创建 maven 项目无 src 目录问题在自己的 maven 主配置文件 mirrors 下加入 国内阿里云的镜像网站 12345678910111213141516 &lt;mirrors&gt; &lt;!-- 阿里云仓库 --&gt; &lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/repositories/central/&lt;/url&gt; &lt;/mirror&gt; &lt;!-- 中央仓库 --&gt; &lt;mirror&gt; &lt;id&gt;repo&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;Human Readable Name for this Mirror.&lt;/name&gt; &lt;url&gt;http://repo1.maven.org/maven2/&lt;/url&gt; &lt;/mirror&gt;&lt;/mirrors&gt; 参考：https://blog.csdn.net/xiaoke815/article/details/72810976 Q:maven idea 项目 xml 文件中 junit 版本红色A:将版本从 4.11 改成 4.10 或者 4.9 Q:maven jar 包冲突A: maven 的 jsp 与 servlet api 与 tomcat 中的冲突了，在这两个 dependency 中添加 provided` 属性，修改其依赖范围 参考：https://stackoverflow.com/questions/5735957/maven-loads-servlet-api-twice Q: intellj idea 的 jsp 页面无法使用 el 表达式A:在 page 属性中加上 isELIgnored=”false” 属性，使其不要忽略 EL 表达式 1&lt;%@ page contentType="text/html;charset=UTF-8" language="java" isELIgnored="false" %&gt; 参考：https://blog.csdn.net/qq_36921440/article/details/83785588 Q:intellj idea meven install 错误The packaging for this project did not assign a file to the build artifact A:不要使用自带右侧 maven 的 install ，自己在 EditConfiguration 中配置 install Q:分模块运行 web 错误 404HTTP Status 404 - There is no Action mapped for namespace [/] and action name [findById] associated with context path [/ssh].type Status report message There is no Action mapped for namespace [/] and action name [findById] associated with context path [/ssh]. description The requested resource (There is no Action mapped for namespace [/] and action name [findById] associated with context path [/ssh].) is not available. A: 经过查看 target 的输出文件夹，发现 applicationContext.xml 与 struts.xml 文件 都不在 class 目录下 于是查看后发现把 ssh-web 模块的 resources 文件夹放到了src 目录下，需要将其放入 src/main 中 Q: idea 上传到私服错误idea Failed to execute goal org.apache.maven.plugins:maven-deploy-plugin:2.7:deploy Return code is: 401, ReasonPhrase: Unauthorized A:401 是用户密码错误，没有设置好用户名和密码，400是没有访问权限 需要在你的 idea 的配置 xml 下配置 server 属性（C:\Users\用户名\.m2），而不是 maven conf 下的xml https://huangyunbin.iteye.com/blog/1740426 Q:idea 不会自动从私服下载项目模块 jar 包A:因为 idea 默认的 maven 是自带的，需要在 setting Build，Execution，Deployment/Build Tools/Maven 的Maven Home Directory 中选择自己安装的 maven 目录 https://blog.csdn.net/suah01/article/details/64906323 Q:struts2 从 ajax 接收中文字符串乱码问题A:利用 ajax 的 data 项传递参数 data:{&quot;key&quot;,value}， 如果使用 url 后拼接的方式会导致乱码]]></content>
      <categories>
        <category>SSH</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
        <tag>SSH</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Listener_Filter]]></title>
    <url>%2F2018%2F12%2F25%2FListener_Filter%2F</url>
    <content type="text"><![CDATA[监听器 Listener监听器概念监听某个对象的状态变化的组件 事件源：被监听的对象 – 三个域对象 request、session、servletContext 监听器：监听事件源对象 – 事件源对象的状态变化都会触发监听器 – 6+2 注册监听器：将监听器与事件源进行绑定 相应行为：监听器监听到事件源的状态变化时所涉及的功能代码 – 需要编写 监听器分类第一维度：按照被监听对象划分：ServletRequest 域、 HttpSession 域、servletContext 域 第二维度：安装监听的内容分：监听域对象的创建与销毁 监听域对象的属性变化 监听三大域对象的创建与销毁的监听器监听 ServletContext 域的创建与销毁的监听器 ServletContextListener servlet 与的生命周期 何时创建：服务器启动创建 何时销毁：服务器关闭销毁 监听器编写步骤（重点） 编写一个监听器类去实现监听器接口 （6+2 中选） 覆盖监听器的方法 在 web.xml 中进行配置 监听方法 6个监听器 ：ServletContext、HttpSession、ServletRequest 域 + Listener / AttributeListener ServletContextListener 的主要作用 初始化的工作：初始化数据 – 加载数据库驱动、连接池的初始化 加载一些初始化的配置文件 – spring 配置文件 12345//配置 spring 的核心监听器 //ContextLoaderListener implements ServletContextListener 实现了 监听器接口&lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;listener-class&gt;&lt;/listener&gt; 以上配置监听器用来在服务器开启时加载 spring 配置文件 applicationContext.xml 任务调度 – 定时器 Timer、TimerTask httpSession 域的 创建与销毁 监听器，在一个客户端访问时会创建一个 session jsp 页面默认被转换成 sevlet 会自动添加 pageContext.getSession 方法 一般只用来记录页面访问人数 2个监听器：与 session 中的绑定对象相关的监听器（对象感知监听器） 4个状态都是针对 存放到 session 中的对象的 即将绑定到 session 的对象状态： 绑定状态：一个对象被放到 session 中 解绑状态：一个对象被 session 移除 钝化状态：将 session 内存中的对象持久化（序列化）到磁盘 活化状态 绑定与解绑监听器： HttpSessionbindingListener ：是给对象用的，对象自己知道自己被绑或解绑 感知监听器不用配置 xml 面试题：当用户很多时，怎么对服务器进行优化？ 答：把待机很久不动的用户 session （服务器内存）中的内容存到磁盘中，如果用户回来了就将磁盘中的内容返回给用户 钝化与活化监听器：HttpSessionActivationListener 钝化（服务器关闭后）tomcat 文件夹下会有一个 SESSIONS.ser 文件 ，对象需要 实现 Serializable 接口才能真正钝化（序列化）到磁盘，不然会无法活化 服务器正常关闭或启动 实现钝化活化 使用钝化与活化监听器需要在 webContent/META-INF 下配置 context.xml 过滤器 Filter过滤器概念 filter 是对客户端访问资源的过滤，符合要求的放行不符合的不放行，并且可以对目标访问资源前后进行逻辑处理 编写一个过滤器的类实现 Filter 接口 实现接口中尚未实现的方法（着重实现 doFilter 方法） 在 web.xml 中进行配置（主要对过滤哪些资源配置进行配置） 作用：权限控制、公共代码的提取、对 request 和 response 中的方法进行增强（装饰者模式/动态代理） 增强方法：在 filter 中获得 request 与 response 时进行增强再发送给客户端 核心过滤方法 ：doFilter 放行请求：doFilter(resqust,response); doFilter(ServletRequest,ServletResponse){ } doFilter 内部请求是 ServletRequest，所以无法使用一些 HttpServletRequest 的 Api 如 request.getSession()，需要把它强转成子类，servlet 内部的 doGet doPost 方法都是底层源码自动强转过的 HttpServletRequest FilterChian 对象 内部有所有 Filter 的索引与顺序 过滤器的执行顺序看 web.xml 中 配置的先后顺序 异常报错 HTTP Status 500 – Internal Server ErrorTypeException ReportMessage An exception occurred processing JSP page [/index.jsp] at line [27]Description The server encountered an unexpected condition that prevented it from fulfilling the request.Exceptionorg.apache.jasper.JasperException: An exception occurred processing JSP page [/index.jsp] at line [27]24: 鑼冨洿浠庡皬鍒板ぇ page鍩�(pageContext 瀵硅薄)–&gt;request鍩�–&gt;session鍩�–&gt;application鍩�(servletContext)–%&gt;25: &lt;%–&lt;%=pageContext.findAttribute(“name”)%&gt;–%&gt;26: 27: &lt;jsp:include page=”/header.jsp”&gt;&lt;/jsp:include&gt;28:29: 30: Stacktrace:org.apache.jasper.servlet.JspServletWrapper.handleJspException(JspServletWrapper.java:584) org.apache.jasper.servlet.JspServletWrapper.service(JspServletWrapper.java:466) org.apache.jasper.servlet.JspServlet.serviceJspFile(JspServlet.java:386) org.apache.jasper.servlet.JspServlet.service(JspServlet.java:330) javax.servlet.http.HttpServlet.service(HttpServlet.java:742) org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52) Root Causeorg.apache.jasper.JasperException: An exception occurred processing JSP page [/header.jsp] at line [20]17: 娉ㄥ唽18: &lt;/c:if&gt;19: &lt;c:if test=”${user != null}”&gt;20: 娆㈣繋鎮�,${user.username }21: &lt;/c:if&gt;22: 璐墿杞�23: 鎴戠殑璁㈠崟Stacktrace:org.apache.jasper.servlet.JspServletWrapper.handleJspException(JspServletWrapper.java:584) org.apache.jasper.servlet.JspServletWrapper.service(JspServletWrapper.java:481) org.apache.jasper.servlet.JspServlet.serviceJspFile(JspServlet.java:386) org.apache.jasper.servlet.JspServlet.service(JspServlet.java:330) javax.servlet.http.HttpServlet.service(HttpServlet.java:742) org.apache.jasper.runtime.JspRuntimeLibrary.include(JspRuntimeLibrary.java:894) org.apache.jsp.index_jsp._jspService(index_jsp.java:144) org.apache.jasper.runtime.HttpJspBase.service(HttpJspBase.java:70) javax.servlet.http.HttpServlet.service(HttpServlet.java:742) org.apache.jasper.servlet.JspServletWrapper.service(JspServletWrapper.java:443) org.apache.jasper.servlet.JspServlet.serviceJspFile(JspServlet.java:386) org.apache.jasper.servlet.JspServlet.service(JspServlet.java:330) javax.servlet.http.HttpServlet.service(HttpServlet.java:742) org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52) Root Causejavax.el.PropertyNotFoundException: Property [username] not found on type [com.itheima.domain.User] javax.el.BeanELResolver$BeanProperties.get(BeanELResolver.java:260) javax.el.BeanELResolver$BeanProperties.access$300(BeanELResolver.java:212) javax.el.BeanELResolver.property(BeanELResolver.java:347) javax.el.BeanELResolver.getValue(BeanELResolver.java:92) org.apache.jasper.el.JasperELResolver.getValue(JasperELResolver.java:110) org.apache.el.parser.AstValue.getValue(AstValue.java:169) org.apache.el.ValueExpressionImpl.getValue(ValueExpressionImpl.java:184)org.apache.jasper.runtime.PageContextImpl.proprietaryEvaluate(PageContextImpl.java:944) org.apache.jsp.header_jsp._jspx_meth_c_005fif_005f1(header_jsp.java:301) org.apache.jsp.header_jsp._jspService(header_jsp.java:137) org.apache.jasper.runtime.HttpJspBase.service(HttpJspBase.java:70) javax.servlet.http.HttpServlet.service(HttpServlet.java:742) org.apache.jasper.servlet.JspServletWrapper.service(JspServletWrapper.java:443) org.apache.jasper.servlet.JspServlet.serviceJspFile(JspServlet.java:386) org.apache.jasper.servlet.JspServlet.service(JspServlet.java:330) javax.servlet.http.HttpServlet.service(HttpServlet.java:742) org.apache.jasper.runtime.JspRuntimeLibrary.include(JspRuntimeLibrary.java:894) org.apache.jsp.index_jsp._jspService(index_jsp.java:144) org.apache.jasper.runtime.HttpJspBase.service(HttpJspBase.java:70) javax.servlet.http.HttpServlet.service(HttpServlet.java:742) org.apache.jasper.servlet.JspServletWrapper.service(JspServletWrapper.java:443) org.apache.jasper.servlet.JspServlet.serviceJspFile(JspServlet.java:386) org.apache.jasper.servlet.JspServlet.service(JspServlet.java:330) javax.servlet.http.HttpServlet.service(HttpServlet.java:742) org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52) Note The full stack trace of the root cause is available in the server logs. 在 jstl 语句中使用了 javaBean 不存在的属性 过滤器解决 post get 乱码问题在传递 request 之前对 request 的 getParameter 方法进行增强 装饰者模式（包装） 增强类与被增强类实现统一接口 在增强类中传入被增强的类 需要增强的方法重写，不需要增强的方法调用被增强类的 filter 1234567//前处理打开session 事务chain.dofilter(req,resp);//放行-&gt;去处理 servlet，service，dao，jsp//后处理关闭 session 事务 此方式可以让 全部范围内的程序 session 处于打开状态]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaweb core]]></title>
    <url>%2F2018%2F12%2F14%2Fweb20%2F</url>
    <content type="text"><![CDATA[xml&amp;反射DTD 文件 document type definition ：文档类型定义 用于约束（约定/规定）xml 文档的格式 Scheme 文件，后缀名 .xsd 是 DTD 文件的升级类型，功能比 DTD 文件更多 DOM:将文档一次加载到内存形成树形结构，进行解析，解析成一个 Document 对象 SAX：Simple API for XML ：事件驱动的方式，边读边解析 反射JAVA 反射机制指在运行过程中，对于任意一个类，都能知道这个类的所有属性和方法；对于任意一个对象，都能调用它的任意一个方法和属性 使用反射可以在运行时 (在内存中操作代码) 对 .class 类文件中的字节码（机器代码）进行修改。在运行时对类 Class 、构造方法 Constructor、普通方法 Method、字段 field 进行操作。 反射获得 xml 配置文件中的 Servlet 类，对其进行方法调用（点击详细） //1.创建解析器对象 SAXReader saxReader = new SAXReader(); //2.使用解析器加载web.xml文件得到document对象 Document document = saxReader.read(“src/cn/itheima/web/servlet1/web.xml”); //3.获取根元素节点 Element rootElement = document.getRootElement(); //4.根据元素名称获取子元素节点 Element servletElement = rootElement.element(“servlet”); //5.根据元素名称获取servlet-class的文本节点 String servletClass = servletElement.element(“servlet-class”).getText(); //System.out.println(servletClass); //6.通过类全名获取字节码文件 Class clazz = Class.forName(servletClass); //7.创建实例对象 MyServlet1 my = (MyServlet1) clazz.newInstance(); //8.调用实例对象里面的方法 my.init(); my.service(); my.destory(); 读取 src 下文件比较好的方式是用类加载器： bean.xml 在 src 下时 String path = BeanFactory.class.getLorder().getResource(“”).getPath(“xxx.xml”); 读取 web 应用下最好的方式是用 this.getServletContext.getPath(“xxx”); MySql &amp; JDBC注册驱动： 用类加载器加载字符串描述的驱动类，将其加载到内存，该静态代码会自动执行 Class.forName(“com.mysql.jdbc.Driver”); Driver 底层有着方法，静态代码块在类一加载就运行：static{java.sql.DriverManager.registerDriver(new Driver());} 会自动对自己进行注册 获取连接： DriverManeger.getConnection(url,username,password); limit 关键词查询 （limit 2，2） 第一个参数表示查询起始位置（要查第几页-1）*第二个参数 第二个参数表示每页显示的查询个数 例如一共 11条记录，每页3条记录，要查询第四页的内容 limit（（4-1）*3，3）–&gt;limit（9，3） 最后显示10与11两条记录 limit 是左不包含的 Mysql 语句 左连接（LEFT JOIN ） SELECT M.columnname……,N.* columnname….. FROM left_table M LEFT JOIN right_table N ON M.columnname_join=N.columnname_join AND N.columnname=XXX WHERE M.columnname=XXX….. 左连接表示需要查询的数据条件即使不满足左边的表也可以查出左表的所有内容 右连接 SELECT M.columnname……,N.* columnname….. FROM left_table M RIGHT JOIN right_table N ON M. columnname_join=N. columnname_join AND M. columnname=XXX WHERE M.columnname=XXX….. 右连接与左连接相反，就算右表中有不符合查询条件的字段，也会出现在查询结果中。 内连接 只是嵌套的查询语句 Mysql 左连接 右连接 等值连接 JDBC连接池&amp;DBUtils创建连接池时移除、增加操作多使用 LinkList，查询时使用 ArrayList 1private static DataSource dataSource = new ComboPooledDataSource(); 创建连接池时会自动去寻找 c3p0-config.xml DBUtil 是 JDBC 开发简化工具包，封装了 JDBC 操作，可以很多代码 DBUtils 三个核心功能 QueryRunner：提供对 SQL 语句可操作 API QueryRunner(DataSource ds) 提供数据源（连接池），DBUtils 底层自动维护连接 connection update（String sql，Object … param），执行更新程序,参数可以多个 query（String sql，ResultSetHandlerrsh,Object … param)，执行查询（sql语句，处理结果，obj）参数可以多个 ResultSetHandler 结果处理类： BeanHandler ：将结果集中第一条记录封装到指定 javaBean BeanListHandler : 将结果集中每一条记录封装到指定 javaBean，将这些 javaBean 封装到一个 List 集合 ScalarHandler : 用于单数据，例如 select count(*) from 表 的操作（返回表中某一条件的记录数） 会话技术 Cookie&amp;SessionHttp 协议是无状态的，每个客户端访问服务器资源时，服务器并不知道客户端是谁，所以需要会话技术识别客户端 把无状态客户数据存储到服务器就是 session ，存到客户端本地就是 cookie session 域是服务器端为每个客户端创建的私有的内存空间，而 servletContext 服务端只有一个，是公有的 从打开一个浏览器访问一个站点，到关闭这个浏览器的过程称为一次会话（需要把标签页全部关闭才算关闭浏览器）（面试） 域中可以存任何东西，包括对象。 cookie 中不能存对象，只能存字符串，而且不能为中文 设置 Cookie 持久化时间cookie.setMaxAge(int seconds) – 秒 如果不设置 cookie 的持久化时间，cookie 存储在浏览器内存中，浏览器关闭 cookie 信息销毁(会话级别 cookie) 如果设置持久化时间，cookie 会持久化到浏览器的磁盘文件中 设置 Cookie 路径cookie.setPath(“/“); 如果不设置携带路径，则该 cookie 信息会在访问 设置该 cookie 的同级目录文件时携带该 cookie 信息（产生该 cookie 的 web 资源所在的路径） 删除Cookie如果要 删除 Cookie ，则在同路径下设置一个同名 Cookie（只要 key 相同，value 无所谓） 并设置持久化时间为 0 获得Cookie1234567891011Cookie[] cookies = req.getCookies(); for(Cookie cookie : cookies)&#123; //获得 cookie 名称 String cookieName = cookie.getName(); if(cookie!=null)&#123; if(cookieName.equals("name")) &#123;// 如果名称(key)等于 name 则获取其 value 值（zhangsan） String cookieValue = cookie.getValue(); System.out.println(cookieValue); &#125; &#125; 获取上次登陆时间出现网页报错 错误信息 500 HTTP Status 500 – Internal Server ErrorType Exception Report Message An invalid character [32] was present in the Cookie valueDescription The server encountered an unexpected condition that prevented it from fulfilling the request.Exception java.lang.IllegalArgumentException: An invalid character [32] was present in the Cookie value org.apache.tomcat.util.http.Rfc6265CookieProcessor.validateCookieValue(Rfc6265CookieProcessor.java:182)org.apache.tomcat.util.http.Rfc6265CookieProcessor.generateHeader(Rfc6265CookieProcessor.java:115) org.apache.catalina.connector.Response.generateCookieString(Response.java:1019) org.apache.catalina.connector.Response.addCookie(Response.java:967) org.apache.catalina.connector.ResponseFacade.addCookie(ResponseFacade.java:386)com.itheima.cookie.ShowLastAccessTimeServlet.doGet(ShowLastAccessTimeServlet.java:60) javax.servlet.http.HttpServlet.service(HttpServlet.java:635) javax.servlet.http.HttpServlet.service(HttpServlet.java:742) org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52) Note The full stack trace of the root cause is available in the server logs. ​ 错误原因：传入 cookie 的日期设置中出现了空格，An invalid character [32] was present in the Cookie value 32 就是空格的编码 解决：格式化日期时别加入空格 参考：https://blog.csdn.net/allan_liu_/article/details/74990162 Session 技术session 技术是基于 cookie 技术的，session 有一个存储 session 编号的 JSESSIONID，servlet1 得到这个 JSESSIONID 把它返回给客户端，客户端根据这个编号去访问 servlet2 时传递这个编号，从而服务器可以知道这两个 servlet 访问来自一个客户端。coolkie 可以帮助 session 存储 JSESSIONID 此方法根据客户端在服务器有无 session，如果没有则创建一个 session，如有则返回该 session 的引用 HttpSession session = request.getSession(); Session 对象生命周期（面试题）创建：第一次运行 request.getSession() 时 销毁： 服务器（非正常）关闭（如果正常关闭服务器，session 会被监听器从内存钝化到磁盘上，但是这个 session值仍然存在） session 过期/失效（默认30分钟） 在 tomcat web.xml 中配置全局（一般在自己项目的 web.xml 配置，只有自己项目没配才会用 tomcat 的全局设置） 123&lt;session-config&gt; &lt;session-timeout&gt;30&lt;/session-timeout&gt;&lt;/session-config&gt; 问：从何时开始的 30 分钟 session 算过期？ 从不操作服务器端资源开始 30 分钟 手动销毁 session ，session.invalidate(); 面试题：浏览器关闭，session 就销毁了吗？ 不对，session 的销毁方式只有 服务器关闭 跟 客户端一段时间不操作过期 才会销毁，跟客户端关闭与否无关 session 作用范围：默认一次会话中（访问服务器到关闭客户端），如果设置了 session 持久化，则在关闭浏览器后再次打开浏览器访问，还是能根据 JSESESSIONID 访问到原来的 session session 一般不建议存放一些一次性信息，如错误提醒等，使用 request 这种销毁快的存放 登陆后 el 表达式无法获得 session 中的 name 值，页面后台无报错 解决：数据库查询名 跟 UserBean 的 name 不一致，导致查询后返回的 User username 属性值为空，无法再页面显示；并且 el 表达式获取某个值时，若为空，则显示为空，不会报错。 Servlet&amp;JSPServletServlet: Service + let: 运行在服务端的 java 小程序，sun 公司提供的一套接口规范（接口），用来处理客户端请求响应给浏览器动态资源，实质就是 java 代码，放在服务器端，别人可以通过 http 协议访问此代码，通过 java API 动态向客户端输出内容。 servlet 规范三大组件： servlet 技术 filter 技术 – 过滤器 listener 技术 – 监听器 实现步骤： 创建类实现 Servlet 接口 覆盖尚未实现的方法 – 主要是 service 方法 在 web.xml 配置 servlet Serlvet 的 API(生命周期) Servlet 接口中的方法 init （ServletConfig config) 何时执行：servlet 对象创建时执行 ServletConfig ：代表该 Servlet 对象的配置信息 ServletConfig 可以获得 servlet 的 name 、servlet 的初始化参数、servletContext 对象 service（ServletRequest request，ServletResponse response） 何时执行：每次请求都会执行 ServletRequest:代表请求，内部封装的是 http 请求信息 ServletResponse 代表响应，认为内部要封装的是响应的信息 destory() 何时执行：servlet 销毁时执行 Servlet 的生命周期（面试题） Servlet 何时创建 默认第一次访问 Servlet 时创建（Tomcat 等容器自动创建） 为什么说默认？ 可以在 \&lt;servlet> 中配置 \&lt;load-on-start>1-5\&lt;/load-on-start> 数字表优先级，servlet 对象可以在服务器启动时创建 Servlet 何时销毁 因为 Servlet 、request、response 等存在服务器内部（内存），服务器关闭 Servlet 就销毁了 每次访问必然执行的方法 service（ServletRequest req，ServletResponse resp） 方法 问题：对 xxxServlet 进行了10次访问，init(),destory(),service(),doGet(),doPost() 一共执行几次？ request 、response 对象创建几个 init()，1次；destory()，服务器没有关闭， 不执行；service()，10次；request对象创建10个；response创建10个 url 配置错误会出现 404 异常，servlet-class 配置错误会出现 500 异常 \其中的为 servlet 类的配置\&lt;/servlet> \&lt;servlet-mapping> 其中为 serlvet 虚拟路径配置\&lt;/servlet-mapping> \&lt;url-pattern> 配置方式 完全匹配 访问资源与配置资源完全相同才能访问到 /xxx 目录匹配 /虚拟的目录../ 代表任意 扩展名匹配 *.xxxx 目录匹配与扩展名匹配不能混用 缺省的 Servlet 当服务器所有 servlet 与 访问的资源地址不匹配时，缺省的 servlet 负责处理 web 应用中所有的资源响应都是 servlet 提供的，包括静态资源 tomcat 下有一个默认的 缺省 Servlet，当访问静态资源时找不到动态资源，从而去你的 WEB-INF 目录下找静态资源 .html .jsp 等，然后用 wirte（）方法输出页面，如果在自己的 web.xml 配置了缺省 Servlet 则会覆盖 tomcat 的 缺省 Servlet 从而访问不到静态页面，404 异常 欢迎页面：tomcat 配置默认 index.html index.htm index.jsp ServletContext 对象ServletContext 对象代表一个 web 应用的环境（上下文）对象，ServletContext 对象内部封装的是 web 的应用信息 一个 web 应用有几个 servlet / ServletContext 对象：多个 Servlet，一个 ServletContext ServletContext 对象的生命周期？ 创建：该 web 应用被加载（服务器启动 或 服务器启动状态发布 web 引用） 销毁：web 应用被卸载（服务器关闭，移除该 web 应用） 怎么获得 Servlet 对象 Servletconfig.getServletContext(); this.getServletContext(); ServletContext 的作用 获得 web 应用全局的 初始化参数 在 web.xml 中配置初始化参数后，用 context.getInitParameter(“name”) 获得 1234567&lt;context-param&gt; &lt;param-name&gt;name&lt;/param-name&gt; &lt;param-value&gt;com.xxx.xxx&lt;/param-value&gt;&lt;/context-param&gt; 获得 web 应用中任何资源的绝对路径（重点） WEB-INF 下的文件不能通过网址直接访问，可以通过代码访问 String 绝对路径 = ServletContext.getRealPath(“相对路径”); //此相对路径相对 WEB-INF 获取 src（classes）下的资源绝对路径时应使用 tomcat 部署后的 相对路径 String path = ServletContext.getRealPath(“WEB-INF/classes/c.txt”); 此外在读取src（classes）下的资源时可以使用类加载器方法 String path = ContextServlet.class.getClassLoader().getResource(“c.txt”).getPath();//此相对路径相对于 部署在 tomcat 服务器后的 classes 路径 idea 下 tomcat java 包 class 文件导出路径：${user.home}/.IntelliJIdea/system/tomcat 可以根据 idea 中配置 tomcat （Project Structure）Artifact 中路径一致， war 包专门用来传输服务器项目 war模式这种可以称之为是发布模式，看名字也知道，这是先打包war包，再发布； war exploded模式是直接把文件夹，jsp页面，classes等等移到Tomcat部署文件夹里面，进行加载部署。因此这种方式支持热部署，一般在开发的时候也是用这种方式。 参考：https://blog.csdn.net/qq_34328582/article/details/77932507 参考：https://blog.csdn.net/weixin_36210698/article/details/72585429 ServletContext 是一个域对象（重点） 什么是域对象？什么是域？ 域就是区域 存储数据的区域就是域对象 ServletContext 域对象的作用范围：整个 web 应用（所有 web 资源都可以随意向 servletContext 域中存取数据，数据可共享） 域对象的通用方法： setAttribute(String name,Object obj); getAttribute(String name); removeAttribute(String name); Linux 下的项目部署：idea 导出 war 包，将 war 包放到 linux 的 tomcat/web 目录下 Shift+Ctrl+Alt+S —&gt; 选择 Artifacts —&gt; 选择中间栏的绿色 + 号，选择 WebApplication:Archive /empty（empty 生成的是 war 包，exploded 生成的是 文件夹类型的热部署模式）—&gt; 点击右边的绿色 + 号，选择 Directory Content —&gt;上方可 Name 栏修改 war 包名称，OutPut Directory 修改 war包输出路径 —&gt; 现已完成除 classes 文件夹的 war 包配置 —&gt; 选中 war 包，点击上方黄色带红星的文件夹图标 创建 WEB-INF 和其 子目录 classes —&gt; 选中 classes 目录，点击上方（右侧）绿色 + 号，选择 Module Output —&gt; 全部确定后 在 build 中点击 BuildArtifacts，会将 war 包导出到刚才配置的路径下 参考： war 和 war exploded（热部署模式）的区别 解决 war 包没有 classes 文件问题 idea 导出 jar 包 mysql 导出对应的 SQL 到 linux 的数据库中 HTTP将应用放到 web 应用服务器，外界就可以通过 http 协议访问到该应用 http 协议 超文本传输协议 协议版本：HTTP/1.1 HTTP/1.0，发送请求，创建一次连接，获得一个web资源，连接断开。 HTTP/1.1，发送请求，创建一次连接，获得多个web资源，保持连接。 请求头： If-Modified-Since:浏览器通知服务器，本地缓存的最后变更时间。与另一个响应头组合控制浏览器页面的缓存。 响应头： Last-Modified:服务器通知浏览器，文件的最后修改时间。与If-Modified-Since一起使用。如果比较两个时间不一致，则返回 200，重新访问；如果比较两个时间一致，则返回 304，用本地缓存，不再访问服务器 404 ：服务器找到了，但是没有该资源 Request URL: https://www.google.com/search?q=111&amp;ie=UTF-8 Request Method: GET Status Code: 200 Remote Address: 106.187.52.155:443 Referrer Policy: no-referrer-when-downgrade Web 应用服务器TomcatB/S(Browser/Server):浏览器 服务器 系统 — 网站 C/S(Client/Server):客户端 服务器 系统 — 客户端（游戏客户端、QQ客户端） web 应用服务器 供向外部发布web资源的服务器软件 weblogic：oracle公司的大型收费web服务器 支持全部javaEE规范 websphere：IBM公司的大型收费web服务器 支持全部的javaEE规范 Tomcat：Apache开源组织下的 开源免费的中小型的web应用服务器 支持 javaEE 中的 servlet 和 jsp规范 如果没有配置JAVA_HOME环境变量，在双击“startup.bat”文件运行tomcat 时，将一闪立即关闭。且必须配置正确，及JAVA_HOME指向JDK的安装目录 端口冲突 java.net.BindException: Address already in use: JVM_Bind &lt;null>:8080 修改Tomcat/conf/server.xml 80 端口是 http 默认端口，访问 localhost:80/ 后 80 不会显示 web 资源 存在于 web 应用服务器的资源 例如：css、html、css、js、图片、视频、音乐等 静态资源：指web页面中供人们浏览的数据始终是不变。比如：HTML、CSS、 JS、图片、多媒体。 动态资源（java 代码等）：指web页面中供人们浏览的数据是由程序产生的，不同时间点访问 web页面看到的内容各不相同。比如：JSP/Servlet、ASP、PHP javaWEB领域：动态资源认为通过java代码去动态生成 html WEB-INF 是受保护的，外界不能直接访问 httpServletResponse通过 response 设置响应行：response.setStatus(int sc); 通过 response 设置响应头 add(set)Header(String name,String value); add(set)IntHeader(String name,int value); add(set)DateHeader(String name,Date value); add 表示添加，set 表示设置（相同 name 的新 value 会覆盖旧的） Response 重定向重定向状态码：302 重定向响应头：location 重定向指客户端向 Servlet1 请求一个资源，Servlet1 没有这个资源，便告诉客户端去访问 Servlet2 ，然后 Servlet2 返回资源给客户端（客户端地址会发生变化，第一次访问 Servlet1 是客户端主动访问，重定向则是 tomcat 等服务器端自动跳转的） 设置状态码302：response.setStatus(302); 设置响应头 location：response.setHeader(“location”,”url”); 以上 2 个方法可以封装成一个重定向方法 response.sendRedirect(“url”); 延时重定向方法：response.setHeader(“refleash”,”second;url”);response.setHeader(“名称”,”几秒后跳转;地址”)； 通过 response 设置响应体通过 response.getWriter().write(“xxx”); 将数据写入 response 的缓存区，然后 tomcat 的response 从缓存区获得数据，在引擎处将其拼接成 http 响应传给客户端 response 解决乱码问题 在数据写入 response 缓存区前设置，让其通过 response 查询 utf-8 的码表（设置 response 查询码表） response.setCharacterEncoding(“utf-8”); 告知客户端用 utf-8 解码（通过一个头 Context-type 告知客户端使用何种码表） “text/html”告知客户端文本是 html 类型，charset=utf-8 编码是 uft-8 response.setHeader(“Content-Type”,”text/html;charset=utf-8”); 以上方法可以封装为 response.setContentType(“text/html;charset=utf-8”); 文件下载文件下载就是服务器端到客户端的文件拷贝 什么情况下文件会下载？ 浏览器不能解析的文件会下载 什么情况下需要编写文件下载代码？ 理论上，浏览器可以解析的文件需要编写下载代码 实际开发中，只要是下载的文件都编写文件下载代码 response 获得的流不需要主动关，tomcat 容器会帮助我们关闭 getWriter() 与 getOutPutStream() 不能同时调用, 如果同时调用则会报 500 异常: getOutPutStream() / getWriter() has been called for this response window.onload 的匿名函数内部的函数属于局部私有函数，外部无法访问，所以 onclick 点击事件的函数不能放在 window.onload 内部 window.onload = function(){ ​ function(){} } HttpServletRequest只有 form 表单提交，并且提交方式为 post 时才是 post 提交，请求体中有数据，其他方式都是 get 提交，请求体为空，数据在请求行 通过 request 获得请求行request.getMethod(); – 获得请求方法 – get、post request.getRequestURI(); – 一般指所有路径 – /项目名/应用名 request.getRequestURL(); – 一般指 web 的路径 – http:localhost:8080/项目名/应用名 – 会带上网络协议,多个主机名和主机端口 request.getContextPath(); – 指上下文路径（web 应用名称） request.getQueryString(); – 获得请求行后的数据字符串，如果为 post 提交则为 null request 可以获得客户机（客户端） 的一些信息 request.getRemoteAddr() – 获得访问客户端的 ip 地址 通过 request 获得请求头request.getHeader(“”);– 获得指定的头 request.getHeader(“referer”); 获得请求来源，如 http://localhost:8080/web/xxx.html 再利用 startWith() 函数判断是否以自己的网站为开头，判断是否盗链 通过 request 获得请求体获得单个表单值 String request.getParameter(“”); 获得多个表单的值 String [] request.getParameterValues(); 获得所有请求参数名称(没用) Enmueration getParameterNames(); 获得所有参数 封装到一个 Map&lt;String,String[]&gt; Map&lt;String,String[]&gt; getParameterMap(); post、get 方式提交，以上方法通用 request 其他功能request 是一个域对象 请求重定向（response.sendRedirect(); 服务器外部行为，需要客户端二次请求访问不同 servlet，地址会变） 请求转发 服务器内部行为，只有一次请求，servlet1 没有资源自己找 servlet2 ,把请求（request）转发给servlet2要资源，servlet2 返回给 客户端，地址不会发生变化 获得请求转发器， path 是转发地址 RequestDispatcher getRequestDispatcher(String path) 请求转发是在一次请求中，总计访问服务器一次，所以地址还会带有 web 根目录，不需要再添加 request.getContextPath()，来补全地址，重定向则需要 通过转发器对象转发 requestDispatcher.forward(ServletRequest,ServletResponse)–转发的数据在不同 servlet 就取不到域中的值了 请求转发是服务器内部行为，整个请求在 web 工程内部，可以直接写 /servlet2 相对路径，不用加工程名（服务器端地址，服务器内部的叫服务器端地址，不用写 web 应用名称）请求转发等 客户端去访问的叫客户端地址，服务器外部的地址，需要加上 web 应用名称：重定向、直接输入地址等 request 的域范围在一次请求中，每次访问（请求）都会创建一个新的 request 跟 response dispatcher.forward(request,response); 转发 request 不论多少次都算一个请求（虽然都是不同对象，但是 request 内部的值是相同的） 转发性能优于重定向，重定向可以访问外部网站，转发只能访问内部的资源 request 在访问时创建，响应结束销毁，作用域一次请求 存在域中的数据都是 Object 类型的，getAttribute 获得的数据也是 Object，但若知道原来存进去的数据类型，取出来后可以进行强转 setAttribute(“string”,”object”); Object getAttribute(“string”); 解决 request 乱码问题获得页面数据乱码过程： 张三 —&gt; 页面进行 utf-8 编码 —&gt; request 获取数据进行 ios8859-1 解码（默认解码方式）—&gt; 乱码 解决乱码过程： 乱码 —&gt; 使用 ios8859 编码 —&gt; 使用 utf-8 解码 —&gt; 张三 编码方式：str.getByte(“ios8859-1”); 解码方式：new String(bytes,”utf-8”); 将编码和解码方式合并：new String(str.getByte(“iso8859-1”),”utf-8”); 以上方式可以解决 get 和 post 方式提交表单，但是需要对一个对象中每个字段进行编解码，如果在 Map 中的数据还需要在 for 循环中编解码。 但是 post 提交可以用更简便的 request.setCharacterEncoding(“utf-8”); 使用这种方式，只需要写一条，所有的字段都可以解决乱码 request.getParameter(); filter 配置 request 解决乱码问题参考：https://www.cnblogs.com/yyhl/p/9212301.html tomcat 8.5 等服务器 使用了过滤器配置 parameter = new String(parameter.getBytes(“iso8859-1”),”UTF-8”); 会乱码，因为 parmeter 获取到时已是中文，二次编解码会乱码 重定向是客户端重新访问一个 servlet ，属于客户端地址，所以重定向地址不应该固定,用 request 获得上下文路径（web 项目的路径） response.sendRedirect(request.getContextPath”/web/xxx.jsp”); BeanUtils 的方法Map&lt;String,String[]&gt; properties = request.getParameterMap(); User user = new User(); BeanUtils.populate(user,properties); 工作原理：将 map 中的数据根据 key 与实体的属性对应关系封装 只要 key 中的属性与实体的属性名字相同，就自动封装到实体 JSP JAVA Server Page：是在 html 页面写入 java 代码，本质是一个 servlet ，作为简化的 servlet 而发明，擅长写页面，不擅长写 java 代码 在 java 代码中写入 html 页面，擅长写 java 代码，但是写页面比较繁琐，从而诞生了 JSP JSP 运行原理jsp 在第一次访问时（或被修改后）会被 web 容器（tomcat）翻译成 servlet （helloServlet.jsp–&gt;helloServlet_jsp.java）然后编译运行 被翻译后的文件在 tomcat 目录的 work 文件夹下 JSP 的 page 指令12&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt; language=&quot;java&quot; 设置 JSP 插入语言，可以不写 contentType=&quot;text/html; charset=UTF-8&quot; JSP 页面上的 contentType 在编译为 servlet 后会变成 response.setContentType(“text/html”;charset=”UTF-8”); 跟 servlet 中解决网页乱码问题的方法一致，可以用来设置 response 中缓冲区的编码，并知道页面解析时的编码 可以被包含在 pageEncoding 内 pageEncoding=&quot;UTF-8&quot; JSP 文件本身的编码格式 isErrorPage/errorPage: 用来处理服务器端错误 （500错误），无法处理 400 找不到页面错误 404 错误用使用 web.xml 下配置应用的全局错误页面 1234&lt;error-page&gt; &lt;error-code&gt;404&lt;/error-code&gt; &lt;location&gt;/error.jsp&lt;/location&gt;&lt;/error-page&gt; JSP 的 include 指令 &lt;%@ include file=&quot;header.jsp&quot;%&gt; 可以引入其他的 JSP 页面 开发时可以先写页面头跟尾，在重复引用即可 JSP 的 taglib 指令 &lt;%@ taglib uri=&quot;&quot; prefix=&quot;c&quot;%&gt; &lt;c:if&gt; &lt;c:if&gt; prefix:用来标记一个标签库，使用该标签库时就使用该标记 一般用来引入 jstl 标签库/struts2 标签库 JSP 九大隐式对象4大域： page 域 ：pageContext：当前 JSP 页面范围可见（A页面转发到B页面也无法取到） request 域 ：一次请求（不包括返回） session 域 ：一次会话 application 域 ：servletContext 的域 （整个 web 应用） out：输出类型 JspWriter out 作用：向客户端输出内容，out.write(); 直接在 html 页面写数据、使用 &lt;%out.write()%&gt;以及&lt;%=&quot;xxx&quot;&gt;都会在servlet 转换成 out.write(“”); 并将数据放在 out 的缓冲区，out 缓冲区默认大小 8k 可以在&lt;%@ page buffer=&quot;0kb&quot;%&gt;设置关闭 out 缓冲区，从而使用 response 使用&lt;%response.getWriter.write()%&gt;则把数据放在 response 缓冲区，tomcat 默认从 response 获取数据，所以加载 response 数据会快一些，之后会将 out 缓冲区数据放到 response 缓冲区 pageContext：可以向不同域设置内容 1234567&lt;%request.setAttribute("name","zhangsan");pageContext.setAttribute("name","sunba");pageContext.setAttribute("name","lisi",pageContext.REQUEST_SCOPE);pageContext.setAttribute("name","wangwu",pageContext.SESSION_SCOPE);pageContext.setAttribute("name","tianqi",pageContext.APPLICATION_SCOPE);%&gt; 1234 &lt;%--findAttribute 从小到大搜索域范围中的 name 范围从小到大 page域(pageContext 对象)--&gt;request域--&gt;session域--&gt;application域(servletContext)--%&gt;&lt;%=pageContext.findAttribute("name")%&gt; JSP 标签（动作）include1.jsp 与 include2.jsp 静态包含&lt;%@include file=&quot;&quot;%&gt; 将 include2 的页面拷贝到 include1.jsp，再翻译成 include1_jsp.java 静态包含最终有一个文件 动态包含&lt;jsp:include page=&quot;&quot; 将 include1.jsp 翻译成 include1_jsp.java 编译运行后 发现其中的 include(request,response,”include2.jsp”,out,false); 再回去找 include2.jsp 将 include2.jsp 翻译成 include2_jsp.java 再编译运行 动态包含有两个文件 &lt;jsp:forward page=&quot;/forward2.jsp&quot;&gt;&lt;jsp:forward&gt; 请求转发，跟 request.getRequestDispatcher(“/forward2.jsp”).forward(request,response); 一致 将请求从 forward1.jsp 转发到 forward2.jsp 网址还是 forward1.jsp 内容显示 forward2.jsp el 表达式防止 jsp 中嵌入过多 java 代码，从而使用 el 表达式从域中取数据，逻辑判断用 JSTL 从而代替 java 代码 el 从域中取出数据（最重要的 el 功能） 全域查找： 各个域查找： ${requestScope.key }; ${sessionScope.key }; ${applicationScope.key }; 全域查找： ${key}; 底层是 application.findAttribute(); 方法，依次从 pageContext 域，request 域，session 域，application 域中获取属性，在某个域中获取到了则不再往后找 el 表达式没有内置 八大对象，需要用 pageContext 获取 pageContext 功能跟 jsp 类似，能获取八大对象 ${pageContext.request } ${pageContext.request.contextPath } 等于 request.getContextPath(); 常用于重定向 response.sendRedirect(request.getContextPath()+”/product/xxx.jsp”); 用来获取 web 应用名称，通常用于拼接重定向目录 防止 web 应用名称修改后项目无法使用 如： &lt; form action=”${pageContext.request.contextPath }/xxx/xxx.jsp” method=”post”&gt; 拼接的是访问地址 http://localhost:8080/admin/home.jsp 8080 后，/admin 前的这一段地址，在 ieda 修改这段地址的方法是在 tomcat 设置中 Deployment 栏 Application context 栏修改 客户端地址（一般 src 中获取外部链接，插入外来页、导入 css 包、获取图片等都是客户端地址）需要加上 web 应用名称，这样就是绝对地址 JSTL 技术1&lt;%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c"%&gt; &lt;c:if test=&quot;${1=1} &quot;&gt;&lt;c:if&gt; 当 test 中返回为 true 才会进入体内 模拟普通 for 循环 for(i=0;i&lt;5;i++){ } &lt;c:forEach begin=&quot;0&quot; end=&quot;5&quot; var=&quot;i&quot;&gt;&lt;c:forEach&gt; 从 0 开始到 5 ，把每次循环的值赋给 i 模拟增强 for 循环 for(Product product : productList){ } 往 items 中放集合需要借助 el 表达式 &lt;c:forEach items=&quot;${productList }&quot; var=&quot;product&quot;&gt;${product.pname}&lt;c:forEach&gt; 循环取出 productList 集合中每项的 product 的 pname 属性 var 中的每一个数据都是临时存放在在 page 域中，循环过程中被下一个数据所覆盖 el 表达式中可以有空格，但表达式与冒号间不能有空格 “${productList} “(错误) forEach 中的 varStatus count 是从 1 开始循环计数的 index 从 0 开始 如果 items 中没有加 ${} 直接取值会报 Caused by: javax.el.PropertyNotFoundException: Property [oid] not found on type [java.lang.String] 异常 123&lt;c:forEach items=&quot;$&#123;orderList &#125;&quot; var=&quot;order&quot; varStatus=&quot;vs&quot;&gt;$&#123;vs.count&#125;$&#123;vs.index&#125; javaee 开发模式1.模式是开发过程中总结出的“套路”，约定俗成的设计模式 2.javaEE 的模式 model1：jsp+javaBean：随着业务繁琐，导致 jsp 页面混乱 model2：jsp+servlet+javaBean：开发中使用各个技术擅长的方面 mvc：– web开发模式 M：model-模型：javaBean：封装数据 V： view-视图：Jsp：单纯页面显示 C：Controller-控制器：Servlet：获取数据-对数据封装-传递数据数据-指派显示页面 javaEE 的三层架构：–javaEE独有web层：与客户端交互：收集页面数据、封装数据、传递数据、指定响应 jsp 页面 service层：复杂业务处理：逻辑业务代码编写 dao层：与数据库交互：数据库访问代码 开发时体现在包结构 web 层的作用 接受客户端表单数据 封装散装数据成实体 bean，发送数据到 service 层 vo：value object 用来专门传递值，可以专门把 实体 bean 中不存在的判断条件封装一个新的 vo 对象 例如condition 条件对象 接受 service 层返回的数据，并指定跳转页面 service 层作用 接受 web 层传来的 bean 对象，并将其传给 dao 层 接受 dao 层返回的查询数据，将其返回给 web 层 dao 层作用 接受 service bean 对象，查询数据库数据 将查询到的数据返回给 service 层 事务一件事情有 n 个组成单元，要不这 n 个组成单元同时成功，要不就同时失败，就是将 n 个组成单元放到一个事务中 Mysql 事务mysql 有默认的事务：一条 sql 语句就是一个事务，默认开启事务并提交事务 手动 mysql 事务： 显示开启一个事务： start transaction ：开启事务后所有 sql 语句不修改数据库，但保存在一个日志中，可查询 事务提交：commit 表示开启事务到事务提交内所有 sql 语句有效，并更新数据库 事务的回滚：rollback 表示事务回滚，总事务开启到事务回滚，中间所有 sql 操作无效，不更新数据库 JDBC 事务默认自动事务，执行 SQL 语句：executeUpdate（），每执行一次 executeUpdate 代表事务自动提交 jdbc 开启手动事务： 开启事务：conn.setAutoCommit(false); 提交事务：conn.commit(); 回滚事务：conn.rollback(); 控制事务的 connection 必须是同一个，执行 sql 的 connection 与控制事务的 connection 必须是同一个，才能控制事务 DBUtil 事务操作DBUtil 事务控制也是通过 JDBC （进行了封装） QueryRunner runner = new QueryRunner(DataSource datasource); DateSource 会自动寻找 xml 中的数据库连接配置，从连接池中随机获取一个 Connection，随机的 conn 无法控制事务 有参构造将数据源（连接池）作为参数传入 QueryRunner，QueryRunner 会从连接池中获得一个数据库连接资源操作数据库，直接使用无 Connection 参数的方法即可操作数据库 如果要进行事务控制则使用无参 QueryRunner 构造,从而自己再方法体中获取一个 conn，利用确定的 conn 进行事务控制 12345678910QueryRunner runner = new QueryRunner(）&#123; //用 JDBC 的方式获得一个 conn Connection conn = DataSource.getConnection(); //用 conn 开启事务 conn.setAutoCommit(false); runner.update(conn,sql); //提交事务或回滚 conn.commit();&#125; 如果用 SQLException 无法 catch 到 1/0 异常，网页会产生如下异常，而且事务也无法控制住会丢失金额 错误信息： Type Exception Report（点击详细信息） Type Exception ReportMessage / by zero Description The server encountered an unexpected condition that prevented it from fulfilling the request.Exception java.lang.ArithmeticException: / by zero com.itheima.service.TransferService.transferMoney(TransferService.java:21) com.itheima.web.TransferServlet.doGet(TransferServlet.java:24) com.itheima.web.TransferServlet.doPost(TransferServlet.java:12) javax.servlet.http.HttpServlet.service(HttpServlet.java:661) javax.servlet.http.HttpServlet.service(HttpServlet.java:742) org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52) Note The full stack trace of the root cause is available in the server logs. 代码案例：DBUtilsDemo 公司接口：根据客户给出的参数从数据库查询出相关信息返回一个集合 ThreadLocal ：javaEE三层架构间都是一个线程执行方法，ThreadLocal 底层是一个 Map，key 都为 Thread-1，只存储 value，应用：通过线程绑定方式传递参数（Connection） 事务的特性 面试题 （概念问题）缩写（ACID） 原子性（Atomicity)原子性指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生 一致性（Consistency）一个事务中，事务前后的完整性必须保持一致 隔离性（Isolation）多个事务间的关系，隔离性指多用户并发访问数据库时，一个用户的事务不能被其他用户的事务所干扰，多个并发事务之间数据要相互隔离（多个用户访问时每个用户都会有一个独立的ThreadLocal，那么每个 ThreadLocal 中存放的 Connection 也是不同的，可以保证每个 conn 控制一个事务） 持久性（Durability）持久性指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即时数据库发生故障也不会对其有任何影响 事务并发访问问题（由事务的隔离性引起） 脏读：B 事务读取到了 A 事务尚未提交的数据 – 需要 B 事务读取 A 事务已提交的数据 例：A 向 B 转账，B 读到了 A 未提交的转账记录，然后 A 将事务回滚，钱仍在 A 处 不可重复读：一个事务中 两次读取的事务不一致 – 需求一个事务中多次读取时数据是一致的 –update 例：在你开启事务后，你读取了自己银行卡的金额，发现有 5000 余额，此时你老婆刷走了 5000 块，你在这个事务中读取金额仍然还是显示 5000 余额，只有你关闭了这个事务，再次开启一个事务查询时才知道你已经是个穷鬼了 幻读/虚读：一个事务中 两次读取数据的数量不一致 – 要求在一个事务多次读取数据的数量是一致的 – insert delete 例：与不可重复读类似，在一次事务中，你读取自己银行卡的交易记录，一共有 4 条，此时你老婆刷了 5000 那一笔钱，你在这个事务中再次查询也无法看到这次消费，需要再开一个事务才能查询到 事务的隔离级别 read uncommited：读取尚未提交的数据–无法解决任何问题 read commited：读取已提交的数据–可以解决脏读 – oracle 默认 repeatable read：重复读取–可以解决脏读和不可重复读–mysql 默认 serializable：串行化–可以解决 脏读 不可重复读 和 虚读–相当于锁表，性能过低不使用 注解@override 帮助开发人员检查覆盖父类方法是否正确–给编译器用 @SuppressWarning(“rawtype”) List list = new ArrayList(); 压制警告（忽略类型安全），压制警告括号内可以为数组，表示压制多个警告，也可以为 “all” 压制所有警告 @Deprecated 标注过时方法 元注解修饰注解的注解，在注解类上使用，用来限制定义的注解的特性 @Target({TYPE,METHOD…,PARAMETER}) 表示该注解可以用于哪些东西上 TYPE:可以用于类/接口上 METHOD：可以用于方法上 FIELD：字段上能用 java 代码运行过程： demo.java(源码级别) —&gt; 经过编译器 —&gt; demo.class(字节码级别) —&gt; 经过类加载器 —&gt;Class(字节码对象，运行时级别) @Retention(RetentionPolity.RUNTIME) 运行可见级别 SOURCE：源码级别可见 CLASS：字节码文件级别 RUNTIME：运行时级别 Junit4 idea 测试设置 动态代理1234567//反射获得方法Method method = clazz.getMethod(method,req,resp)xxx方法method.invoke()xxx方法 在方法执行前后进行一些操作，就是面向切面编程 获得动态代理对象(点击详细) //获得动态的代理对象—-在运行时 在内存中动态的为Target创建一个虚拟的代理对象 //objProxy是代理对象 根据参数确定到底是谁的代理对象TargetInterface objProxy = (TargetInterface) Proxy.newProxyInstance( Target.class.getClassLoader(), //与目标对象相同的类加载器 new Class[]{TargetInterface.class}, newInvocationHandler() { //invoke 代表的是执行代理对象的方法 @Override //method：代表目标对象的方法字节码对象 //args:代表目标对象的响应的方法的参数 public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { System.out.println(“目标方法前的逻辑”); //执行目标对象的方法 Object invoke = method.invoke(new Target(), args); System.out.println(“目标方法后的逻辑”); return invoke; } }); Q&amp;AQ: servlet 的转发页面空白无显示1request.getRequestDispatcher("admin/product/list.jsp").forward(request,response); A: 如把代码写在 doGet 中需要在 doPost 中进行 doGet 覆盖，或把代码写在 doPost 中，在 doGet 进行 doPost 覆盖 Q:在 servlet 设置断点无法进断点，后台、网页无报错A:如果无法进入断点说明问题在于 页面， 参数无法传递到后台 可能的错误有：json 参数传递语句错误、JQuery 的 ajax 语句 $.post(); 写成 $post.{}; 等 Q:java.lang.NoSuchMethodExceptionA: 如果在整合 servlet 时没有将内部方法的 protect 变成 public 则会出现此问题 Q:java.io.FileNotFoundException: .\xx\xx (拒绝访问。)A: 一般这种情况是访问的是一个文件目录而不是文件 参考：https://blog.csdn.net/w405722907/article/details/78610485 Q:Data truncation: Incorrect datetime value: ‘’A: 存入的 Date 与数据库 Date 格式不符，setDate() 前先进行 Date 格式化： 12345678910SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;); //SimpleDateFormat中的format方法可以 //把Date型的字符串转换成特定格式的String类型 String format = simpleDateFormat.format(new Date()); //SimpleDateFormat中的parse方法可以 //把String型的字符串转换成特定格式的date类型 Date parse = simpleDateFormat.parse(format); //将转换格式的 Date 存入 product product.setPdate(parse); Q:表单中 循环显示,只显示最后一组 tr 的内容，且标题 tr 项不显示 A: 标题 tr 项写错内容，与数据的 项不一致 Tips:一般没有 request 域数据传递使用 重定向 response.sendRedirect(request.getContextPath());（后台地址获取直接 request.getContextPath()） 有 request 域传递数据的使用 请求转发request.getRequestDispatcher(“admin/product/list.jsp”).forward(request,response+“/admin/product/list.jsp”); 如果在注解中配置了 urlPatterns 地址跟 重定向 response.sendRedrest(path); 的地址相同，则会出现死循环，网页提示重定向次数过多，如果提交了表单， 数据库会出现多个空白数据，需要进行空表单验证 12345//获取表单数据Map&lt;String, String[]&gt; properties = request.getParameterMap();//封装数据Product product = new Product（）；BeanUtils.populate(product,properties); 此方法会将表单提交的属性根据 name 值 与 Bean 的属性名 对应起来，然后将表单提交的属性封装成一个 Bean a 标签有自己内置的点击事件，如果 a 标签有 href 属性，在点击后会自动跳转到页面头 阻止事件传播： # 代表本页面 &lt;a href=&quot;#&quot; onclick=&quot;delProduct()&quot;&gt;&lt;a/&gt; 将 href 中内容改为 javascript:void(0); &lt;a href=&quot;javascript:void(0);&quot; onclick=&quot;delProduct()&quot;&gt;&lt;a/&gt; 可以防止点击 a 标签后默认样式的 href 无任何行为 123456789&lt;select name="cid"&gt; &lt;c:forEach items="$&#123;categoryList &#125;" var="category"&gt; &lt;option value="$&#123;category.cid &#125;"&gt; $&#123;category.cname &#125; &lt;/option&gt; &lt;/c:forEach&gt;&lt;/select&gt; items 的值与 servlet 中 setAttribute 的值名相同，var 为循环 items 的值后单个的值 不让用户看到，但是后台需要某个属性时，使用隐藏域传递数据 &lt;input type=&quot;hidden&quot; name=&quot;pid&quot; value=&quot;${product.pid}&quot;/&gt; 传递 pid 的值到 servlet Map&lt;String,String[] properties = request.getParameterMap(); 将前台的属性全部获取，以便之后进行对象的封装 1enctype=&quot;multipart/form-data 如果在 form 中有如上代码，页面能跳转，但是修改不回生效 当 form 使用 enctype=”multipart/form-data” 多表单提交时，getParameter 将无法获取到值，根据 getMethod（） 取值的 BaseServlet 方式抽取 Servlet 会获取不到 method， 需要重新创建继承 HttpServlet 的文件上传 从数据库查询多表或单表的数据时，可以直接封装 map 而不是对象，以 json 字符串返回前台 代码示例web核心内容 商城小demo]]></content>
      <tags>
        <tag>java</tag>
        <tag>web</tag>
        <tag>servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SomeProblem]]></title>
    <url>%2F2018%2F12%2F11%2FSomeProblems%2F</url>
    <content type="text"><![CDATA[serlvet 提交 post 乱码解决方法request.setCharacterEncoding(“UTF-8”); 或者使用先编后解码方式解决 Jquery post 提交已经自动进行过编解码，不需要再写，如果二次编解码反而会乱码 get 提交乱码先编码再解码 JQuery get 中文提交乱码： 先编码后解码 ajax 传值乱码问题如果 ajax 使用 url 后加字段的方式 post 传输到后台乱码，可以将需要传输的参数添加到 data：{key:value} 中 input 在 table 中无法居中table 中 td 表格下再添加 input 无法居中，使用 &lt;tr&gt; &lt;td colspan=&#39;2&#39;&gt;&lt;/td&gt;&lt;/tr&gt; 在 td 中放 input 栏即可 多层引号套用html 中多层引号，第一层： &quot;&quot; 第二层：&#39;&#39; 第三层：\&#39;\&#39; 或者 第一层：&#39;&#39; 第二层：&quot;&quot; 第三层：\&quot;\&quot; 后台的 json 数据横向排列到前台后台传的json 数据遍历到HTML 页面 js 中 map 取不到值的问题js中的map结构实质上是json对象, 即LS那样的键值对. 用”.”号或者[]号可以索引 prepareStatement.setString(index,xxxx) xxxx 可以为 null java 中的 toString 空值判断问题null.toString() 会出现异常,所以进行 toString() 前要进行非空判断 null 可以赋值给 String java print 函数对 print(s) 中的 s 做了判断，如果为 null 则进行 s = ‘null’ ，将字符串 null 赋值给 s 再进行输出 如果 print Integer 则会在内部进行 write(String.Value(obj)) 的转换 value of 的方法 public static String valueOf(Object obj) { return (obj == null) ? &quot;null&quot; : obj.toString();} 内部对其进行判断，是否为空 拓展：Java String 对 null 对象的容错处理 WebService 开发使用 soap 与 wsdl 进行接口开发操作 webService 开发 kudu 建表错误ERROR: ImpalaRuntimeException: Error creating Kudu table ‘impala::kudu_test.t_scd_order_kudu_2’CAUSED BY: NonRecoverableException: Got out-of-order key column: name: “day_of_time” type: STRING is_key: true is_nullable: false cfile_block_size: kudu表的主键必须在建表语句中列的最前面，并且不为空 参考：kudu异常总结 查询连接数据库问题telnet 命令 telnet ip port 可以从本地查看服务器端的 oracle 该 ip 的该端口是否通畅 端口占用问题查看所有端口占用情况C:\Users\Administrator&gt;netstat -ano 查看指定C:\Users\Administrator&gt;netstat -ano|findstr “3000” 查看PID对应的进程C:\Users\Administrator&gt;tasklist|findstr “3000” 结束该进程C:\Users\Administrator&gt;taskkill /f /t /im node.exe/f表示强制终止进程/t表示终止指定的进程和任何由此启动的子进程/im name表示要终止的进程的映像名称，可以使用通配符*/PID process id指定要终止进程的PID 出处：https://www.jianshu.com/p/81b7b2c48bb5 webmvcrequesthandlerprovider required a bean named ‘entitymanagerfactory’添加数据库源配置时没有 @Primary 设置主数据库 result maps collection does not contain value for没有删除一个 mapper.xml 下一个原有的方法 mybatis 使用 bean 传值为空 无效的列类型 mybatis常用jdbcType数据类型 Mybatis：使用bean传值，当传入值为Null时，提示“无效的列类型”的解决办法 循环往list中add对象却总是add的是一个对象 在new 一个对象的时候，对象的ID是唯一确定的； 将对象add入list中时，放入list中的其实是对象的引用 ； 而每次循环只是简单 的set 对象的属性，set新的属性值，而add进list中的对象还是同一个对象id，也就是同一个对象； 将创建对象方法放在循环体内 https://blog.csdn.net/u013991521/article/details/80932838 springboot 启动报错Exception in thread “main” java.lang.NoClassDefFoundError: org/jacoco/agent/rt/internal_035b120/Offline Caused by :java.lang.ClassNotFoundException:org:jacoco.agent.rt.internal_035b120.Offline 使用 maven 工具 clean 清理]]></content>
      <tags>
        <tag>java</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springMVC32]]></title>
    <url>%2F2018%2F10%2F30%2FspringMVC32%2F</url>
    <content type="text"><![CDATA[大致流程流程参考：IDEA整合SSM框架：Spring+SpringMVC+Mybatis 入门 Springmvc 流程 Web 工程 导入 jar 包 web.xml 中配置前端控制器（指定上下文路径 classpath：springmvc.xml） 拦截规则 拦截所有（包括 Jsp）：/* 拦截除了 JSP 以外部分 : / .action 或 .do springmvc.xml 配置扫描 @controller 注解 Action Controller Handler 处理器 需要写的部分：类上@Controller 方法上 @RequestMapping（Value=请求的路径）.action 可以省略 Public ModelAndView itemList(){ ​ new ModelAndView ​ 设置数据 ​ 设置 JSP 页面路径（跳转路径 /WEB-INF/jsp/xxx.jsp） } 架构分析一个中心 三个基本点 前端控制器（在 web.xml 中配置） 处理器映射器 处理器适配器 视图解释器 由 Springmvc 提供 Handler 处理器 JSP 视图（页面，即 html 标签） 由程序员书写 默认三大组件默认三大组件已废弃 现组件：RequestMappingHandlerMapping (处理器映射器) RequestMappingHandlerAdapter (处理器适配器) 可用 &lt;mvc:anonation-driver/&gt; 代替 处理器映射器 和 处理器适配器的配置 视图解释器 用来优化 JSP 页面的路径书写 /WEB-INF/jsp/xxx.jsp 可以拼接 xxx 的前后缀 整合 mybatis SqlMapConfig.xml 核心配置文件（别名） applicationContent.xml 数据源 druid （替代 JDBC）读取 db.properties Mybatis 的工厂以及 Mybaits Mapper 动态代理开发的扫描方式 扫描基本包 创建 db.properties 文件 事务、扫描@Service Spring+Mybatis 创建 Springmvc.xml 三大组件 扫描基本包（com.itheima 包下 controller 与 Service 全扫描） web.xml 文件中配置监听器读取 applicationContext.xml 上下文 配置前端控制器读取 Spingmvc.xml 配置 POST 提交乱码 Fittler 过滤器 参数绑定 默认参数绑定 Request Response Session Model 实现关系 ModelMap 简单类型参数绑定 方法的形参上（Integer id String Double double Boolean） POJO 类型 Items items input name = name name 与 items 对象中属性名一致 包装类型 QueryVo （内含 Items） Query Vo items.name （传参方式） 自定义参数格式 转换日期：在 Springmvc.xml 配置转换器的工厂 Converters list set array 创建自定义转换器类 实现 Converter&lt;S,T&gt; Strus2 与 Springmvc 区别 入口 Servlet 与 Fittler 单例 多例 值 Request域 controller 返回值 ModelAndView 万能的 带数据 返回视图路径后结束 String 只能返回视图路径 需要通过方法传参数 Model model，通过 model 带数据 request.setAttribute(),model.addAttribute(“itemsList”,list); 官方推荐 符合解耦合 数据 视图 分离 MVC void ajax 请求 适合返回 json 格式数据（response 异步请求使用，不用刷页面） 重定向与内部转发区别重定向的页面在提交后会跳转到 重定向的路径（网址） 内部转发的页面在提交后不会跳转 会在修改页面的路径（网址） SpringMVC 三大组件 处理器映射器（HandlerMapping）、视图解析器(ViewResolver) 、处理器适配器(HandlerAdapter) 三大组件的默认配置文件 /springmvc32/web/WEB-INF/lib/spring-webmvc-4.1.3.RELEASE.jar!/org/springframework/web/servlet/DispatcherServlet.properties 在 springmvc 的配置文件中修改默认配置 springmvc.xml 123456789101112131415161718&lt;!--扫描 @Controller @Service --&gt; &lt;context:component-scan base-package="com.itheima"&gt;&lt;/context:component-scan&gt; &lt;!-- 处理器映射器 --&gt; &lt;!--&lt;bean class="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping"/&gt;--&gt; &lt;!-- 处理器适配器 --&gt; &lt;!--&lt;bean class="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter"/&gt;--&gt; &lt;!-- 注解驱动:可以替代以上两个配置 --&gt; &lt;mvc:annotation-driven/&gt; &lt;!-- 视图解析器 --&gt; &lt;!-- 跟 ItemController 的 setViewName 中的内容拼接成完整地址 --&gt; &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix" value="/WEB-INF/jsp/"/&gt; &lt;property name="suffix" value=".jsp"/&gt; &lt;/bean&gt; ItemServiceImpl 中实现接口，并覆写实现方法 将方法放到接口 ItemService controller 控制层中 @RequestMapping(value=”/网页中的 form 中 action 相对地址”) jsp 中 input 的 name 属性中的内容与接受的 Items（bean）的 name 属性一致 jsp 页面上的 name 属性名的参数绑定与 Controller 中传入的 POJO 形参名无关，而是属性名与 POJO 对象中的成员变量名一致 ​ 但是如果将 POJO 进行了包装，将 Items 类封装到 Vo 类中，Vo 类中有着获取、修改 Items 类的方法，则在 jsp 页面的 name 属性名的参数绑定将变为 Items.（Items 类中的成员变量名） 例如：Items.name Q&amp;AQ1: idea 编译出现 “文档中根元素后面的标记必须格式正确” 字样错误提示A: 这个错误一般是元素未正确结束，或者出现未知元素造成的 . 提示这行不代表就是这行，提示是告诉你这个元素有问题，这个元素下面的任何子元素都可能存在问题 错误点：未将 等代码放入 栏 Q2: 运行后网页提示错误：​ org.xml.sax.SAXParseException; lineNumber: 10; columnNumber: 9; cvc-complex-type.2.3: 元素 ‘beans’ 必须不含字符 [子级], 因为该类型的内容类型为“仅元素”。 A: 在 标签中多了一个 、 Q3: debug 报错：​ org.apache.jasper.servlet.TldScanner.scanJars At least one JAR was scanned for TLDs yet contained no TLDs. Enable debug logging for this logger for a complete list of JARs that were scanned but no TLDs were found in them. Skipping unneeded JARs during scanning can improve startup time and JSP compilation time. A: 在apache-tomcat-8.5.29\conf目录下找到logging.properties文件，对文件进行编辑，在最后一行加入： 1234567891011121314151617181920212223242526272829303132333435这样就不再显示错误信息了。http://blog.51cto.com/lavasoft/2087440##### Q4: Tomcat 8报错 SEVERE: One or more listener failed to start​ 06-Nov-2018 17:26:46.429 信息 [RMI TCP Connection(3)-127.0.0.1] org.apache.jasper.servlet.TldScanner.scanJars At least one JAR was scanned for TLDs yet contained no TLDs. Enable debug logging for this logger for a complete list of JARs that were scanned but no TLDs were found in them. Skipping unneeded JARs during scanning can improve startup time and JSP compilation time.​ 06-Nov-2018 17:26:46.465 严重 [RMI TCP Connection(3)-127.0.0.1] org.apache.catalina.core.StandardContext.startInternal One or more listeners failed to start. Full details will be found in the appropriate container log file​ 06-Nov-2018 17:26:46.468 严重 [RMI TCP Connection(3)-127.0.0.1] org.apache.catalina.core.StandardContext.startInternal Context [] startup failed due to previous errorsA: &gt; Full details will be found in the appropriate container log file 意思是让我们在日志文件中查看详细报错信息，那日志文件在哪里呢？这里如果我们是使用idea调试，则日志文件存放在C:\Users\Administrator\.IntelliJIdea2017.1\system\tomcat\Unnamed_SpringMVCDemo\logs 详细问题在 logs 文件夹的几个日志文件中参考：https://blog.csdn.net/dkbnull/article/details/81605157 &gt; If you are using IntelliJ IDEA, and deploy application on Tomcat Server, it says: Under File menu -&gt; select project Structure -&gt; click artifact -&gt; select your jars and right click -&gt; put in WEB\lib -&gt; restart server参考：https://stackoverflow.com/questions/6210757/java-lang-classnotfoundexception-org-springframework-web-context-contextloaderl##### Q5: 启动服务后网页报错```javaorg.springframework.beans.factory.BeanCreationException: Error creating bean with name &apos;itemController&apos;: Injection of autowired dependencies failed; nested exception is org.springframework.beans.factory.BeanCreationException: Could not autowire field: private com.itheima.springmvc.service.ItemService com.itheima.springmvc.controller.ItemController.itemService; nested exception is org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of type [com.itheima.springmvc.service.ItemService] found for dependency: expected at least 1 bean which qualifies as autowire candidate for this dependency. Dependency annotations: &#123;@org.springframework.beans.factory.annotation.Autowired(required=true)&#125; A: spring在管理创建bean的时候发生了错误，一是检查注解是否正确@Service;二是看看web.xml中配置的 spring容器的 xml 文件是否错误 未添加 ItemServiceImpl 的 @Service 注释 参考：https://blog.csdn.net/zxz9325/article/details/79179444 Q6: HTTP Status 500 – Internal Server Error Type Exception Report Message Request processing failed; nested exception is java.lang.NumberFormatException: null Description The server encountered an unexpected condition that prevented it from fulfilling the request. Exception 1org.springframework.web.util.NestedServletException: Request processing failed; nested exception is java.lang.NumberFormatException: null A: 应该打开查询网页 http://localhost:8080/itemEdit.action 而非直接打开 http://localhost:8080/item/itemEdit.action，无法直接访问，而且没有传 id 导致为空 Q7: 运行后显示 404Type Status Report Description The origin server did not find a current representation for the target resource or is not willing to disclose that one exists. A: http://blog.csdn.net/DBC_121/article/details/79204340 @requestMapping(value=””) 中 value 地址书写错误 Q8:HTTP Status 400 – Bad RequestType Status Report Description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). A: jsp 页面上的 name 属性名的参数绑定与 Controller 中传入的 POJO 形参名无关，而是属性名与 POJO 对象中的成员变量名一致,如果不一致则在后台获取不到参数 Q9:jsp 页面 name 属性名应与 POJO 内部成员变量一致HTTP Status 500 – Internal Server Error Type Exception Report Message Request processing failed; nested exception is java.lang.NullPointerException Description The server encountered an unexpected condition that prevented it from fulfilling the request. A: 将 POJO 进行包装后没有在 jsp 页面进行 name 属性修改 如果将 POJO 进行了包装，将 Items 类封装到 Vo 类中，Vo 类中有着获取、修改 Items 类的方法，则在 jsp 页面的 name 属性名的参数绑定将变为 Items.（Items 类中的成员变量名） 例如：Items.name Q10:自定义异常错误HTTP Status 500 – Internal Server Error Type Exception Report Message Request processing failed; nested exception is java.lang.ClassCastException: java.lang.ArithmeticException cannot be cast to com.itheima.springmvc.exception.MessageException Description The server encountered an unexpected condition that prevented it from fulfilling the request. Exception 12345678910org.springframework.web.util.NestedServletException: Request processing failed; nested exception is java.lang.ClassCastException: java.lang.ArithmeticException cannot be cast to com.itheima.springmvc.exception.MessageException org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:978) org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:857) javax.servlet.http.HttpServlet.service(HttpServlet.java:635) org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:842) javax.servlet.http.HttpServlet.service(HttpServlet.java:742) org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52) org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:88) org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) org.apache.logging.log4j.core.web.Log4jServletFilter.doFilter(Log4jServletFilter.java:66) Root Cause 123456789101112131415java.lang.ClassCastException: java.lang.ArithmeticException cannot be cast to com.itheima.springmvc.exception.MessageException com.itheima.springmvc.exception.CustomExceptionResolver.resolveException(CustomExceptionResolver.java:19) org.springframework.web.servlet.DispatcherServlet.processHandlerException(DispatcherServlet.java:1167) org.springframework.web.servlet.DispatcherServlet.processDispatchResult(DispatcherServlet.java:1004) org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:955) org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:877) org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:966) org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:857) javax.servlet.http.HttpServlet.service(HttpServlet.java:635) org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:842) javax.servlet.http.HttpServlet.service(HttpServlet.java:742) org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52) org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:88) org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) org.apache.logging.log4j.core.web.Log4jServletFilter.doFilter(Log4jServletFilter.java:66) Note The full stack trace of the root cause is available in the server logs. A： 12345678910ModelAndView mav = new ModelAndView();if(e instanceof MessageException)&#123; MessageException me = (MessageException)e; mav.addObject("error",me.getMsg());&#125;else &#123; mav.addObject("error", "未知异常");&#125;mav.setViewName("error");return mav; Tips：intelj idea 添加本地 xsd 文件​ intellij idea配置外部dtd文件 ​ 打开file——Settings..(快捷键ctrl+alt+s); ​ 找到Languages&amp;Frameworks——Schemas and DTDs ​ 找到右侧的External Schemas and DTDs窗口中点击添加按钮 ​ 在 Explorer 栏找到下载好的外部 dtd 文件 ​ 在 URI 栏可以填入从 xml 文件头上找到的相对应约束 URI ​ intelj idea jar 包 导入​ 导入 jar 包 3种方法 intelj idea 中的 mybatis 逆向工程​ Mybatis在IDEA中使用generator逆向工程生成pojo,mapper ​ 12345// servlet 开发// String id = request.getParameter("id");// Items items = itemService.selectItemsById(Integer.parseInt(id));// Spring 底层还是使用 request 的 getParameter 方法获取 id 的值的，但是我们不需要自己去写，并且会自动帮我们转换 Int 类型 Items items = itemService.selectItemsById(id); Springmvc 与 Strus2 的区别参数绑定区别​ Strus2 绑定参数在类的属性（ Action 的成员变量上） ​ Springmvc 从客户端请求 key/value 数据，通过参数绑定，将其绑定在 controller 方法的形参上 ​ SpringMVC中的参数绑定总结 存储数据区别​ Springmvc 使用 ModelAndView.addObject(“”,””); ​ 底层是 request.setAttribute(“”,””); 存在 request 的域中，没有值栈概念 ​ Strus2 有值栈概念 入口区别​ Springmvc 入口是 servlet 前端控制器 ​ Strus2 是过滤器 filter 模式区别​ Springmvc 是单例模式（以方法为单位，每次请求复制一个方法副本） ​ Strus2 是多例模式（以类为单位，每个请求创建一个类） 代码实现简易 springmvc 代码 Springmvc-mybatis]]></content>
      <categories>
        <category>SpringMvc</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>springmvc</tag>
        <tag>mybatis Maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linuxInstall]]></title>
    <url>%2F2018%2F09%2F12%2FlinuxInstall%2F</url>
    <content type="text"><![CDATA[linux 无法使用 ifconfig https://www.cnblogs.com/dunitian/p/4974761.html ：使用新指令 ip 没有 ifcfg-eth0 ，可能为 ifcfg-ens33 或其他 https://hk.saowen.com/a/227c3c22a44418b6927076afcd72c05d41291f7d0e9dc7fa60031b591d9bedbc Centos 下安装与设置VIM编辑器 查找已安装的myslq 版本：​ #rpm -qa | grep mysql （注意大小写，如果mysql 不行就换MySQL） Linux 下 mysql 安装：遇到该错误哪个被需要 yum 哪个 12用yum命令安装依赖,多个依赖用空格隔开,命令如下: yum -y install libaio.so.1 libc.so.6 libcrypt.so.1 libdl.so.2 libm.so.6 net-tools 点击详细错误：依赖检测失败 libaio.so.1 被 MySQL-server-5.6.22-1.el6.i686 需要 libaio.so.1(LIBAIO_0.1) 被 MySQL-server-5.6.22-1.el6.i686 需要 libaio.so.1(LIBAIO_0.4) 被 MySQL-server-5.6.22-1.el6.i686 需要 libc.so.6 被 MySQL-server-5.6.22-1.el6.i686 需要 libc.so.6(GLIBC_2.0) 被 MySQL-server-5.6.22-1.el6.i686 需要 libc.so.6(GLIBC_2.1) 被 MySQL-server-5.6.22-1.el6.i686 需要 libc.so.6(GLIBC_2.1.2) 被 MySQL-server-5.6.22-1.el6.i686 需要 libc.so.6(GLIBC_2.1.3) 被 MySQL-server-5.6.22-1.el6.i686 需要 libc.so.6(GLIBC_2.10) 被 MySQL-server-5.6.22-1.el6.i686 需要 libc.so.6(GLIBC_2.2) 被 MySQL-server-5.6.22-1.el6.i686 需要 libc.so.6(GLIBC_2.2.3) 被 MySQL-server-5.6.22-1.el6.i686 需要 libc.so.6(GLIBC_2.3) 被 MySQL-server-5.6.22-1.el6.i686 需要 libc.so.6(GLIBC_2.3.3) 被 MySQL-server-5.6.22-1.el6.i686 需要 libc.so.6(GLIBC_2.3.4) 被 MySQL-server-5.6.22-1.el6.i686 需要 libc.so.6(GLIBC_2.4) 被 MySQL-server-5.6.22-1.el6.i686 需要 libc.so.6(GLIBC_2.7) 被 MySQL-server-5.6.22-1.el6.i686 需要 libc.so.6(GLIBC_2.8) 被 MySQL-server-5.6.22-1.el6.i686 需要 libcrypt.so.1 被 MySQL-server-5.6.22-1.el6.i686 需要 libcrypt.so.1(GLIBC_2.0) 被 MySQL-server-5.6.22-1.el6.i686 需要 libdl.so.2 被 MySQL-server-5.6.22-1.el6.i686 需要 libdl.so.2(GLIBC_2.0) 被 MySQL-server-5.6.22-1.el6.i686 需要 libdl.so.2(GLIBC_2.1) 被 MySQL-server-5.6.22-1.el6.i686 需要 libgcc_s.so.1 被 MySQL-server-5.6.22-1.el6.i686 需要 libgcc_s.so.1(GCC_3.0) 被 MySQL-server-5.6.22-1.el6.i686 需要 libgcc_s.so.1(GLIBC_2.0) 被 MySQL-server-5.6.22-1.el6.i686 需要 libm.so.6 被 MySQL-server-5.6.22-1.el6.i686 需要 libm.so.6(GLIBC_2.0) 被 MySQL-server-5.6.22-1.el6.i686 需要 libm.so.6(GLIBC_2.1) 被 MySQL-server-5.6.22-1.el6.i686 需要 libpthread.so.0 被 MySQL-server-5.6.22-1.el6.i686 需要 libpthread.so.0(GLIBC_2.0) 被 MySQL-server-5.6.22-1.el6.i686 需要 libpthread.so.0(GLIBC_2.1) 被 MySQL-server-5.6.22-1.el6.i686 需要 libpthread.so.0(GLIBC_2.2) 被 MySQL-server-5.6.22-1.el6.i686 需要 libpthread.so.0(GLIBC_2.3.2) 被 MySQL-server-5.6.22-1.el6.i686 需要 librt.so.1 被 MySQL-server-5.6.22-1.el6.i686 需要 librt.so.1(GLIBC_2.2) 被 MySQL-server-5.6.22-1.el6.i686 需要 libstdc++.so.6 被 MySQL-server-5.6.22-1.el6.i686 需要 libstdc++.so.6(CXXABI_1.3) 被 MySQL-server-5.6.22-1.el6.i686 需要 libstdc++.so.6(GLIBCXX_3.4) 被 MySQL-server-5.6.22-1.el6.i686 需要 libstdc++.so.6(GLIBCXX_3.4.11) 被 MySQL-server-5.6.22-1.el6.i686 需要 libstdc++.so.6(GLIBCXX_3.4.9) 被 MySQL-server-5.6.22-1.el6.i686 需要 net-tools 被 MySQL-server-5.6.22-1.el6.i686 需要[root@localhost mysql]# yum install libaio.so.1已加载插件：fastestmirrorLoading mirror speeds from cached hostfile- base: mirrors.njupt.edu.cn- extras: mirrors.163.com- updates: mirrors.163.com正在解决依赖关系–&gt; 正在检查事务—&gt; 软件包 libaio.i686.0.0.3.109-13.el7 将被 安装–&gt; 解决依赖关系完成依赖关系解决=============================================================================== Package 架构 版本 源 大小正在安装: libaio i686 0.3.109-13.el7 base 24 k事务概要安装 1 软件包总下载量：24 k安装大小：37 kIs this ok [y/d/N]: yDownloading packages:libaio-0.3.109-13.el7.i686.rpm | 24 kB 00:00Running transaction checkRunning transaction testTransaction test succeededRunning transaction警告：RPM 数据库已被非 yum 程序修改。** 发现 41 个已存在的 RPM 数据库问题， ‘yum check’ 输出如下：MySQL-server-5.6.22-1.el6.i686 有缺少的需求 libaio.so.1MySQL-server-5.6.22-1.el6.i686 有缺少的需求 libaio.so.1(LIBAIO_0.1)MySQL-server-5.6.22-1.el6.i686 有缺少的需求 libaio.so.1(LIBAIO_0.4)MySQL-server-5.6.22-1.el6.i686 有缺少的需求 libc.so.6MySQL-server-5.6.22-1.el6.i686 有缺少的需求 libc.so.6(GLIBC_2.0)MySQL-server-5.6.22-1.el6.i686 有缺少的需求 libc.so.6(GLIBC_2.1)MySQL-server-5.6.22-1.el6.i686 有缺少的需求 libc.so.6(GLIBC_2.1.2)MySQL-server-5.6.22-1.el6.i686 有缺少的需求 libc.so.6(GLIBC_2.1.3)MySQL-server-5.6.22-1.el6.i686 有缺少的需求 libc.so.6(GLIBC_2.10)MySQL-server-5.6.22-1.el6.i686 有缺少的需求 libc.so.6(GLIBC_2.2)MySQL-server-5.6.22-1.el6.i686 有缺少的需求 libc.so.6(GLIBC_2.2.3)MySQL-server-5.6.22-1.el6.i686 有缺少的需求 libc.so.6(GLIBC_2.3)MySQL-server-5.6.22-1.el6.i686 有缺少的需求 libc.so.6(GLIBC_2.3.3)MySQL-server-5.6.22-1.el6.i686 有缺少的需求 libc.so.6(GLIBC_2.3.4)MySQL-server-5.6.22-1.el6.i686 有缺少的需求 libc.so.6(GLIBC_2.4)MySQL-server-5.6.22-1.el6.i686 有缺少的需求 libc.so.6(GLIBC_2.7)MySQL-server-5.6.22-1.el6.i686 有缺少的需求 libc.so.6(GLIBC_2.8)MySQL-server-5.6.22-1.el6.i686 有缺少的需求 libcrypt.so.1MySQL-server-5.6.22-1.el6.i686 有缺少的需求 libcrypt.so.1(GLIBC_2.0)MySQL-server-5.6.22-1.el6.i686 有缺少的需求 libdl.so.2MySQL-server-5.6.22-1.el6.i686 有缺少的需求 libdl.so.2(GLIBC_2.0)MySQL-server-5.6.22-1.el6.i686 有缺少的需求 libdl.so.2(GLIBC_2.1)MySQL-server-5.6.22-1.el6.i686 有缺少的需求 libgcc_s.so.1MySQL-server-5.6.22-1.el6.i686 有缺少的需求 libgcc_s.so.1(GCC_3.0)MySQL-server-5.6.22-1.el6.i686 有缺少的需求 libgcc_s.so.1(GLIBC_2.0)MySQL-server-5.6.22-1.el6.i686 有缺少的需求 libm.so.6MySQL-server-5.6.22-1.el6.i686 有缺少的需求 libm.so.6(GLIBC_2.0)MySQL-server-5.6.22-1.el6.i686 有缺少的需求 libm.so.6(GLIBC_2.1)MySQL-server-5.6.22-1.el6.i686 有缺少的需求 libpthread.so.0MySQL-server-5.6.22-1.el6.i686 有缺少的需求 libpthread.so.0(GLIBC_2.0)MySQL-server-5.6.22-1.el6.i686 有缺少的需求 libpthread.so.0(GLIBC_2.1)MySQL-server-5.6.22-1.el6.i686 有缺少的需求 libpthread.so.0(GLIBC_2.2)MySQL-server-5.6.22-1.el6.i686 有缺少的需求 libpthread.so.0(GLIBC_2.3.2)MySQL-server-5.6.22-1.el6.i686 有缺少的需求 librt.so.1MySQL-server-5.6.22-1.el6.i686 有缺少的需求 librt.so.1(GLIBC_2.2)MySQL-server-5.6.22-1.el6.i686 有缺少的需求 libstdc++.so.6MySQL-server-5.6.22-1.el6.i686 有缺少的需求 libstdc++.so.6(CXXABI_1.3)MySQL-server-5.6.22-1.el6.i686 有缺少的需求 libstdc++.so.6(GLIBCXX_3.4)MySQL-server-5.6.22-1.el6.i686 有缺少的需求 libstdc++.so.6(GLIBCXX_3.4.11)MySQL-server-5.6.22-1.el6.i686 有缺少的需求 libstdc++.so.6(GLIBCXX_3.4.9)MySQL-server-5.6.22-1.el6.i686 有缺少的需求 net-tools 正在安装 : libaio-0.3.109-13.el7.i686 1/1 验证中 : libaio-0.3.109-13.el7.i686 1/1已安装: libaio.i686 0:0.3.109-13.el7完毕！ 然后 继续安装 mysql 包出现问题 12345678910[root@localhost mysql]# rpm -ivh MySQL-server-5.6.22-1.el6.i686.rpm错误：依赖检测失败： libgcc_s.so.1 被 MySQL-server-5.6.22-1.el6.i686 需要 libgcc_s.so.1(GCC_3.0) 被 MySQL-server-5.6.22-1.el6.i686 需要 libgcc_s.so.1(GLIBC_2.0) 被 MySQL-server-5.6.22-1.el6.i686 需要 libstdc++.so.6 被 MySQL-server-5.6.22-1.el6.i686 需要 libstdc++.so.6(CXXABI_1.3) 被 MySQL-server-5.6.22-1.el6.i686 需要 libstdc++.so.6(GLIBCXX_3.4) 被 MySQL-server-5.6.22-1.el6.i686 需要 libstdc++.so.6(GLIBCXX_3.4.11) 被 MySQL-server-5.6.22-1.el6.i686 需要 libstdc++.so.6(GLIBCXX_3.4.9) 被 MySQL-server-5.6.22-1.el6.i686 需要 选择 yum -y install libgcc_s.so.1 libstdc++.so.6出现新问题 点击显示详细错误：已加载插件… 已加载插件：fastestmirrorLoading mirror speeds from cached hostfile base: mirrors.njupt.edu.cn extras: mirrors.163.com * updates: mirrors.163.com正在解决依赖关系–&gt; 正在检查事务—&gt; 软件包 libgcc.i686.0.4.8.5-36.el7 将被 安装–&gt; 解决依赖关系完成错误： Multilib version problems found. This often means that the root cause is something else and multilib version checking is just pointing out that there is a problem. Eg.: 1. You have an upgrade for libgcc which is missing some dependency that another package requires. Yum is trying to solve this by installing an older version of libgcc of the different architecture. If you exclude the bad architecture yum will tell you what the root cause is (which package requires what). You can try redoing the upgrade with –exclude libgcc.otherarch … this should give you an error message showing the root cause of the problem. 2. You have multiple architectures of libgcc installed, but yum can only see an upgrade for one of those architectures. If you don’t want/need both architectures anymore then you can remove the one with the missing update and everything will work. 3. You have duplicate versions of libgcc installed already. You can use “yum check” to get yum show these errors. …you can also use –setopt=protected_multilib=false to remove this checking, however this is almost never the correct thing to do as something else is very likely to go wrong (often causing much more problems). 错误：保护多库版本：libgcc-4.8.5-36.el7.i686 != libgcc-4.8.5-28.el7.x86_64 此时哪个出现 ‘保护多版本库’ 升级哪个 yum update libstdc++-4.8.5-28.el7.x86_64 全部解决后即可安装 mysql 参考：https://blog.csdn.net/Wuhaotian1996/article/details/80689009 https://blog.csdn.net/qq_40208605/article/details/80679020 点击详情：安装mysql异常 [root@localhost mysql]# rpm -ivh MySQL-server-5.6.22-1.el6.i686.rpm准备中… ################################# [100%] file /usr/share/mysql/charsets/README from install of MySQL-server-5.6.22-1.el6.i686 conflicts with file from package mariadb-libs-1:5.5.56-2.el7.x86_64 file /usr/share/mysql/czech/errmsg.sys from install of MySQL-server-5.6.22-1.el6.i686 conflicts with file from package mariadb-libs-1:5.5.56-2.el7.x86_64 file /usr/share/mysql/danish/errmsg.sys from install of MySQL-server-5.6.22-1.el6.i686 conflicts with file from package mariadb-libs-1:5.5.56-2.el7.x86_64 file /usr/share/mysql/dutch/errmsg.sys from install of MySQL-server-5.6.22-1.el6.i686 conflicts with file from package mariadb-libs-1:5.5.56-2.el7.x86_64 file /usr/share/mysql/english/errmsg.sys from install of MySQL-server-5.6.22-1.el6.i686 conflicts with file from package mariadb-libs-1:5.5.56-2.el7.x86_64 file /usr/share/mysql/estonian/errmsg.sys from install of MySQL-server-5.6.22-1.el6.i686 conflicts with file from package mariadb-libs-1:5.5.56-2.el7.x86_64 file /usr/share/mysql/french/errmsg.sys from install of MySQL-server-5.6.22-1.el6.i686 conflicts with file from package mariadb-libs-1:5.5.56-2.el7.x86_64 file /usr/share/mysql/german/errmsg.sys from install of MySQL-server-5.6.22-1.el6.i686 conflicts with file from package mariadb-libs-1:5.5.56-2.el7.x86_64 file /usr/share/mysql/greek/errmsg.sys from install of MySQL-server-5.6.22-1.el6.i686 conflicts with file from package mariadb-libs-1:5.5.56-2.el7.x86_64 file /usr/share/mysql/hungarian/errmsg.sys from install of MySQL-server-5.6.22-1.el6.i686 conflicts with file from package mariadb-libs-1:5.5.56-2.el7.x86_64 file /usr/share/mysql/italian/errmsg.sys from install of MySQL-server-5.6.22-1.el6.i686 conflicts with file from package mariadb-libs-1:5.5.56-2.el7.x86_64 file /usr/share/mysql/japanese/errmsg.sys from install of MySQL-server-5.6.22-1.el6.i686 conflicts with file from package mariadb-libs-1:5.5.56-2.el7.x86_64 file /usr/share/mysql/korean/errmsg.sys from install of MySQL-server-5.6.22-1.el6.i686 conflicts with file from package mariadb-libs-1:5.5.56-2.el7.x86_64 file /usr/share/mysql/norwegian-ny/errmsg.sys from install of MySQL-server-5.6.22-1.el6.i686 conflicts with file from package mariadb-libs-1:5.5.56-2.el7.x86_64 file /usr/share/mysql/norwegian/errmsg.sys from install of MySQL-server-5.6.22-1.el6.i686 conflicts with file from package mariadb-libs-1:5.5.56-2.el7.x86_64 file /usr/share/mysql/polish/errmsg.sys from install of MySQL-server-5.6.22-1.el6.i686 conflicts with file from package mariadb-libs-1:5.5.56-2.el7.x86_64 file /usr/share/mysql/portuguese/errmsg.sys from install of MySQL-server-5.6.22-1.el6.i686 conflicts with file from package mariadb-libs-1:5.5.56-2.el7.x86_64 file /usr/share/mysql/romanian/errmsg.sys from install of MySQL-server-5.6.22-1.el6.i686 conflicts with file from package mariadb-libs-1:5.5.56-2.el7.x86_64 file /usr/share/mysql/russian/errmsg.sys from install of MySQL-server-5.6.22-1.el6.i686 conflicts with file from package mariadb-libs-1:5.5.56-2.el7.x86_64 file /usr/share/mysql/serbian/errmsg.sys from install of MySQL-server-5.6.22-1.el6.i686 conflicts with file from package mariadb-libs-1:5.5.56-2.el7.x86_64 file /usr/share/mysql/slovak/errmsg.sys from install of MySQL-server-5.6.22-1.el6.i686 conflicts with file from package mariadb-libs-1:5.5.56-2.el7.x86_64 file /usr/share/mysql/spanish/errmsg.sys from install of MySQL-server-5.6.22-1.el6.i686 conflicts with file from package mariadb-libs-1:5.5.56-2.el7.x86_64 file /usr/share/mysql/swedish/errmsg.sys from install of MySQL-server-5.6.22-1.el6.i686 conflicts with file from package mariadb-libs-1:5.5.56-2.el7.x86_64 file /usr/share/mysql/ukrainian/errmsg.sys from install of MySQL-server-5.6.22-1.el6.i686 conflicts with file from package mariadb-libs-1:5.5.56-2.el7.x86_64 file /usr/share/mysql/charsets/Index.xml from install of MySQL-server-5.6.22-1.el6.i686 conflicts with file from package mariadb-libs-1:5.5.56-2.el7.x86_64 file /usr/share/mysql/charsets/armscii8.xml from install of MySQL-server-5.6.22-1.el6.i686 conflicts with file from package mariadb-libs-1:5.5.56-2.el7.x86_64 file /usr/share/mysql/charsets/ascii.xml from install of MySQL-server-5.6.22-1.el6.i686 conflicts with file from package mariadb-libs-1:5.5.56-2.el7.x86_64 file /usr/share/mysql/charsets/cp1250.xml from install of MySQL-server-5.6.22-1.el6.i686 conflicts with file from package mariadb-libs-1:5.5.56-2.el7.x86_64 file /usr/share/mysql/charsets/cp1251.xml from install of MySQL-server-5.6.22-1.el6.i686 conflicts with file from package mariadb-libs-1:5.5.56-2.el7.x86_64 file /usr/share/mysql/charsets/cp1256.xml from install of MySQL-server-5.6.22-1.el6.i686 conflicts with file from package mariadb-libs-1:5.5.56-2.el7.x86_64 file /usr/share/mysql/charsets/cp1257.xml from install of MySQL-server-5.6.22-1.el6.i686 conflicts with file from package mariadb-libs-1:5.5.56-2.el7.x86_64 file /usr/share/mysql/charsets/cp850.xml from install of MySQL-server-5.6.22-1.el6.i686 conflicts with file from package mariadb-libs-1:5.5.56-2.el7.x86_64 file /usr/share/mysql/charsets/cp852.xml from install of MySQL-server-5.6.22-1.el6.i686 conflicts with file from package mariadb-libs-1:5.5.56-2.el7.x86_64 file /usr/share/mysql/charsets/cp866.xml from install of MySQL-server-5.6.22-1.el6.i686 conflicts with file from package mariadb-libs-1:5.5.56-2.el7.x86_64 file /usr/share/mysql/charsets/dec8.xml from install of MySQL-server-5.6.22-1.el6.i686 conflicts with file from package mariadb-libs-1:5.5.56-2.el7.x86_64 file /usr/share/mysql/charsets/geostd8.xml from install of MySQL-server-5.6.22-1.el6.i686 conflicts with file from package mariadb-libs-1:5.5.56-2.el7.x86_64 file /usr/share/mysql/charsets/greek.xml from install of MySQL-server-5.6.22-1.el6.i686 conflicts with file from package mariadb-libs-1:5.5.56-2.el7.x86_64 file /usr/share/mysql/charsets/hebrew.xml from install of MySQL-server-5.6.22-1.el6.i686 conflicts with file from package mariadb-libs-1:5.5.56-2.el7.x86_64 file /usr/share/mysql/charsets/hp8.xml from install of MySQL-server-5.6.22-1.el6.i686 conflicts with file from package mariadb-libs-1:5.5.56-2.el7.x86_64 file /usr/share/mysql/charsets/keybcs2.xml from install of MySQL-server-5.6.22-1.el6.i686 conflicts with file from package mariadb-libs-1:5.5.56-2.el7.x86_64 file /usr/share/mysql/charsets/koi8r.xml from install of MySQL-server-5.6.22-1.el6.i686 conflicts with file from package mariadb-libs-1:5.5.56-2.el7.x86_64 file /usr/share/mysql/charsets/koi8u.xml from install of MySQL-server-5.6.22-1.el6.i686 conflicts with file from package mariadb-libs-1:5.5.56-2.el7.x86_64 file /usr/share/mysql/charsets/latin1.xml from install of MySQL-server-5.6.22-1.el6.i686 conflicts with file from package mariadb-libs-1:5.5.56-2.el7.x86_64 file /usr/share/mysql/charsets/latin2.xml from install of MySQL-server-5.6.22-1.el6.i686 conflicts with file from package mariadb-libs-1:5.5.56-2.el7.x86_64 file /usr/share/mysql/charsets/latin5.xml from install of MySQL-server-5.6.22-1.el6.i686 conflicts with file from package mariadb-libs-1:5.5.56-2.el7.x86_64 file /usr/share/mysql/charsets/latin7.xml from install of MySQL-server-5.6.22-1.el6.i686 conflicts with file from package mariadb-libs-1:5.5.56-2.el7.x86_64 file /usr/share/mysql/charsets/macce.xml from install of MySQL-server-5.6.22-1.el6.i686 conflicts with file from package mariadb-libs-1:5.5.56-2.el7.x86_64 file /usr/share/mysql/charsets/macroman.xml from install of MySQL-server-5.6.22-1.el6.i686 conflicts with file from package mariadb-libs-1:5.5.56-2.el7.x86_64 file /usr/share/mysql/charsets/swe7.xml from install of MySQL-server-5.6.22-1.el6.i686 conflicts with file from package mariadb-libs-1:5.5.56-2.el7.x86_64 经网上查找是起了冲突 ‘conflicts’ 看到“conflicts”，是产生冲突了，文件“/usr/share/mysql/charsets/*”需要MySQL-server-5.6.22-1.el6.i686 版本的，而系统已经存在mariadb-libs-1:5.5.56-2.el7.x86_64版本的 删除冲突文件 mariadb-libs-1:5.5.56-2* yum -y remove mariadb-libs-1:5.5.56-2* 然后就可以安装自己的 mysql 了 参考：https://blog.csdn.net/testcs_dn/article/details/39026213 tomcat 安装后，启动找不到安装的 jdk解决方法：将jdk 目录手动配置到 catalina.sh 文件下 配置jdk环境变量，打开/etc/profile配置文件，将下面配置拷贝进去 123456789#set java environment JAVA_HOME=/usr/local/jdk1.8.0_191 CLASSPATH=.:$JAVA_HOME/lib.tools.jar PATH=$JAVA_HOME/bin:$PATH export JAVA_HOME CLASSPATH PATH 重新加载 /etc/profile 配置文件 source /etc/profile 永久写入防火墙配置因为是 CentOS Linux 7 的内核，不能直接用 6 内核的方法 先删除 7.0 系统自带防火墙，，安装旧版 开放 xxx 端口 /sbin/iptables -I INPUT -p tcp –dport 80 -j ACCEPT 永久保存 service iptables save 或 /usr/libexec/iptables/iptables.init save 参考：https://www.cnblogs.com/zhangzhibin/p/6231870.html https://blog.csdn.net/guoyf123321/article/details/52416328 mysql 安装后没有密码文件重设 mysql 密码 解决方案如下： #service mysqld stop#mysqld_safe –user=mysql –skip-grant-tables –skip-networking &amp; #mysql -u root mysql mysql&gt; UPDATE user SET Password=PASSWORD(‘newpassword’) where USER=’root’;mysql&gt; FLUSH PRIVILEGES;mysql&gt; quit service mysqld restart # mysql -uroot -pEnter password: &lt;输入新设的密码newpassword&gt; mysql&gt; UPDATE user SET Password=PASSWORD(‘newpassword’) where USER=’root’; 这句中的 newpassword 指需要新设置的密码 参考：https://onekeyes.iteye.com/blog/2316794 Linux tomcat 部署 war 文件后无法访问 tomcat 只显示 tomcat 主页可能是 idea 的 tomcat 和 jdk 版本跟 Linux 下的不同，将 linux 的 tomcat 和 jdk 升级成 idea 一样。 idea 使用 Junit 自动生成测试类https://www.cnblogs.com/libingbin/p/6007203.html Xshell 无法 ping 通虚拟机，虚拟机可以 ping 通 本机，而且无法连接虚拟机 主机的网络适配器设置，NAT相关的适配器变成了自动获取IP地址，需要改成手动配置，将虚拟机的网段填入 如虚拟机子网 ip 为 192.168.25.0 子网掩码为 255.255.255.0 网关为 192.168.25.2 本机的 VMnet8 ip 改为 192.168.25.1 子网掩码为 255.255.255.0 网关为 192.168.25.2 然后就可 ping 通虚拟机了 出处：NAT模式，虚拟机可以ping通主机，主机不能ping通虚拟机，主机ping不同虚拟机]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[idea_create_web]]></title>
    <url>%2F2018%2F08%2F31%2Fidea-create-web%2F</url>
    <content type="text"><![CDATA[流程参考：https://www.cnblogs.com/xuange306/p/7012341.htmlidea 设置参考 遇见的小问题：没有 javax.servlet.* 的 jar 包 在 Project Structure 中选择 libraries 点击左侧加号选择 java 添加 tomcat 文件夹下 lib 文件夹中的 servlet-api.jar 同时也可添加常用 jar 包 tomcat-api 与 jsp-api 可以使用 ctrl+shift+alt+s 打开 Project Structure 选择 Modules 点击右侧 + 号，选择 libraries ，选择 Project Libraries 下的 tomcat 添加即可 普通 jar 包添加可选方法：在 WEB-INF 下创建 lib 目录，把 jar 包复制到 lib 目录下，ctrl+shift+alt+s 打开 Project Structure 选择左侧 libraries ，点击左侧加号 选择 java，选择 创建的 lib 目录添加，选择左侧 Modules 栏，勾选 lib https://my.oschina.net/fdblog/blog/161305 创建Web项目后没有WEB-INF文件夹及web.xml 最简单的方法：idea 创建 web 项目时用 xml 2.5 或： shift+ctrl+alt+s进入Project Structure打开Project Structure，在facets中选中次级的web或者在Modules中选中web，在deployment Descriptors面板里，点击 +号选择web.xml以及版本号。然后在弹出的对话框中修改xml默认的目录，加上web就可以了 Q: IntelliJ IDEA Tomcal启动报错： org.apache.catalina.core.AprLifecycleListener.init The APR based Apache Tomcat Native library failed to load. The error reported was [C:\tomcat\bin\tcnative-1.dll: Can’t load AMD 64-bit .dll on a IA 32-bit platform] java.lang.UnsatisfiedLinkError: C:\tomcat\bin\tcnative-1.dll: Can’t load AMD 64-bit .dll on a IA 32-bit platform A: 主要是在64位的系统下安装的虚拟机是64位的，而WTK的sublime.dll不能在64位的平台下加载64位的虚拟机，只能加载32位的。由于WTK在安装的时候加载的64虚拟机的地址，它找到的是64位的虚拟机，所以它提示不能加载32位的虚拟机（在目录下没有32的虚拟机） 解决办法下载 the 32bit from http://www.apache.org/dist/tomcat/tomcat-connectors/native/找到最近的版本，我的是 tomcat-native-1.2.16-win32-bin.zip下载后解压，找到tomcat-native-1.2.16-win32-bin.zip\bin\tcnative-1.dll (不是64X文件夹中的)替换到tomcat根目录下tomcat\bin idea tomcat警告参考：http://blog.51cto.com/13765598/2120489 Q: intellj idea启动tomcat服务器后无法访问localhost:8080（白屏）A: 原因：没有将tomcat主页的工程部署到intellj idea的虚拟tomcat路径，可在Run/Debug Configurations中Deployment选项中点击右边的绿色加号，选择External Source，然后添加Tomcat安装目录tomcat/webapps/Root目录即可；参考资料：https://blog.csdn.net/qq_22708467/article/details/79070973 Q:idea 打 jar 包出现 MANIFEST.MF already exists in VFSA:打包 jar 参考：https://blog.csdn.net/xuemengrui12/article/details/74984731 之前已经在 IDEA 打过 jar 包了，module 中会有一个 MANIFEST.MF 文件夹，删除文件夹重新打包即可，VFS 是虚拟文件系统 META MANIFEST.MF 介绍与参考 参考：https://blog.csdn.net/sdujava2011/article/details/50245261 Q:idea 打 jar 包修改名称A: 直接在 artifacts 中的 Output Layout 中右键 jar 包重命名 tips：在部署 tomcat 服务器时，点击右上角 edit configurations 选择Deployment 添加了 Artifact 后，右边的Application context中的 / 代表项目部署的虚拟路径（网址访问主页面路径）: 若 index.jsp 在 aaa/web 目录下，虚拟路径为 /则访问 index.jsp 地址为 localhost/8080 或 localhost/8080/index.jsp . 若虚拟路径设为 /aaa 则访问 index.jsp 的地址为 localhost/8080/aaa/index.jsp 或 localhost/8080/aaa-request.getContextPath(); 得到的值为虚拟路径 maven 打 jar 包配置 maven pom 文件 1234567891011121314151617181920212223242526272829303132&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;archive&gt; &lt;manifest&gt; &lt;addClasspath&gt;true&lt;/addClasspath&gt; &lt;!--下面必须指定好主类 如com.my.Main --&gt; &lt;mainClass&gt;Main&lt;/mainClass&gt; &lt;/manifest&gt; &lt;/archive&gt; &lt;descriptorRefs&gt; &lt;descriptorRef&gt;jar-with-dependencies&lt;/descriptorRef&gt; &lt;/descriptorRefs&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;make-my-jar-with-dependencies&lt;/id&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;single&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 右边执行 clean ，package 在 jar 包上可以直接重命名]]></content>
      <categories>
        <category>idea</category>
      </categories>
      <tags>
        <tag>intelj</tag>
        <tag>idea</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单例设计模式]]></title>
    <url>%2F2018%2F08%2F20%2FSingleDemo%2F</url>
    <content type="text"><![CDATA[单例设计模式：解决一个类中只存在一个对象单例设计模式特性：保证对象在内存中的唯一性： 为了避免其他程序创建过多对象，先禁止其他程序创建该类对象 为了让其他类访问到该对象，在本类中自定义一个对象 方便其他对象对自定义对象的访问，可以对外提供一些访问方式 用代码的方式实现对象在内存中唯一性： 将构造函数私有化 在类中创建一个本类对象 提供一个方法可以获取到该对象 单例模式使用方式：按平时的描述方式描述事物，加上 单例模式 的 3 步方式即可 单例设计模式饿汉式 java 代码实现：1234567891011121314151617181920class Single&#123; private Single()&#123;&#125;; //内置成员变化需要私有化 private static Single s = new Single(); /** 方法被调用的方法只有两种：对象、类名 因为该对象被私有化了，无法外部创建该方法，所以用类名调用 类名调用需要设置静态方法 静态方法只能访问静态成员，所以成员也需要静态 */ private Single getInstance()&#123; return s; &#125;&#125;class SingleDemo&#123; public static void main(String [] args)&#123; Single ss = Single.getInstance(); &#125;&#125; 栈中加载 main 函数 和 ss 方法区中有了 Single 的空间、静态的 s 变量、getInstance() 方法 堆中有了一个 new Single() 地址假设为 0x0015 方法区的 s 变量指向了 堆中 new Single() 的地址 0x0015 return s Single ss = Single.getInstance(); 使得 ss 也指向 0x0015 普通方式创建多个对象：1234567891011121314151617181920212223242526272829303132333435363738394041424344class Single&#123; private int num; public void setNum(int num)&#123; this.num = num; &#125; public int getNum()&#123; return num; &#125; //不设置私有化，可外部创建该对象 Single()&#123;&#125;; //单例模式下设置私有化，不可外部创建该对象 //private Single()&#123;&#125;; private static Single s = new Single(); private Single getInstance()&#123; return s; &#125;&#125;class SingleDemo&#123; public static void main(String [] args)&#123; //创建 2 个 Single 对象 Single s1 = new Single(); Single s2 = new Single(); //设置值为 30 s1.setNum(30); /**输出值为默认值 0 创建了两个对象，修改其中一个值跟另一个无关 */ System.out.println(s2.getNum()); /* ss2 的值为 23，表明 ss1 与 ss2 是同一个对象 单例模式内存中一个一个对象在执行，该对象有 3 个引用： SingleDemo 的 ss1、ss2 和 Single 中的 s */ //Single ss1 = Single.getInstance(); //Single ss2 = Single.getInstance(); //ss1.setNum(15); //System.out.println(ss2); &#125;&#125; 单例设计模式 懒汉式 java 代码123456789101112131415161718192021222324252627282930/*先初始化对象：称为 饿汉式Single 类一进内存，就已经创建好了对象class Single&#123; private Single()&#123;&#125;; private static Single s = new Single(); private Single getInstance()&#123; return s; &#125; &#125;*///对象在方法被调用时才初始化，也叫作对象的延时加载 称为 懒汉式//Single 类进内存，对象还没有存在，只有调用 getInstance() 方法时，才建立对象class Single&#123; private Single()&#123;&#125;; private static Single s = null; private Single getInstance()&#123; if(s==null)&#123; s = new Single(); &#125; return s; &#125; &#125;class SingleDemo&#123; public static void main(String [] args)&#123; Single ss = Single.getInstance(); &#125;&#125; 饿汉式：Single 类 加载进内存时，方法区就有 s，堆中就有对象，对象的地址值赋给 s 懒汉式：Single 类 加载进内存时，方法区 s 为空，当调用 getInstance() 方法时，才在内存中建立建立对象，将堆内存中的地址赋给 s，替换空值 懒汉式防止多个用户创建多个对象1234567891011121314151617class Single&#123; private Single()&#123;&#125;; private static Single s = null; //锁加载判断内部，提升效率 private Single getInstance()&#123; if(s==null)&#123; //加锁，防止创建多个对象 synchronized(Single.class)&#123; if(s==null)&#123; s = new Single(); &#125; &#125; &#125; return s; &#125; &#125;]]></content>
      <categories>
        <category>Design Patterns</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>Singleton Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring4x_2]]></title>
    <url>%2F2018%2F08%2F14%2FSpring4x-2%2F</url>
    <content type="text"><![CDATA[Spring 名词参考POJO：POJO（Plain Ordinary Java Object）简单的Java对象，实际就是普通JavaBeans，是为了避免和EJB混淆所创造的简称 使用POJO名称是为了避免和EJB混淆起来, 而且简称比较直接. 其中有一些属性及其getter setter方法的类,没有业务逻辑，有时可以作为VO(value -object)或dto(Data Transform Object)来使用.当然,如果你有一个简单的运算属性也是可以的,但不允许有业务方法,也不能携带有connection之类的方法。 教程参考 idea 创建 log4j 文件 Q&amp;AQ1:application context not configured for this file A: application context not configured for this file于spring框架使用中的原因 Q2: cvc-complex-type.2.4.c: 通配符的匹配很全面, 但无法找到元素 ‘tx:Advisor’ 的声明。 A: 在 smart-context.xml 中加入 Spring 引用 Q3:1Caused by: java.sql.SQLException: Access denied for user &apos;root&apos;@&apos;localhost&apos; (using password: YES) A: smart-context.xml 配置 数据库的用户密码错误 Q4:c:if 与 c:url 标签无效 A: accepted First add this to the top of your “.jsp” file: 1&lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot; prefix=&quot;c&quot; %&gt; It will still give syntax error but you can fix that by adding “javax.servlet:jstl:1.2” (without quotes) as a module dependency. To do that, follow these steps: Click your project name and press “F4” to bring up the module settings dialog. Then go to the “dependencies” tab in the “modules” section. Click the green “+” icon –&gt; library –&gt; new library –&gt; From Maven. Search for javax.servlet:jstl:1.2 in the search bar and press OK and it will download and add the above mentioned library as a module. Now you should not have any kind of syntax error. c:if标签 Cannot resolve symbol]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springAutoAssembly]]></title>
    <url>%2F2018%2F08%2F10%2FspringAutoAssembly%2F</url>
    <content type="text"><![CDATA[通过 Java 代码装配 bean通常组件扫描和自动化装配实现 Spring 的自动化配置，但是有时候例如要将第三方库中的组件装配到你的应用中，这种情况下没办法在它的类上添加 @Component 和 @Autowired 注解，就不能使用自动化配置了。 需要进行显示装配方式：java/XML java(javaConfig) 是比较好的方案，它更强大、类型安全、对重构友好，它是 java 代码，但是 JavaConfig 是配置代码，不应该包含任何业务逻辑，会将其放在单独的包中与其他应用程序逻辑分离开。 创建配置类如果去掉 CDPlayerConfig 的 @ComponentScan 注解，再次运行 CDPlayerTest 的话，测试会失败，出现异常。测试期望被注入CDPlayer 和 CompactDisc，但是这些 bean 没有被创建，组件扫描不会发现它们。 123456789package com.soundsystem;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;@Configuration//@ComponentScanpublic class CDPlayerConfig &#123;&#125; 声明简单的 bean在 JavaConfig 中声明 bean ，编写一个创建所需类型的实例的方法，给这个方法添加 @Bean 注解。 声明 CompactDisc bean : 1234@Beanpublic CompactDisc sgtPeppers()&#123; return new SgtPeppers();&#125; @Bean 注解告诉 Spring 这个方法返回一个对象，该对象要注册为 Spring 应用上下文中的 bean ，方法体中包含了最终产生 bean 实例的逻辑。 默认情况下，bean 的 id 跟带有@bean注解的方法名一样，本例中为 sgtPeppers，如果要重新设置可以通过name属性指定： 1234@Bean(name="lonelyHeartsClubBand")public CompactDisc sgtPeppers()&#123; return new SgtPeppers();&#125; 方法体返回了一个新的 SgtPeppers 实例，因为是java代码所以可以使用java提供的全部功能，只要最终能生成CompactDisc实例就行。 可以用 java的功能在一组 CD 中随机选择一个 CompactDisc 播放： 12345678910111213@Beanpublic CompactDisc randomBeatlesCD()&#123; int choice = (int)Math.floor(Math.random()*4); if(choice==0)&#123; return new WhiteAlbum(); &#125;else if(choice==1)&#123; return new SgtPeppers(); &#125;else if(choice==2)&#123; return new HardDaysNight(); &#125;else if(choice==3)&#123; return enw Revolver(); &#125;&#125; Spring中Bean及@Bean的理解 java 是面相对象，对象有方法和属性，需要对象实例来调用方法和属性（实例化），有方法或属性的类都需要实例化才能具象化地去使用这些方法和属性。bean 是类的代理，这样它就能代表类拥有该拥有的东西了。 注解： 使用 bean: 即是把已经在xml文件中配置好的Bean拿来用，完成属性、方法的组装；比如@Autowired , @Resource，可以通过byTYPE（@Autowired）、byNAME（@Resource）的方式获取Bean； 注册Bean: @Component , @Repository , @ Controller , @Service , @Configration这些注解都是把你要实例化的对象转化成一个Bean，放在IoC容器中，等你要用的时候，它会和上面的@Autowired , @Resource配合到一起，把对象、属性、方法完美组装。 @bean: 意思是@Bean明确地指示了一种方法，什么方法呢——产生一个bean的方法，并且交给Spring容器管理；从这我们就明白了为啥@Bean是放在方法的注释上了，因为它很明确地告诉被注释的方法，你给我产生一个Bean，然后交给Spring容器，剩下的你就别管了 Spring 注入： IOC 容器加载时会扫描 xml 文件中 bean 的配置，对这些 bean 进行实例化（初始化）。注入指在初始化一个实例的时候对这个实例的成员变量进行赋值。 借助 JavaConfig 实现注入当需要声明一个依赖于 CompactDisc 的 CDPlayer bean 时，可用如下方法在 JavaConfig 中进行装配： 引用创建 bean 的方法： 1234@Beanpublic CDPlayer cdPlayer()&#123; return new CDPlayer(sgtPeppers());&#125; 创建的 bean ID 为 cdPlayer，与方法名相同。cdPlayer() 方法没有使用默认的构造器构建实例，而是调用了需要传入 CompactDisc 对象的构造器来创建 CDPlayer 实例，但是它并不是通过调用 sgtPeppers() 方法得到的，sgtPeppers() 方法上添加了 @Bean 注解，所以 Spring 将会拦截所有对它的条用，会直接返回该方法所创建的 bean cdPlayer() 方法请求一个 CompactDisc 作为参数 1234@Beanpublic CDPlayer cdPlayer(CompactDisc compactDisc)&#123; return new CDPlayer(compactdisc);&#125; 不管 CompactDisc 使用什么方式创建出来的，Spring 都会将其传入到配置方法中，并用来创建 CDPlayer bean。以上构造器和下面的 Setter 方法只是 @Bean 的其中一些方法： 123456@Beanpublic CDPlayer cdPlayer(CompactDisc compactDisc)&#123; CDPlayer cdPlayer = new CDPlayer(compactDisc); cdPlayer.setCompactDisc(compactDisc) return cdPlayer;&#125; 声明一个简单的 属性注入（设值注入） 元素类似于 JavaConfig 的 @Bean 注解。 1234&lt;bean id="cdPlayer" class="soundsystem.CDPlayer"&gt; &lt;constructor-arg name="compactDisc" ref="compactDisc" /&gt;&lt;/bean&gt; 1234&lt;bean id="cdPlayer" class="soundsystem.CDPlayer"&gt; &lt;property name="compactDisc" ref="compactDisc" /&gt;&lt;/bean&gt; id 为 cdPlayer 的 CDPlayer 类，其中有一个名称为 compactDisc 的成员变量。 元素为属性的 Setter 方法所提供的功能与 元素为构造器所提供的功能相同。 通过 ref 属性，引用了 ID 为 compactDisc 的 bean，用 setCompactDisc() 方法将其注入到 compactDisc 属性中。所以 CDPlayer 中必须有 setCompactDisc() 的方法，由 IOC 容器自动调用方法进行赋值。]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>autoAssembly</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring 框架基础]]></title>
    <url>%2F2018%2F08%2F02%2Fspring%2F</url>
    <content type="text"><![CDATA[Spring 框架基础控制反转（Inversion of Control，缩写为IoC），是面向对象编程中的一种设计原则，可以用来减低计算机代码之间的耦合度。其中最常见的方式叫做依赖注入（Dependency Injection，简称DI），还有一种方式叫“依赖查找”（Dependency Lookup）。通过控制反转，对象在被创建的时候，由一个调控系统内所有对象的外界实体，将其所依赖的对象的引用传递给它。也可以说，依赖被注入到对象中。 IOC 是一种设计模式，原来创建对象的主动权和时间是由自己控制的，现在把需要使用的对象的创建，销毁的控制权交给别人（IOC容器），使用时直接获取，这种对象可以单例或多例。IOC 有利于降低耦合度。 依赖注入和控制反转的理解 AOP为Aspect Oriented Programming的缩写，意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。 idea 的简单 Spring 文件创建及测试 创建一个 project 勾选 Spring 及 web Application 创建 interface、实现接口类、配置类以及测试类 idea 创建测试类方法： 在 bean 同目录下创建一个 test 测试文件夹，同时按住 ctrl+shift+alt+s 调出 project structure 窗口，选择modules 栏中的 Sources 栏，选中创建 test 文件夹，在 Mark as 栏选择 Tests，将 Tests 文件夹作为 Test 文件创建的目录。 在 实现接口类的类名上 alt+enter 选择 create test，在 TestLibrary 选择 JUnit4， 如果出现 JUnit4 Library notfound in the module ，点击 fix 选择 Use ‘JUnit4’ from idea distribution 点 ok，在下方 Member 栏将方法选中，可创建该类方法的测试方法 在测试类文件中类的上方添加注释 @RunWith(SpringJUnit4ClassRunner.class) 以便在测试开始的时候自动创建 Spring 的应用上下文 添加注解 @ContextConfiguration(classes=CDPlayerConfig.class) 表示需要在 CDPlayerConfig 中加载配置，因为 CDPlayerConfig 类中包含了 @ComponentScan ，则最终引用上下文也会包含 CompactiDisc 的bean 在类中添加 注释 表示将 bean 注入到测试代码之中 12@Autowiredprivate CompactDisc cd; 一个简单的测试方法，断言测试 cd 属性不为 null ，表示 spring 能够发现 CompactDisc 类，能自动在 Spring 上下文中创建 bean 并将其注入到测试代码中 1234@Testpublic void cdShouldNotBeNull()&#123; assertNotNull(cd);&#125; 如果运行测试类报错 org.junit 不存在 导入com.springsource.org.junit-4.7.0.jar 包 如果不行则继续下面操作： ctrl + shift + alt + s 进入 project structure 窗口 ，在 Library 窗口 点击左边绿色的加号 -&gt; Java -&gt; 找到 IDEA 安装路径下的 Lib 中的junit-4.12 -&gt; 确定 ctrl + shift + t 在 测试 文件与 被测试 文件间切换 在类名上 alt + enter，选择 Create test，第一栏选择 Juint4 ，如果有提示 Juint 4 library not found in the module，点击右边的 fix ，选择默认的 Use ‘Juint4’ from Intellj IDEA distribution ，ok，下面选择需要创建的Before 或 After 测试方法，以及需要创建的自己的方法。 如果需要更换 test 测试类的文件存放位置，可以在 Project Structure（ctrl+alt+shift+s）中选择 module 中的 source ，选择一个文件夹作为 test 文件的存放位置。 idea 使用 Junit4 测试教程（需科学上网） idea 打开显示 Spring Configure check 解决方法 ​ 打开 Project Structure－&gt;Facets 配置。左侧 + 号，选择 Spring (添加 spring 配置文件的模块) ​ 右侧 + 号，勾选项目，会选中项目及其下的 xml 文件 (设置添加没有被映射的Spring配置文件)，点击应用即可 为组件扫描的 bean 命名Spring 应用上下文所有的 bean 一般都会根据类名指定一个 ID，将类名的第一个字母变为小写（SgtPeppers 设置为 sgtPeppers），如果要自己设置不同的 ID，则在 SgtPeppers 类注解 @Component 中配置 ID 名，如 1234@Component("lonelyHeartsClub")public class SgtPeppers implements CompactDisc&#123; ...&#125; 或者使用 @Named 注解也可以，但是通常使用 @Component 1234@Named("lonelyHeartsClub")public class SgtPeppers implements CompactDisc&#123; ...&#125; 设置组件扫描基础包如果没有为 @ComponentScan 设置任何属性，它会以配置类所在的包作为基础包（base package）来扫描组件（扫描）。如果想将装配类放在单独的包中跟其他的应用代码进行区分，那么默认基础包将不能满足要求。 为了指定不同的基础包，可以在 @ComponentScan 的 value 属性中指明包的名称： 1234@Configuration@ComponentScan("soundsystem)public class CDPlayerConfig &#123;&#125; 如果为了更清楚地表明设置的是基础包，可以通过 basePackages 属性进行配置： 1234@Configuration@ComponentScan(basePackages="soundsystem")public class CDPlayerConfig &#123;&#125; 若要设置多个基础包，可以将 basePackages 属性设置为需要扫描包的数组即可： 1234@Configuration@ComponentScan(basePackages="soundsystem","video")public class CDPlayerConfig &#123;&#125; 以上用 String 类型表示的基础包设置是类型不安全的(not type-safe)，如果重构代码的话，所指定的基础包可能会出错。 此时应用 @ComponentScan 指定包中所包含的类或接口,为 basePackageClasses 属性所设置的数组中包含了类，这些类所在的的包会作为组件扫描的基础包。 1234@Configuration@ComponentScan(basePackageClasses=(CDPlayer.class,DVDPlayer.class))public class CDPlayerConfig &#123;&#125; 为 bean 添加注解实现自动装配 CDPlayer 类中，给构造器添加 @Autowired 注解，表明当 Spring 创建 CDPlayer bean 时，会通过这个构造器来进行实例化，并且传入一个可设置给 CompactDisc 类型的 bean。 12345package com.soundsystem;public interface MediaPlayer &#123; void play();&#125; 1234567891011121314151617package com.soundsystem;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Component;@Componentpublic class CDPlayer implements MediaPlayer &#123; private CompactDisc cd; @Autowired public CDPlayer(CompactDisc cd)&#123; this.cd = cd; &#125; public void play()&#123; cd.play(); &#125;&#125; 该注解可用在构造器，也可用在属性的 Setter 方法上，CDPlayer 有一个 setCompactDisc() 方法，可以采用如下的注解装配： 1234@Autowired public void setCompactDisc(CompactDisc cd)&#123; this.cd = cd; &#125; 在 Spring 初始化 bean 后，它会尽可能满足 bean 的依赖，本例中的依赖是通过带有 @Autowired 注解声明的，@Autowired 能在构造器、Setter 方法，或者其他方法上发挥同样的作用，Spring 都会去满足方法参数上所声明的依赖。 如果有且只有一个 bean 匹配依赖需求的话，那么这个 bean 会被装配进来。但没有匹配 bean 的情况下，在应用上下文创建的时候，Spring 会抛出一个异常，为了避免异常出现可以将 @Autowired 的 required 属性设置为 false，同时代码中需进行 null 检查。 如果有多个 bean 满足依赖关系 Spring 会抛出一个异常。 Autowired 是 Spring 特有注解，可以选择 @Inject 注解（源自 Java 依赖注入规范）代替。 验证自动装配 System Rules 库 Java 单元测试如何断言(检查)控制台输出 注入 CompactDisc ，注入 CDPlayer bean 到测试代码的 player 成员变量之中（为更通用的 MediaPlayer 类型），在 play 测试方法中，可以调用 CDPlayer 的 player() 方法，断言其行为与你的预期一致 123456789101112131415161718192021222324252627282930313233343536package com.soundsystem;import static org.junit.Assert.*;import org.junit.Rule;import org.junit.Test;import org.junit.contrib.java.lang.system.StandardOutputStreamLog;import org.junit.contrib.java.lang.system.SystemOutRule;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import static org.junit.Assert.*;@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(classes=CDPlayerConfig.class)public class CDPlayerTest &#123; @Rule public final SystemOutRule log = new SystemOutRule(); @Autowired private MediaPlayer player; @Autowired private CompactDisc cd; @Test void cdShouldNotBeNull()&#123; assertNotNull(cd); &#125; @Test public void play() &#123; player.play(); assertEquals( "playing Sgt. Pepper's Lonely Hearts Club Band" + "by The Beatles\n", log.getLog(); ); &#125;&#125; Q&amp;AQ:idea 无法导入 jdbcjdbcDaosupportA: 解决 Project Structure－&gt;Facets 配置。添加spring配置文件的模块 参考： https://blog.csdn.net/tiantiandjava/article/details/41204607 Caused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name ‘accountService’ defined in class path resource [applicationContext.xml]: Initialization of bean failed; nested exception is org.springframework.beans.ConversionNotSupportedException: Failed to convert property value of type ‘com.mchange.v2.c3p0.ComboPooledDataSource’ to required type ‘cn.itcast.dao.AccountDao’ for property ‘ad’; nested exception is java.lang.IllegalStateException: Cannot convert value of type ‘com.mchange.v2.c3p0.ComboPooledDataSource’ to required type ‘cn.itcast.dao.AccountDao’ for property ‘ad’: no matching editors or conversion strategy found xml 配置中需要将 accountDao 注入到 accountService ， 将 dataSource（连接池） 注入到 accountDao Q:BeanCreationExceptionCaused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name ‘transactionManager’ defined in class path resource [applicationContext.xml]: BeanPostProcessor before instantiation of bean failed; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name ‘org.springframework.aop.support.DefaultBeanFactoryPointcutAdvisor#0’: Cannot resolve reference to bean ‘txPc’ while setting bean property ‘pointcut’; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name ‘txPc’: Lookup method resolution failed; nested exception is java.lang.IllegalStateException: Failed to introspect Class [org.springframework.aop.aspectj.AspectJExpressionPointcut] from ClassLoader [sun.misc.Launcher$AppClassLoader@b4aac2] Caused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name ‘org.springframework.aop.support.DefaultBeanFactoryPointcutAdvisor#0’: Cannot resolve reference to bean ‘txPc’ while setting bean property ‘pointcut’; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name ‘txPc’: Lookup method resolution failed; nested exception is java.lang.IllegalStateException: Failed to introspect Class [org.springframework.aop.aspectj.AspectJExpressionPointcut] from ClassLoader [sun.misc.Launcher$AppClassLoader@b4aac2] Caused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name ‘txPc’: Lookup method resolution failed; nested exception is java.lang.IllegalStateException: Failed to introspect Class [org.springframework.aop.aspectj.AspectJExpressionPointcut] from ClassLoader [sun.misc.Launcher$AppClassLoader@b4aac2] A:加粗语句表示缺少 jar 包 aspectjweaver.jar 下载导入此 jar 包即可]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
        <tag>IOC</tag>
        <tag>依赖</tag>
        <tag>注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis_Reply 微信自动回复]]></title>
    <url>%2F2018%2F07%2F30%2FMyBatis-Reply%2F</url>
    <content type="text"><![CDATA[实现输入关键字微信自动回复的功能添加一对多关系配置创建 command 与关联数据库 12create table command(id int primary key , name varchar(16) , description varchar(16));create table command_content (id int primary key , content varchar(2048) , command_id int, foreign key(command_id) references command(id) on delete cascade on update cascade); 查询主表的实体，将查询 sql 语句放在主表对应的 xml 文件中，将查询出的数据填充到主表对应的属性中，同时填充子表的列表 left join COMMAND_CONTENT 关联附表 COMMAND a COMMAND_CONTENT b 给表取别名，主表为 a ；附表为 b a.ID C_ID 给 a 表 ID 取别名为 C_ID 1select a.ID C_ID,a.NAME,a.DESCRIPTION,b.Id,b.CONTENT,b.COMMAND_ID from COMMAND a left join COMMAND_CONTENT b on a.ID=b.COMMAND_ID mybatis 取属性名时，用的是 ResultSet 的 getMetaData().getColumnName(column); 方法 不会取到 a.ID 的 a 前缀 如果创建了不存在的 主表 id 对应 command_id 则无法再创建新的 column 空语句可以产生提示，有了内容就无法发送 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253HTTP Status 500 – Internal Server ErrorType Exception ReportDescription The server encountered an unexpected condition that prevented it from fulfilling the request.Exceptionorg.apache.ibatis.exceptions.PersistenceException: ### Error querying database. Cause: java.lang.IllegalArgumentException: Result Maps collection does not contain value for CommandContent.Content### The error may exist in com/imooc/config/sqlxml/Command.xml### The error may involve Command.queryCommandList### The error occurred while handling results### SQL: select a.ID C_ID,a.NAME,a.DESCRIPTION,b.Id,b.CONTENT,b.COMMAND_ID from COMMAND a left join COMMAND_CONTENT b on a.ID=b.COMMAND_ID### Cause: java.lang.IllegalArgumentException: Result Maps collection does not contain value for CommandContent.Content org.apache.ibatis.exceptions.ExceptionFactory.wrapException(ExceptionFactory.java:30) org.apache.ibatis.session.defaults.DefaultSqlSession.selectList(DefaultSqlSession.java:150) org.apache.ibatis.session.defaults.DefaultSqlSession.selectList(DefaultSqlSession.java:141) com.imooc.dao.CommandDao.queryCommandList(CommandDao.java:34) com.imooc.service.QueryService.queryByCommand(QueryService.java:53) com.imooc.servlet.AutoReplyServlet.doGet(AutoReplyServlet.java:18) javax.servlet.http.HttpServlet.service(HttpServlet.java:635) javax.servlet.http.HttpServlet.service(HttpServlet.java:742) org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52)Root Causejava.lang.IllegalArgumentException: Result Maps collection does not contain value for CommandContent.Content org.apache.ibatis.session.Configuration$StrictMap.get(Configuration.java:888) org.apache.ibatis.session.Configuration.getResultMap(Configuration.java:640) org.apache.ibatis.executor.resultset.DefaultResultSetHandler.getNestedResultMap(DefaultResultSetHandler.java:1011) org.apache.ibatis.executor.resultset.DefaultResultSetHandler.applyNestedResultMappings(DefaultResultSetHandler.java:945) org.apache.ibatis.executor.resultset.DefaultResultSetHandler.getRowValue(DefaultResultSetHandler.java:918) org.apache.ibatis.executor.resultset.DefaultResultSetHandler.handleRowValuesForNestedResultMap(DefaultResultSetHandler.java:881) org.apache.ibatis.executor.resultset.DefaultResultSetHandler.handleRowValues(DefaultResultSetHandler.java:328) org.apache.ibatis.executor.resultset.DefaultResultSetHandler.handleResultSet(DefaultResultSetHandler.java:303) org.apache.ibatis.executor.resultset.DefaultResultSetHandler.handleResultSets(DefaultResultSetHandler.java:196) org.apache.ibatis.executor.statement.PreparedStatementHandler.query(PreparedStatementHandler.java:64) org.apache.ibatis.executor.statement.RoutingStatementHandler.query(RoutingStatementHandler.java:79) org.apache.ibatis.executor.SimpleExecutor.doQuery(SimpleExecutor.java:63) org.apache.ibatis.executor.BaseExecutor.queryFromDatabase(BaseExecutor.java:326) org.apache.ibatis.executor.BaseExecutor.query(BaseExecutor.java:156) org.apache.ibatis.executor.CachingExecutor.query(CachingExecutor.java:109) org.apache.ibatis.executor.CachingExecutor.query(CachingExecutor.java:83) org.apache.ibatis.session.defaults.DefaultSqlSession.selectList(DefaultSqlSession.java:148) org.apache.ibatis.session.defaults.DefaultSqlSession.selectList(DefaultSqlSession.java:141) com.imooc.dao.CommandDao.queryCommandList(CommandDao.java:34) com.imooc.service.QueryService.queryByCommand(QueryService.java:53) com.imooc.servlet.AutoReplyServlet.doGet(AutoReplyServlet.java:18) javax.servlet.http.HttpServlet.service(HttpServlet.java:635) javax.servlet.http.HttpServlet.service(HttpServlet.java:742) org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52)Note The full stack trace of the root cause is available in the server logs.Apache Tomcat/8.5.29 原因：在 Command.xml 中的 collention 属性的 ResultMap 引用 CommandContent.xml 下的 id ,引用名错误 方法：(CommandContent.ResultMap).id=”Content” (Command.Collection)ResultMap=”CommandContent.Content” 如果没有在 Configuration.xml 文件中引入 CommandContent.xml 与 Command.xml 也会产生该错误 mybatis 一对多关系的配置数据库子表内含“段子”关键词的多个内容，对应主表的“段子”的 id 。每次用户发送”段子“时，取出其中的所有内容，拼接进查询服务 QueryService 中创建的 (List)contentList 集合中，再创建随机数返回其中一条内容 12345678910111213&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;!--类似于 java package 的用法，用来区分不同项目,namespace 必须添加--&gt;&lt;!--作为子表包含具体多个内容对应主表的一个 id 然后被主表所引用--&gt;&lt;mapper namespace="CommandContent"&gt; &lt;resultMap type="com.imooc.bean.CommandContent" id="Content"&gt; &lt;id column="ID" jdbcType="INTEGER" property="id"/&gt; &lt;result column="CONTENT" jdbcType="VARCHAR" property="content"/&gt; &lt;result column="COMMAND_ID" jdbcType="VARCHAR" property="commandId"/&gt; &lt;/resultMap&gt;&lt;/mapper&gt; 1234567891011121314151617181920212223242526272829303132&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;!--类似于 java package 的用法，用来区分不同项目,namespace 必须添加--&gt;&lt;mapper namespace="Command"&gt;&lt;!--要反应一个一对多关系，需要用到在主表中引用子表列表的集合,引用CommandContent.xml 中的 Content 属性--&gt; &lt;resultMap type="com.imooc.bean.Command" id="Command"&gt; &lt;id column="C_ID" jdbcType="INTEGER" property="id"/&gt; &lt;result column="NAME" jdbcType="VARCHAR" property="name"/&gt; &lt;result column="DESCRIPTION" jdbcType="VARCHAR" property="description"/&gt; &lt;collection property="contentList" resultMap="CommandContent.Content"/&gt; &lt;/resultMap&gt; &lt;!--查询主表同时关联子表--&gt; &lt;select id="queryCommandList" parameterType="com.imooc.bean.Command" resultMap="Command"&gt; select a.ID C_ID,a.NAME,a.DESCRIPTION,b.Id,b.CONTENT,b.COMMAND_ID from COMMAND a left join COMMAND_CONTENT b on a.ID=b.COMMAND_ID &lt;!--where 关键字指，在其中的 if 语句都不满足条件则不输出 where 关键字，反之，有一个 if 满足则输出 where + if 中语句--&gt; &lt;!--where 还能将 if 拼接的 sql 语句最前端的 and 去掉，防止语句不准确--&gt; &lt;where&gt; &lt;if test="name != null &amp;amp;&amp;amp; !&amp;quot;&amp;quot;.equals(name.trim()) "&gt; and a.NAME=#&#123;name&#125; &lt;/if&gt; &lt;if test="description != null and !&amp;quot;&amp;quot;.equals(description.trim()) "&gt; and a.DESCRIPTION like '%' #&#123;description&#125; '%' &lt;/if&gt; &lt;/where&gt; &lt;/select&gt;&lt;/mapper&gt; 以上两个 xml 要引入到 Configuration.xml 中 将原来的单条信息查询改为一对多的数据查询1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package com.imooc.service;import com.imooc.bean.Command;import com.imooc.bean.CommandContent;import com.imooc.bean.Message;import com.imooc.dao.CommandDao;import com.imooc.dao.MessageDao;import com.imooc.util.Iconst;import java.util.List;import java.util.Random;public class QueryService &#123; //调用 MessageDao 进行数据操作，再由 ListServlet 调用。将值返回给 ListServlet public List&lt;Message&gt; queryMessageList(String command, String description)&#123; MessageDao messageDao = new MessageDao(); return messageDao.queryMessageList(command,description); &#125; /** * 通过指令查询自动回复内容 */ public String queryByCommand(String command)&#123;// MessageDao messageDao = new MessageDao(); CommandDao commandDao = new CommandDao();// List&lt;Message&gt; messageList; List&lt;Command&gt; commandList; if(Iconst.HELP_COMMAND.equals(command))&#123;// 如果指令是帮助，则将所有指令查出来并拼接；// messageList = messageDao.queryMessageList(null, null); commandList = commandDao.queryCommandList(null, null); StringBuilder result = new StringBuilder();// for(int i= 0;i &lt; messageList.size();i++)&#123; for(int i= 0;i &lt; commandList.size();i++)&#123; //如果不是第一行则添加换行 if(i !=0)&#123; result.append("&lt;br/&gt;"); &#125;// 拼接所有查询出来的指令及描述// result.append("回复[" + messageList.get(i).getCommand() + "]可以查看"// + messageList.get(i).getDescription()); result.append("回复[" + commandList.get(i).getName() + "]可以查看" + commandList.get(i).getDescription()); &#125; return result.toString(); &#125; //只需要通过指令，不需要描述来查询自动回复,如果为 null 则不进入 if 判断语句，不会添加 and sql 语句// messageList = messageDao.queryMessageList(command, null);// if(messageList.size() &gt; 0)&#123;// return messageList.get(0).getContent();// &#125; commandList = commandDao.queryCommandList(command, null); if(commandList.size() &gt; 0)&#123; //取得第一条查询语句的 子表集合内容/列表信息 List&lt;CommandContent&gt; contentList = commandList.get(0).getContentList(); //取得列表信息其中一条返回 //取 [0,size()) 的随机数 int i = new Random().nextInt(contentList.size());// 取得随机的 commandContent 的对象，然后从对象中取得内容 return contentList.get(i).getContent(); &#125; //当指令没有匹配的回复内容时，用此内容替代 return Iconst.NO_MATCHING_CONTENT; &#125;&#125; 自动回复 servlet 将跳转功能转换为 写查询返回语句的功能 123456789101112131415161718192021222324252627package com.imooc.servlet;import com.imooc.service.QueryService;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;public class AutoReplyServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; resp.setContentType("text/html;charset=utf-8"); PrintWriter out = resp.getWriter(); QueryService queryService = new QueryService(); out.write(queryService.queryByCommand(req.getParameter("content"))); out.flush(); out.close(); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; this.doGet(req,resp); &#125;&#125; 常用标签 where 标签 where标签 在其中的 if 语句都不满足条件则不输出 where 关键字，反之，有一个 if 满足则输出 where + if 中语句where 还能将 if 拼接的 sql 语句最前端的 and 去掉，防止语句不准确 123456select ID,COMMAND,DESCRIPTION,CONTENT from MESSAGE where 1=1 &lt;if test="command != null &amp;amp;&amp;amp; !&amp;quot;&amp;quot;.equals(command.trim()) "&gt; and COMMAND=#&#123;command&#125; &lt;/if&gt; &lt;if test="description != null and !&amp;quot;&amp;quot;.equals(description.trim()) "&gt; and DESCRIPTION like '%' #&#123;description&#125; '%' &lt;/if&gt; 去掉 where 1=1 ，但是加上 where 标签即可 1234567select ID,COMMAND,DESCRIPTION,CONTENT from MESSAGE&lt;where&gt; &lt;if test="command != null &amp;amp;&amp;amp; !&amp;quot;&amp;quot;.equals(command.trim()) "&gt; and COMMAND=#&#123;command&#125; &lt;/if&gt; &lt;if test="description != null and !&amp;quot;&amp;quot;.equals(description.trim()) "&gt; and DESCRIPTION like '%' #&#123;description&#125; '%' &lt;/if&gt;&lt;/where&gt; include 引用标签 1select ID,COMMAND,DESCRIPTION,CONTENT from MESSAGE 语句能用以下语法代替 12select &lt;include refid="columns"/&gt; from MESSAGE&lt;sql id="columns"&gt;ID,COMMAND,DESCRIPTION,CONTENT&lt;/sql&gt; set 标签 修改升级数据库的功能 1update MESSAGE set COMMAND=#&#123;command&#125;,DESCRIPTION=#&#123;description&#125; update 标签 为了使 sql 语句结尾的 ‘,’ 不多余加入了 set 标签，效果跟 where 去 and 类似，能去掉语句最后多余的 ‘,’ 123456789101112&lt;update id=""&gt; &lt;set&gt; update MESSAGE set &lt;if test="command != null &amp;amp;&amp;amp; !&amp;quot;&amp;quot;.equals(command.trim()) "&gt; COMMAND=#&#123;command&#125;, &lt;/if&gt; &lt;if test="description != null and !&amp;quot;&amp;quot;.equals(description.trim()) "&gt; and DESCRIPTION=#&#123;description&#125;, &lt;/if&gt; COMMAND=#&#123;command&#125;,DESCRIPTION=#&#123;description&#125; &lt;/set&gt;&lt;/update&gt; trim标签 trim 标签中的 prefix 属性，表示前缀，可以等于 where/set…（可自定义）如果各种判断结束有字符串输出就加入 where/set… trim 标签中的 suffix 属性，表示后面，可以加 test 或自定义 ，如果 if 中有内容输出就在最后加一个 test trim 标签的 prefixOverride 属性，表示删除前面内容，例如 prefixOverride=”and/or” 如果在前面出现了and 与 or 则切掉，同理 suffixOverride=”,” 可以去除结尾的 ‘,’ 12345当 prefix 值为 where 且能去掉首部的 and/or，该 trim 能替换 where 标签&lt;trim prefix="where" prefixOverride="and/or"&gt;&lt;/trim&gt;同理当 prefix 值为 set 且去掉尾部的 ','，该 trim 能替换 set 标签&lt;trim prefix="set" suffixOverride=","&gt;&lt;/trim&gt; choose 标签 chosse when 相当于 java 中的 else if，又或者是 switch case choose otherwise 相当于 else，或者是 default 123456789101112131415161718select ID,COMMAND,DESCRIPTION,CONTENT from MESSAGE&lt;where&gt; &lt;if test="command != null &amp;amp;&amp;amp; !&amp;quot;&amp;quot;.equals(command.trim()) "&gt; and COMMAND=#&#123;command&#125; &lt;/if&gt; &lt;if test="description != null and !&amp;quot;&amp;quot;.equals(description.trim()) "&gt; and DESCRIPTION like '%' #&#123;description&#125; '%' &lt;/if&gt; &lt;choose&gt; &lt;when test=""&gt; &lt;/when&gt; &lt;when test=""&gt; &lt;/when&gt; &lt;when test=""&gt; &lt;/when&gt; &lt;when test=""&gt; &lt;/when&gt; &lt;otherwise&gt;&lt;/otherwise&gt; &lt;/choose&gt;&lt;/where&gt; association 标签 需要根据子表内容查询相关联的主表内容，association 与 collection 标签相似 。 property 为 bean 中主表实体的引用，resultMap 指向主表的 nameSpace.(resultMap 的 id) 1&lt;association property="command" resultMap="Command.Command"/&gt; 标签总结 定义 sql 语句 insert，delete，update，select 配置 java 对象属性与查询结果集中列名的对应关系（列名不是数据库表中的列名，而是查询结果集的列名） resultMap 动态拼接 sql 语句 foreach，if，choose 格式化输出（动态拼接 sql 语句不符合 sql 语法，对该语法进行格式化） where，set，trim 配置关联关系（一对多，多对一） collention，association 常量标签（可在需要地方引用他） sql 引用标签（引用常量标签） include resultMap 使用标签配置对应关系，结果集列名与 java 类属性名可以不相同，有 typeHandler 可以配置字符集 resultType 不需要进行配置，但是结果集中的列名与 java 类中的属性名相同 parameterType 与 ognl 表达式相关联 #{} parameterMap 与 resultMap 相似，需要指向 ParameterMap 标签配置的映射关系的 id 。表示参数中的属性与数据库列的对应关系。 以 Map 结尾表示映射，需要配置映射关系 Type 结尾表示类型，resultType 与 parameterType 原名 resultClass 与 parameterClass，与 java 类类似 #{} 被 mybatis 解析为 ？，然后被 preparedStatement 赋值为 ‘段子’，有预编译效果，一半采用该方法 ${} 直接被 mybatis 拼接 字符串 （String）段子，没有引号，需要自己添加单引号 ‘${command}’ ${} 一般用于取直接从页面上传过来的列名进行操作 常见错误 sql 语法错误：使用 log4j 查看拼接后的 sql 语句，将其复制到 nativeMysql 中，将值赋给 ？的占位符，进行 sql 语句的判断 注解型 sql 比 配置型 sql 方便，但是有局限性 编码问题 ：文件本身编码、jsp 设置编码、servlet 接受页面传值，用来转换的编码、用 get 方式提交中文时，tomcat 也要配置编码 网页乱码 : 在talk.jsp上方加上 12&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt;&lt;%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c" %&gt; 若以上全部配置好，而与数据库交互出现乱码，则在 Configuration.xml 写连接数据库的 url 时，就需要加上编码方式、建立数据库与建表时的编码也需要注意获取自增主键值： useGeneratedKeys : 表示插入到这张表时采用生成的主键,而不是自己指定一个主键，Command 这个类的其他属性值来自于页面，而 id 是自增的，所以页面中没有 id 值 keyProperty : mybatis 会取到新增数据的主键，keyProperty 用来告诉 mybatis 将主键存到 Command 对象的哪一个属性中，这里的主键应该是 id. 在 Command 对象传入 xml 时，id 是没有值的，在 sqlSession 调用配置中 sql 语句执行完后，id 就有值了 在talk.jsp上方加上 12&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt;&lt;%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c" %&gt; 123&lt;insert id="insert" userGeneratedKeys="ture" property="id" parameterType="com.imooc.bran.Command"&gt; insert into COMMAND(NAME,DESCRIPTION) value(#&#123;name&#125;,#&#123;description&#125;)&lt;/insert&gt; 向 js 文件中传地址： 添加一个隐藏块，通过 id 与 value 向 js 中传入 basePath 的值 idea rename 一个类： 在一个类上右键 refactor → rename → 修改类名 → 取消 Search in Comments and strings (在评论和字符串中搜索) 跟 Search for textoccurrences (搜索文本事件) → 选择 variable name 点击 ok 即可 如果不取消 2 个勾选，rename 会无效。 选择 variable name 会使得子类重命名在调用该类对象的对象名]]></content>
      <categories>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>MyBatis</tag>
        <tag>autoReply</tag>
        <tag>weChat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jdbcToMyBatis]]></title>
    <url>%2F2018%2F07%2F25%2FjdbcToMyBatis%2F</url>
    <content type="text"><![CDATA[css 设置不显示问题： 将 resources 放入了 WEB-INF 文件夹中（这文件夹中的内容只能根据内部跳转或重定向等网页操作才能访问，不能直接访问） request.getContextPath() 获取的是上下文路径。是你的web项目的根路径，就是 webContent (MyEclipse中是webRoot) 或者 idea 中的 web 路径 拼装当前网页相对路径 url-pattern 配置 此文为 jdbc 版，如已了解直接转至 mybatis版 第一版大体框架 123456789101112131415161718192021222324package com.imooc.servlet;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;/** * 列表页面初始化控制 */@WebServlet(name="ListServlet" ,urlPatterns = "/List.action")public class ListServlet extends HttpServlet&#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; req.getRequestDispatcher("/WEB-INF/jsp/back/list.jsp").forward(req,resp); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; this.doGet(req, resp); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;&lt;%--拼接当前网页相对路径--%&gt;&lt;% String path = request.getContextPath(); String basePath = request.getScheme()+"://"+request.getServerName()+":"+request.getServerPort()+path;%&gt;&lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /&gt;&lt;meta http-equiv="X-UA-Compatible"content="IE=9; IE=8; IE=7; IE=EDGE" /&gt;&lt;title&gt;内容列表页面&lt;/title&gt;&lt;%--css 文件的相对路径--%&gt;&lt;link href="resources/css/all.css" rel="stylesheet" type="text/css" /&gt;&lt;/head&gt;&lt;body style="background: #e1e9eb;"&gt; &lt;form action="" id="mainForm" method="post"&gt; &lt;div class="right"&gt; &lt;div class="current"&gt;当前位置：&lt;br/&gt; &lt;a href="javascript:void(0)" style="color:#6E6E6E;"&gt; 内容管理 &lt;/a&gt; &amp;gt; 内容列表 &lt;/div&gt; &lt;div class="rightCont"&gt; &lt;p class="g_title fix"&gt;内容列表 &lt;a class="btn03" href="#"&gt;新 增&lt;/a&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;a class="btn03" href="#"&gt;删 除&lt;/a&gt; &lt;/p&gt; &lt;table class="tab1"&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td width="90" align="right"&gt;演示字段1：&lt;/td&gt; &lt;td&gt; &lt;input type="text" class="allInput" value=""/&gt; &lt;/td&gt; &lt;td width="90" align="right"&gt;演示字段2：&lt;/td&gt; &lt;td&gt; &lt;input type="text" class="allInput" value=""/&gt; &lt;/td&gt; &lt;td width="85" align="right"&gt; &lt;input type="submit" class="tabSub" value="查 询" /&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;div class="zixun fix"&gt; &lt;table class="tab2" width="100%"&gt; &lt;tbody&gt; &lt;tr&gt; &lt;th&gt;&lt;input type="checkbox" id="all" onclick="#"/&gt;&lt;/th&gt; &lt;th&gt;序号&lt;/th&gt; &lt;th&gt;演示字段1&lt;/th&gt; &lt;th&gt;演示字段2&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;input type="checkbox" /&gt;&lt;/td&gt; &lt;td&gt;1&lt;/td&gt; &lt;td&gt;演示值1&lt;/td&gt; &lt;td&gt;演示值2&lt;/td&gt; &lt;td&gt; &lt;a href="#"&gt;修改&lt;/a&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;a href="#"&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr style="background-color:#ECF6EE;"&gt; &lt;td&gt;&lt;input type="checkbox" /&gt;&lt;/td&gt; &lt;td&gt;2&lt;/td&gt; &lt;td&gt;演示值1&lt;/td&gt; &lt;td&gt;演示值2&lt;/td&gt; &lt;td&gt; &lt;a href="#"&gt;修改&lt;/a&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;a href="#"&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;input type="checkbox" /&gt;&lt;/td&gt; &lt;td&gt;3&lt;/td&gt; &lt;td&gt;演示值1&lt;/td&gt; &lt;td&gt;演示值2&lt;/td&gt; &lt;td&gt; &lt;a href="#"&gt;修改&lt;/a&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;a href="#"&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr style="background-color:#ECF6EE;"&gt; &lt;td&gt;&lt;input type="checkbox" /&gt;&lt;/td&gt; &lt;td&gt;4&lt;/td&gt; &lt;td&gt;演示值1&lt;/td&gt; &lt;td&gt;演示值2&lt;/td&gt; &lt;td&gt; &lt;a href="#"&gt;修改&lt;/a&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;a href="#"&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;div class='page fix'&gt; 共 &lt;b&gt;4&lt;/b&gt; 条 &lt;a href='###' class='first'&gt;首页&lt;/a&gt; &lt;a href='###' class='pre'&gt;上一页&lt;/a&gt; 当前第&lt;span&gt;1/1&lt;/span&gt;页 &lt;a href='###' class='next'&gt;下一页&lt;/a&gt; &lt;a href='###' class='last'&gt;末页&lt;/a&gt; 跳至&amp;nbsp;&lt;input type='text' value='1' class='allInput w28' /&gt;&amp;nbsp;页&amp;nbsp; &lt;a href='###' class='go'&gt;GO&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011121314151617181920212223&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd" version="3.1"&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt;/*此处可用 servlet 中的注释代替*/ &lt;!--&lt;servlet&gt;--&gt; &lt;!--&lt;servlet-name&gt;ListServlet&lt;/servlet-name&gt;--&gt; &lt;!--&lt;servlet-class&gt;com.imooc.servlet.ListServlet&lt;/servlet-class&gt;--&gt; &lt;!--&lt;/servlet&gt;--&gt; &lt;!--&lt;servlet-mapping&gt;--&gt; &lt;!--&lt;servlet-name&gt;ListServlet&lt;/servlet-name&gt;--&gt; &lt;!--访问 http://localhost:8080/List.action 后跳转到 list.jsp 页面--&gt; &lt;!--&lt;url-pattern&gt;/List.action&lt;/url-pattern&gt;--&gt; &lt;!--&lt;/servlet-mapping&gt;--&gt;&lt;/web-app&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package com.imooc.bean;public class Message &#123; /** * 主键 */ private String id; /** * 指令名称 */ private String command; /** * 描述 */ private String description; /** * 内容 */ private String content; public String getId() &#123; return id; &#125; public void setId(String id) &#123; this.id = id; &#125; public String getCommand() &#123; return command; &#125; public void setCommand(String command) &#123; this.command = command; &#125; public String getDescription() &#123; return description; &#125; public void setDescription(String description) &#123; this.description = description; &#125; public String getContent() &#123; return content; &#125; public void setContent(String content) &#123; this.content = content; &#125;&#125; 第一版完善 完善 list.jsp 及 ListSerlvet.java 的相关部分 sql 语句 1234567891011//sql preparedstatement 语句// ? 占位符// 用缺省值的方式，使用 List 在后面遍历填充字段信息比较方便stringsql = "select * from people p where p.id = ? and p.name = ?";preparedstatement ps = connection.preparestatement(sql);//设置缺省值的值//index 的值从 1 开始ps.setint(1,id);ps.setstring(2,name);//执行 sql 语句resultset rs = ps.executequery(); list.jsp 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;&lt;%--使用 jstl--%&gt;&lt;%@taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %&gt;&lt;%--拼接当前网页相对路径--%&gt;&lt;% String path = request.getContextPath(); String basePath = request.getScheme()+"://"+request.getServerName()+":"+request.getServerPort()+path;%&gt;&lt;html xmlns="http://www.w3.org/1999/xhtml"&gt; &lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /&gt; &lt;meta http-equiv="X-UA-Compatible"content="IE=9; IE=8; IE=7; IE=EDGE" /&gt; &lt;title&gt;内容列表页面&lt;/title&gt; &lt;%--css 文件的相对路径--%&gt; &lt;link href="&lt;%=basePath%&gt;/resources/css/all.css" rel="stylesheet" type="text/css" /&gt; &lt;/head&gt; &lt;body style="background: #e1e9eb;"&gt; &lt;%--提交到 ListServlet 上进行初始化与查询--%&gt; &lt;form action="&lt;%=basePath%&gt;/List.action" id="mainForm" method="post"&gt; &lt;div class="right"&gt; &lt;div class="current"&gt;当前位置：&lt;a href="javascript:void(0)" style="color:#6E6E6E;"&gt;内容管理&lt;/a&gt; &amp;gt; 内容列表&lt;/div&gt; &lt;div class="rightCont"&gt; &lt;p class="g_title fix"&gt;内容列表 &lt;a class="btn03" href="#"&gt;新 增&lt;/a&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;a class="btn03" href="#"&gt;删 除&lt;/a&gt;&lt;/p&gt; &lt;table class="tab1"&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td width="90" align="right"&gt;指令名称：&lt;/td&gt; &lt;td&gt; &lt;input name="command" type="text" class="allInput" value="$&#123;command&#125;"/&gt; &lt;/td&gt; &lt;td width="90" align="right"&gt;描述：&lt;/td&gt; &lt;td&gt; &lt;input name="description" type="text" class="allInput" value="$&#123;description&#125;"/&gt; &lt;/td&gt; &lt;td width="85" align="right"&gt;&lt;input type="submit" class="tabSub" value="查 询" /&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;div class="zixun fix"&gt; &lt;table class="tab2" width="100%"&gt; &lt;tbody&gt; &lt;tr&gt; &lt;th&gt;&lt;input type="checkbox" id="all" onclick="#"/&gt;&lt;/th&gt; &lt;th&gt;序号&lt;/th&gt; &lt;th&gt;演示字段1&lt;/th&gt; &lt;th&gt;演示字段2&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;c:forEach items="$&#123;messageList&#125;" var="message" varStatus="status"&gt; &lt;tr &lt;c:if test="$&#123;status.index % 2 != 0&#125;"&gt;style='background-color:#ECF6EE;'&lt;/c:if&gt;&gt; &lt;td&gt;&lt;input type="checkbox" /&gt;&lt;/td&gt; &lt;td&gt;$&#123;status.index + 1&#125;&lt;/td&gt; &lt;td&gt;$&#123;message.command&#125;&lt;/td&gt; &lt;td&gt;$&#123;message.description&#125;&lt;/td&gt; &lt;td&gt; &lt;a href="#"&gt;修改&lt;/a&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;a href="#"&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;div class='page fix'&gt; 共 &lt;b&gt;4&lt;/b&gt; 条 &lt;a href='###' class='first'&gt;首页&lt;/a&gt; &lt;a href='###' class='pre'&gt;上一页&lt;/a&gt; 当前第&lt;span&gt;1/1&lt;/span&gt;页 &lt;a href='###' class='next'&gt;下一页&lt;/a&gt; &lt;a href='###' class='last'&gt;末页&lt;/a&gt; 跳至&amp;nbsp;&lt;input type='text' value='1' class='allInput w28' /&gt;&amp;nbsp;页&amp;nbsp; &lt;a href='###' class='go'&gt;GO&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; ListServlet 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081package com.imooc.servlet;import com.imooc.bean.Message;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.sql.*;import java.util.ArrayList;import java.util.List;/** * 列表页面初始化控制 */@WebServlet(name="ListServlet" ,urlPatterns = "/List.action")public class ListServlet extends HttpServlet&#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; try &#123; //得到表单文本框提交的数据 req.setCharacterEncoding("utf-8"); String command = req.getParameter("command"); String description = req.getParameter("description"); //将查询完的值保留在查询栏中 req.setAttribute("command",command); req.setAttribute("description",description); Class.forName("com.mysql.jdbc.Driver"); Connection conn = DriverManager.getConnection("jdbc:mysql://127.0.0.1:3306/micro_message", "root","root"); StringBuilder sql = new StringBuilder("select ID,COMMAND,DESCRIPTION,CONTENT from MESSAGE where 1=1"); //创建一个 List 将需要拼接的 sql 语句查询内容装进去，最后用 for 循环取出，set 到 PreparedStatement 后执行 List&lt;String&gt; paramList = new ArrayList&lt;String&gt;(); //.trim() 方法返回一个 String 的副本，用来去除首尾的空格 if(command != null &amp;&amp; !"".equals(command.trim()))&#123; //查询sql语句拼接不用sql.append(" and command = '"+command+"'") 因为容易被SQL注入攻击 sql.append(" and COMMAND=?"); paramList.add(command); &#125; if(description != null &amp;&amp; !"".equals(description.trim()))&#123; sql.append(" and DESCRIPTION like '%' ? '%'"); paramList.add(description); &#125; PreparedStatement ps = conn.prepareStatement(sql.toString()); //在 sql 语句执行前，将参数加进去 for (int i = 0; i &lt; paramList.size(); i++) &#123; ps.setString(i + 1,paramList.get(i)); &#125; ResultSet rs = ps.executeQuery(); List&lt;Message&gt;messageList = new ArrayList&lt;Message&gt;(); while(rs.next())&#123; Message message = new Message(); //添加到容器中的不是对象本身，此时操作对象仍可以改变在容器中的内容。 //也可以将对象在最后添加到容器 message.setId(rs.getString("ID")); message.setCommand(rs.getString("COMMAND")); message.setDescription(rs.getString("DESCRIPTION")); message.setContent(rs.getString("CONTENT")); messageList.add(message); &#125; //将容器添加到 request 的 attribute 可以在页面上显示出来 req.setAttribute("messageList",messageList); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; req.getRequestDispatcher("/WEB-INF/jsp/back/list.jsp").forward(req,resp); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; this.doGet(req, resp); &#125;&#125; idea 引入 c 标签 网页有框架没有数据，提示找不到 jdbc，没有正确导入 Driver 包； You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ‘message’ at line 1 ​ at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)​ at sun.reflect.NativeConstructorAccessorImpl.newInstance(Unknown Source)​ at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(Unknown Source)​ at java.lang.reflect.Constructor.newInstance(Unknown Source) Sql 语句有语法错误：from 写成了 form 第一版代码重构 将原来 servlet 的功能分出去 servlet 的功能 设置编码 接受页面的值 向页面传值 dao 层的功能 根据查询条件查询消息列表，跟表 Message 相关的所有操作都在这层 service 层的功能 调用 MessageDao 进行数据操作，再由 ListServlet 调用。将值返回给 ListServlet ListSerlvet 123456789101112131415161718192021222324252627282930313233343536373839404142package com.imooc.servlet;import com.imooc.bean.Message;import com.imooc.service.ListService;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.sql.*;import java.util.ArrayList;import java.util.List;/** * 列表页面初始化控制 */@WebServlet(name="ListServlet" ,urlPatterns = "/List.action")public class ListServlet extends HttpServlet&#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //设置编码 req.setCharacterEncoding("utf-8"); //接受页面的值 String command = req.getParameter("command"); String description = req.getParameter("description"); //向页面传值 req.setAttribute("command",command); req.setAttribute("description",description); //查询消息列表并传给页面。调用 ListService 的函数，将查询的结果放到 req 中 ListService listService = new ListService(); req.setAttribute("messageList",listService.queryMessageList(command,description)); //向页面跳转 req.getRequestDispatcher("/WEB-INF/jsp/back/list.jsp").forward(req,resp); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; this.doGet(req, resp); &#125;&#125; MessageDao 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package com.imooc.dao;import com.imooc.bean.Message;import java.sql.*;import java.util.ArrayList;import java.util.List;//Dao 层跟表相关，此 dao 包含跟 message 表相关的操作public class MessageDao &#123; /** * 根据查询条件查询消息列表 */ public List&lt;Message&gt; queryMessageList(String command,String description)&#123; List&lt;Message&gt;messageList = new ArrayList&lt;Message&gt;(); try &#123; Class.forName("com.mysql.jdbc.Driver"); Connection conn = DriverManager.getConnection("jdbc:mysql://127.0.0.1:3306/micro_message", "root","root"); StringBuilder sql = new StringBuilder("select ID,COMMAND,DESCRIPTION,CONTENT from MESSAGE where 1=1"); //创建一个 List 将需要拼接的 sql 语句查询内容装进去，最后用 for 循环取出，set 到 PreparedStatement 后执行 List&lt;String&gt; paramList = new ArrayList&lt;String&gt;(); //.trim() 方法返回一个 String 的副本，用来去除首尾的空格 if(command != null &amp;&amp; !"".equals(command.trim()))&#123; //查询sql语句拼接不用sql.append(" and command = '"+command+"'") 因为容易被SQL注入攻击 sql.append(" and COMMAND=?"); paramList.add(command); &#125; if(description != null &amp;&amp; !"".equals(description.trim()))&#123; sql.append(" and DESCRIPTION like '%' ? '%'"); paramList.add(description); &#125; PreparedStatement ps = conn.prepareStatement(sql.toString()); //在 sql 语句执行前，将参数加进去 for (int i = 0; i &lt; paramList.size(); i++) &#123; ps.setString(i + 1,paramList.get(i)); &#125; ResultSet rs = ps.executeQuery(); while(rs.next())&#123; Message message = new Message(); //添加到容器中的不是对象本身，此时操作对象仍可以改变在容器中的内容。 //也可以将对象在最后添加到容器 message.setId(rs.getString("ID")); message.setCommand(rs.getString("COMMAND")); message.setDescription(rs.getString("DESCRIPTION")); message.setContent(rs.getString("CONTENT")); messageList.add(message); &#125; &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return messageList; &#125;&#125; ListService 1234567891011121314package com.imooc.service;import com.imooc.bean.Message;import com.imooc.dao.MessageDao;import java.util.List;public class ListService &#123; //调用 MessageDao 进行数据操作，再由 ListServlet 调用。将值返回给 ListServlet public List&lt;Message&gt; queryMessageList(String command, String description)&#123; MessageDao messageDao = new MessageDao(); return messageDao.queryMessageList(command,description); &#125;&#125;]]></content>
      <categories>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>jdbc</tag>
        <tag>myBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis]]></title>
    <url>%2F2018%2F07%2F23%2FMyBatis%2F</url>
    <content type="text"><![CDATA[用 mybatis 替代 jdbcmybatis 下载地址 jdbc 版跳转此处 dao 层、mybatis 及 SqlSession 作用dao (data access objection 数据访问对象)层需求 ： 能与数据库交互 能执行 sql 语句 mybatis ：向 dao 层提供对象 SqlSession SqlSession 作用： 向 sql 语句传入参数 执行 sql 语句 获取执行 sql 语句的结果 事务的控制 如何得到 SqlSession： 通过配置文件获取数据库连接的相关信息 通过配置信息构建 SqlSessionFactory 通过 SqlSessionFactory 打开 数据库会话（SqlSession） 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package com.imooc.bean;public class Message &#123; /** * 主键 */ private String id; /** * 指令名称 */ private String command; /** * 描述 */ private String description; /** * 内容 */ private String content; public String getId() &#123; return id; &#125; public void setId(String id) &#123; this.id = id; &#125; public String getCommand() &#123; return command; &#125; public void setCommand(String command) &#123; this.command = command; &#125; public String getDescription() &#123; return description; &#125; public void setDescription(String description) &#123; this.description = description; &#125; public String getContent() &#123; return content; &#125; public void setContent(String content) &#123; this.content = content; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!-- Copyright 2009-2016 the original author or authors. Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.--&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;!--类似于 java package 的用法，用来区分不同项目,namespace 必须添加--&gt;&lt;mapper namespace="Message"&gt; &lt;!--对应 jdbc 的 message.setId(rs.getString("ID")); 等方法--&gt; &lt;!--type 表示的是数据库字段对应 java 中哪个类的对象；id 随意取名；--&gt; &lt;!--如果在数据库中为主键，则配 id colum,否则配 result colum 标签；--&gt; &lt;!--colum 对应数据库列的属性名；property 是数据库对应 java bean对象中的属性名--&gt; &lt;!--jdbcType 对应数据库中属性的类型 Int、varchar 等--&gt; &lt;resultMap type="com.imooc.bean.Message" id="MessageResult"&gt; &lt;id column="ID" jdbcType="INTEGER" property="id"/&gt; &lt;result column="COMMAND" jdbcType="VARCHAR" property="command"/&gt; &lt;result column="DESCRIPTION" jdbcType="VARCHAR" property="description"/&gt; &lt;result column="CONTENT" jdbcType="VARCHAR" property="content"/&gt; &lt;/resultMap&gt; &lt;!--select id 必须是唯一的，但与 resultMap 中的 id 可以重名--&gt; &lt;!--parameterType 是传入 sqlSession 的参数的属性--&gt; &lt;!--resultMap 指向 resultMap 标签的 id--&gt; &lt;!--OGNL 表达式 如果是自定义类型就直接写自定义属性的属性名（command）--&gt; &lt;!--可以从 java 对象中调用属性值 而且可以直接调用 java 对象的方法--&gt; &lt;!--但是 与符号 &amp;&amp; 需要转义成 &amp;amp;&amp;amp 或者用 OGNl 的 and 操作符--&gt; &lt;!--双引号 "" 需要转义成 &amp;quot;&amp;quot;--&gt; &lt;!--占位符 ? 需要用 #&#123;command&#125; 来替换，表示用 command 值来填充 ? 这是 mybatis 的解析规则--&gt; &lt;!--mybatis 配置中 sql 语句前后不需要留空格，会自动拼接--&gt; &lt;!--模糊查询 like 跟 '%' 保留，问号 ? 替换，问号两边依旧保留空格 --&gt; &lt;select id="queryMessageList" parameterType="com.imooc.bean.Message" resultMap="MessageResult"&gt; select ID,COMMAND,DESCRIPTION,CONTENT from MESSAGE where 1=1 &lt;if test="command != null &amp;amp;&amp;amp; !&amp;quot;&amp;quot;.equals(command.trim()) "&gt; and COMMAND=#&#123;command&#125; &lt;/if&gt; &lt;if test="description != null and !&amp;quot;&amp;quot;.equals(description.trim()) "&gt; and DESCRIPTION like '%' #&#123;description&#125; '%' &lt;/if&gt; &lt;/select&gt; &lt;!--单个删除--&gt; &lt;!--#&#123;&#125; 中的取值写法可以视为与 OGNL 相同：当参数为 String 与基本数据类型时，标签属性为 _parameter, 若为自定义类型则写自定义类型属性名--&gt; &lt;delete id="deleteOne" parameterType="int"&gt; delete from MESSAGE where ID = #&#123;_parameter&#125; &lt;/delete&gt; &lt;!--批量删除--&gt; &lt;delete id="deleteBatch" parameterType="java.util.List"&gt; delete from MESSAGE where ID in ( &lt;foreach collection="list" item="item" separator=","&gt; #&#123;item&#125; &lt;/foreach&gt; ) &lt;/delete&gt;&lt;/mapper&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!-- Copyright 2009-2016 the original author or authors. Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.--&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;!-- &lt;settings&gt; &lt;setting name="useGeneratedKeys" value="false"/&gt; &lt;setting name="useColumnLabel" value="true"/&gt; &lt;/settings&gt; &lt;typeAliases&gt; &lt;typeAlias alias="UserAlias" type="org.apache.ibatis.submitted.complex_property.User"/&gt; &lt;/typeAliases&gt; --&gt; &lt;environments default="development"&gt; &lt;environment id="development"&gt; &lt;transactionManager type="JDBC"&gt; &lt;property name="" value=""/&gt; &lt;/transactionManager&gt; &lt;dataSource type="UNPOOLED"&gt; &lt;property name="driver" value="com.mysql.jdbc.Driver"/&gt; &lt;property name="url" value="jdbc:mysql://127.0.0.1:3306/micro_message"/&gt; &lt;property name="username" value="root"/&gt; &lt;property name="password" value="root"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!--用来引入 sqlxml 配置文件的内容--&gt; &lt;mappers&gt; &lt;!--mapper 可以多个--&gt; &lt;mapper resource="com/imooc/config/sqlxml/Message.xml"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110package com.imooc.dao;import com.imooc.bean.Message;import com.imooc.db.DBAccess;import org.apache.ibatis.session.SqlSession;import java.io.IOException;import java.sql.*;import java.util.ArrayList;import java.util.List;//Dao 层跟表相关，此 dao 包含跟 message 表相关的操作public class MessageDao &#123; /** * mybytis 根据查询条件查询消息列表 */ public List&lt;Message&gt; queryMessageList(String command,String description)&#123; DBAccess dbAccess = new DBAccess(); //要在 final 中关闭此会话，所以放在外面 SqlSession sqlSession = null; //创建 List 将查询语句内容放进 List 中 List&lt;Message&gt;messageList = new ArrayList&lt;Message&gt;(); //捕获 DBAccess 抛出的异常 try &#123; sqlSession = dbAccess.getSqlSession(); //新建一个对象，将 command description 对象封装到对象中 Message message = new Message(); message.setCommand(command); message.setDescription(description); //通过 sqlSession 执行 查找sql 语句；值为 namespace.resultMap messageList = sqlSession.selectList("Message.queryMessageList",message); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally&#123; if(sqlSession!=null)&#123; sqlSession.close(); &#125; &#125; return messageList; &#125; /** * * 单条删除 */ public void deleteOne(int id)&#123; DBAccess dbAccess = new DBAccess(); //要在 final 中关闭此会话，所以放在外面 SqlSession sqlSession = null; //捕获 DBAccess 抛出的异常 try &#123; sqlSession = dbAccess.getSqlSession(); //通过 sqlSession 执行 删除sql 语句；值为 Message.mapper 的 namespace.resultMap sqlSession.delete("Message.deleteOne",id); //使用 mybatis 时对 commit 进行了封装，需要手动进行提交 /** * Connection conn; * 下面两条sql语句是自动提交互不影响的 * 但是将 conn.setAutoCommit(false) 设定后，下面的 sql 语句将处于一个事物中 * 需要进行 conn.commit(); 或 conn.roolback(); 才能一次性手动提交 * conn.prepareStatement("sql").execute(); * conn.prepareStetement("sql").execute(); * conn.commit(); * * * 如下的 sqlSession.commit()；实际上就是 conn.commmit(); */ sqlSession.commit(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally&#123; if(sqlSession!=null)&#123; sqlSession.close(); &#125; &#125; &#125; /** * 批量删除 */ public void deleteBatch(List&lt;Integer&gt; ids)&#123; DBAccess dbaccess = new DBAccess(); SqlSession sqlsession = null; try &#123; sqlsession = dbaccess.getSqlSession(); //执行删除语句 sqlsession.delete("Message.deleteBatch",ids); sqlsession.commit(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; // public static void main(String[] args) &#123;// MessageDao messageDao = new MessageDao();// messageDao.queryMessageList("","");//// &#125;&#125; 123456789101112131415161718192021222324package com.imooc.db;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import java.io.IOException;import java.io.Reader;/** * 访问数据库类 */public class DBAccess &#123; public SqlSession getSqlSession() throws IOException &#123; //通过配置文件获取数据库连接信息 Reader reader = Resources.getResourceAsReader("com/imooc/config/Configuration.xml"); //通过配置信息构建一个 SqlSessionFactory SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(reader); //通过 sqlSessionFactory 打开一个数据库会话 SqlSession sqlSession = sqlSessionFactory.openSession(); return sqlSession; &#125;&#125; 1234567891011121314package com.imooc.service;import com.imooc.bean.Message;import com.imooc.dao.MessageDao;import java.util.List;public class ListService &#123; //调用 MessageDao 进行数据操作，再由 ListServlet 调用。将值返回给 ListServlet public List&lt;Message&gt; queryMessageList(String command, String description)&#123; MessageDao messageDao = new MessageDao(); return messageDao.queryMessageList(command,description); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.imooc.service;import com.imooc.dao.MessageDao;import java.util.ArrayList;import java.util.List;/** * 维护 Service * 维护相关业务的功能 * 页面的一个动作对应了一个 Servlet ；而 Service 不应该同时增加 * 把相似的功能（修改，新增，删除，批量删除等）放在一个维护 Service 中 * 以后可以一直添加新功能 * * 将取值的转型及判断是否为空 都放在 Service 中进行 */public class MaintainService &#123; /** * 单条删除 */ public void deleteOne(String id)&#123; //判断 id 是否为空，或 空字符串 if(id != null &amp;&amp; !"".equals(id.trim())) &#123; MessageDao messageDao = new MessageDao(); //将 id 从 String 转型为 int 并作为参数传入 deleteOne 函数 messageDao.deleteOne(Integer.valueOf(id)); &#125; &#125; /** * 批量删除 */ public void deleteBatch(String [] ids)&#123; MessageDao messageDao = new MessageDao(); //创建 id 的 List List&lt;Integer&gt; idList = new ArrayList&lt;Integer&gt;(); for (String id : ids) &#123; //转型为 Integer 再传入 List if(id!=null &amp;&amp; !"".equals(id.trim())) &#123; idList.add(Integer.valueOf(id)); &#125; &#125; //调用 messageDao 的 deleteBatch 方法 messageDao.deleteBatch(idList); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142package com.imooc.servlet;import com.imooc.bean.Message;import com.imooc.service.ListService;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.sql.*;import java.util.ArrayList;import java.util.List;/** * 列表页面初始化控制 */@WebServlet(name="ListServlet" ,urlPatterns = "/List.action")public class ListServlet extends HttpServlet&#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //设置编码 req.setCharacterEncoding("utf-8"); //接受页面的值 String command = req.getParameter("command"); String description = req.getParameter("description"); //向页面传值 req.setAttribute("command",command); req.setAttribute("description",description); //查询消息列表并传给页面。调用 ListService 的函数，将查询的结果放到 req 中 ListService listService = new ListService(); req.setAttribute("messageList",listService.queryMessageList(command,description)); //向页面跳转 req.getRequestDispatcher("/WEB-INF/jsp/back/list.jsp").forward(req,resp); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; this.doGet(req, resp); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435package com.imooc.servlet;import com.imooc.service.ListService;import com.imooc.service.MaintainService;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;/** * 单条删除控制层 */public class DeleteOneServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //设置编码 req.setCharacterEncoding("utf-8"); //接受页面的值 String id = req.getParameter("id"); MaintainService maintainService = new MaintainService(); //需要接受的参数为 int 但是判断接受的值是否为空以及转型应该在 Service 中进行 maintainService.deleteOne(id); //向页面跳转 直接跳转到 list.jsp 会使得列表全部消失；列表初始化需要 listServlet 进行一些操作 //所以应该先跳到 listServlet// req.getRequestDispatcher("/WEB-INF/jsp/back/list.jsp").forward(req,resp); req.getRequestDispatcher("/List.action").forward(req,resp); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; this.doGet(req, resp); &#125;&#125; 1234567891011121314151617181920212223242526272829package com.imooc.servlet;import com.imooc.service.MaintainService;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;/** * 批量删除控制层 */public class DeleteBatchServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; req.setCharacterEncoding("utf-8"); MaintainService maintainService = new MaintainService(); String[] ids = req.getParameterValues("id"); maintainService.deleteBatch(ids); //页面跳转 req.getRequestDispatcher("/List.action").forward(req,resp); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; this.doGet(req,resp); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;&lt;%--使用 jstl--%&gt;&lt;%@taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %&gt;&lt;%--拼接当前网页相对路径--%&gt;&lt;% String path = request.getContextPath(); String basePath = request.getScheme()+"://"+request.getServerName()+":"+request.getServerPort()+path;%&gt;&lt;html xmlns="http://www.w3.org/1999/xhtml"&gt; &lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /&gt; &lt;meta http-equiv="X-UA-Compatible"content="IE=9; IE=8; IE=7; IE=EDGE" /&gt; &lt;title&gt;内容列表页面&lt;/title&gt; &lt;link href="&lt;%=basePath%&gt;/resources/css/all.css" rel="stylesheet" type="text/css" /&gt; &lt;script src="&lt;%=basePath %&gt;/resources/js/common/jquery-1.8.0.min.js"&gt;&lt;/script&gt; &lt;script src="&lt;%=basePath %&gt;/resources/js/back/list.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; function deleteOne(path,id)&#123; if(confirm("确定要删除吗？"))&#123; document.getElementById("id").value=id; document.getElementById("mainForm").action = path+"/DeleteOneServlet.action"; document.getElementById("mainForm").submit(); &#125; &#125; &lt;/script&gt; &lt;/head&gt; &lt;body style="background: #e1e9eb;"&gt; &lt;%--提交到 ListServlet 上进行初始化与查询--%&gt; &lt;form action="&lt;%=basePath%&gt;/List.action" id="mainForm" method="post" &gt; &lt;div class="right"&gt; &lt;div class="current"&gt;当前位置：&lt;a href="javascript:void(0)" style="color:#6E6E6E;"&gt;内容管理&lt;/a&gt; &amp;gt; 内容列表&lt;/div&gt; &lt;div class="rightCont"&gt; &lt;p class="g_title fix"&gt; 内容列表 &lt;a class="btn03" href="#"&gt; 新 增 &lt;/a&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;a class="btn03" href="javascript:deleteBatch('&lt;%=basePath%&gt;');"&gt; 删 除 &lt;/a&gt; &lt;/p&gt; &lt;table class="tab1"&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td width="90" align="right"&gt;指令名称：&lt;/td&gt; &lt;td&gt; &lt;input name="command" type="text" class="allInput" value="$&#123;command&#125;"/&gt; &lt;/td&gt; &lt;td width="90" align="right"&gt;描述：&lt;/td&gt; &lt;td&gt; &lt;input name="description" type="text" class="allInput" value="$&#123;description&#125;"/&gt; &lt;/td&gt; &lt;td width="85" align="right"&gt;&lt;input type="submit" class="tabSub" value="查 询" /&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;div class="zixun fix"&gt; &lt;table class="tab2" width="100%"&gt; &lt;tbody&gt; &lt;tr&gt; &lt;th&gt;&lt;input type="checkbox" id="all" onclick="#"/&gt;&lt;/th&gt; &lt;th&gt;序号&lt;/th&gt; &lt;th&gt;演示字段1&lt;/th&gt; &lt;th&gt;演示字段2&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;input type="hidden" id="id" name="id" /&gt; &lt;c:forEach items="$&#123;messageList&#125;" var="message" varStatus="status"&gt; &lt;tr &lt;c:if test="$&#123;status.index % 2 != 0&#125;"&gt;style='background-color:#ECF6EE;'&lt;/c:if&gt;&gt; &lt;%--value 值与下面的 id 表达式相同--%&gt; &lt;td&gt;&lt;input type="checkbox" name="id" value="$&#123;message.id&#125;"/&gt;&lt;/td&gt; &lt;td&gt;$&#123;status.index + 1&#125;&lt;/td&gt; &lt;td&gt;$&#123;message.command&#125;&lt;/td&gt; &lt;td&gt;$&#123;message.description&#125;&lt;/td&gt; &lt;td&gt; &lt;a href="#"&gt;修改&lt;/a&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;%--使用 get 方法提交，不适合隐私信息及中文信息提交--%&gt; &lt;%--&lt;a href="$&#123;basePath&#125;/DeleteOneServlet.action?id=$&#123;message.id&#125;"&gt;删除&lt;/a&gt;--%&gt; &lt;%--&lt;a href="$&#123;basePath&#125;/DeleteOneServlet.action?id=$&#123;message.id&#125;"--%&gt; &lt;%--onclick="return confirm('确定要删除这条信息吗？');"&gt;删除&lt;/a&gt;--%&gt; &lt;a href="#" onclick="deleteOne('$&#123;pageContext.request.contextPath&#125;',$&#123;message.id&#125;)"&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;div class='page fix'&gt; 共 &lt;b&gt;4&lt;/b&gt; 条 &lt;a href='###' class='first'&gt;首页&lt;/a&gt; &lt;a href='###' class='pre'&gt;上一页&lt;/a&gt; 当前第&lt;span&gt;1/1&lt;/span&gt;页 &lt;a href='###' class='next'&gt;下一页&lt;/a&gt; &lt;a href='###' class='last'&gt;末页&lt;/a&gt; 跳至&amp;nbsp;&lt;input type='text' value='1' class='allInput w28' /&gt;&amp;nbsp;页&amp;nbsp; &lt;a href='###' class='go'&gt;GO&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 123456789程序未报错，但 tomcat 连接后直接停止：Connected to the target VM, address: &apos;127.0.0.1:10605&apos;, transport: &apos;socket&apos;Disconnected from the target VM, address: &apos;127.0.0.1:10605&apos;, transport: &apos;socket&apos;解决方法：把 main 测试函数注释掉，通过 tomcat 发布文件 12345678910&lt;script type="text/javascript"&gt; function deleteOne(path,id)&#123; if(confirm("确定要删除吗？"))&#123; document.getElementById("id").value=id; //将路径首字母小写会使函数失效，这里对应的是web.xml 配置的 url //"/deleteOneServlet.action" document.getElementById("mainForm").action = path+"/DeleteOneServlet.action"; document.getElementById("mainForm").submit(); &#125; &#125; &lt;/script&gt; 123456789idea 未报错，点击删除，批量删除无效，网页前台控制台报错：Uncaught ReferenceError: deleteBatch is not defined at &lt;anonymous&gt;:1:1 解决：DeleteBatchServlet 后忘记加 .action 应将其提交到 web.xml 配置的 url 上$(&quot;#mainForm&quot;).attr(&quot;action&quot;,basePath+&quot;/DeleteBatchServlet.action&quot;);//此处 name = &quot;id&quot; 而不是 id = &quot;id&quot;,而且不加 value 时，checkbox 选中时返回的值是 on&lt;td&gt;&lt;input type=&quot;checkbox&quot; name=&quot;id&quot; value=&quot;$&#123;message.id&#125;&quot;/&gt;&lt;/td&gt; 12345678910111213141516171819202122232425262728网页报错：Type Exception ReportMessage For input string: &quot;&quot;Description The server encountered an unexpected condition that prevented it from fulfilling the request.Exceptionjava.lang.NumberFormatException: For input string: &quot;&quot; java.lang.NumberFormatException.forInputString(Unknown Source) java.lang.Integer.parseInt(Unknown Source) java.lang.Integer.valueOf(Unknown Source) com.imooc.service.MaintainService.deleteBatch(MaintainService.java:41) com.imooc.servlet.DeleteBatchServlet.doGet(DeleteBatchServlet.java:17) com.imooc.servlet.DeleteBatchServlet.doPost(DeleteBatchServlet.java:25) javax.servlet.http.HttpServlet.service(HttpServlet.java:661) javax.servlet.http.HttpServlet.service(HttpServlet.java:742) org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52)Note The full stack trace of the root cause is available in the server logs.问题：ids 在接受值时 String[] ids = req.getParameterValues(&quot;id&quot;);会多出一个 index[0] = &quot;&quot;;解决： 在 service 中判断是否为空 if(id!=null &amp;&amp; !&quot;&quot;.equals(id.trim())) &#123; idList.add(Integer.valueOf(id)); &#125; 123456789101112131415点击删除后，页面跳转到 http://localhost:8080/DeleteBatchServlet.action但是没有删除所选中的几条值日志：2018-07-27 12:54:52,186 [http-nio-8080-exec-3] DEBUG [Message.deleteBatch] - ==&gt; Preparing: delete from MESSAGE where ID in( ? , ? ) 2018-07-27 12:54:52,187 [http-nio-8080-exec-3] DEBUG [Message.deleteBatch] - ==&gt; Parameters: 5(Integer), 6(Integer)2018-07-27 12:54:52,188 [http-nio-8080-exec-3] DEBUG [Message.deleteBatch] - &lt;== Updates: 22018-07-27 12:54:52,226 [http-nio-8080-exec-3] DEBUG [Message.queryMessageList] - ==&gt; Preparing: select ID,COMMAND,DESCRIPTION,CONTENT from MESSAGE where 1=1 2018-07-27 12:54:52,227 [http-nio-8080-exec-3] DEBUG [Message.queryMessageList] - ==&gt; Parameters: 2018-07-27 12:54:52,229 [http-nio-8080-exec-3] DEBUG [Message.queryMessageList] - &lt;== Total: 3解决：messageDao 中传入的参数类型错误，应该为 List&lt;Integer&gt;idspublic void deleteBatch(List&lt;Integer&gt; ids) idea 导入本地 jar 包源码的方法idea 导入本地 jar 包源码 log4j 中的代码意义log4j.appender.Console.layout.ConversionPattern=%d [%t] %-5p [%c] - %m%n %d 日志生成的时间 %t 是产生日志所处的线程名称 %p 输出日志的级别，%-5p 将占5位字符，不足5位用空格填补，- 指的是在右边补空 %c 你输出日志的包以及类的全名 %m 是你附加的信息 %n 换行 代码实现demo 源码]]></content>
      <categories>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AnnTest java 注解]]></title>
    <url>%2F2018%2F07%2F18%2FAnnTest%2F</url>
    <content type="text"><![CDATA[运行机制划分注解 源码注解：只在源码中存在，编译成 .class 文件就不存在了。 编译时注解：注解在源码和 .class 文件中都存在 @Override @Deprecated @Suppvisewarning @Override ：表示覆写了某一个方法 @Deprecated ：表示一个方法已经过期，可用 @Suppvisewarning 忽略警告 运行时注解：在运行阶段还起作用，甚至会影响运行逻辑的注解。 @Autowired 1234567891011package com.ann.test;public class Test &#123; //忽略方法中的方法过期警告，也可以放在类外，忽略整个类的过期警告 @SuppressWarnings("deprecation") public void sing()&#123; Person p = new Child(); p.sing(); &#125;&#125; 123456789package com.ann.test;public interface Person &#123; public String name(); public int age(); //提示方法已过期 @Deprecated public void sing();&#125; 解析注解1234元注解RetentionPolicy，表明注解的生命周期：1、SOURCE：在原文件中有效，被编译器丢弃。 2、CLASS：在class文件有效，可能会被虚拟机忽略。 3、RUNTIME：在运行时有效。 @Inherited 元注解是一个标记注解，@Inherited阐述了某个被标注的类型是被继承的。 如果一个使用了@Inherited修饰的annotation类型被用于一个class，则这个annotation将被用于该class的子类。 注意：@Inherited annotation类型是被标注过的class的子类所继承。类并不从它所实现的接口继承annotation， 方法并不从它所重载的方法继承annotation。 @Inherited 对接口没作用，只会继承类 123456789101112package com.ann.test;import java.lang.annotation.*;import java.util.Map;//自定义注解，在 Child 中使用@Target(&#123;ElementType.METHOD,ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Inherited@Documentedpublic @interface Description &#123; String value();&#125; 12345678910111213141516171819package com.ann.test;@Description("i am class annotation")public class Child implements Person &#123; @Override @Description("i am method annotation") public String name() &#123; return null; &#125; @Override public int age() &#123; return 0; &#125; @Override public void sing() &#123; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.ann.test;import java.lang.annotation.Annotation;import java.lang.reflect.Method;//只能取到运行时加载public class PraseAnn &#123; public static void main(String[] args) &#123; try &#123; //使用类加载器加载类 Class c = Class.forName("com.ann.test.Child"); //找到类上的注解 boolean isExist = c.isAnnotationPresent(Description.class); if(isExist)&#123; //拿到注解实例 Description d = (Description) c.getAnnotation(Description.class); System.out.println(d.value()); &#125; //找到方法上的注解 Method[] ms = c.getMethods(); for (Method m : ms) &#123; boolean isMExist = m.isAnnotationPresent(Description.class); if(isMExist)&#123; Description d = m.getAnnotation(Description.class); System.out.println(d.value()); &#125; &#125; //另一种解析方法 for (Method m : ms) &#123; Annotation[]as = m.getAnnotations(); for (Annotation a : as) &#123; if(a instanceof Description)&#123; Description d = (Description) a; System.out.println(d.value()); &#125; &#125; &#125; &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 运行 PraseAnn 输出结果 i am class annotationi am method annotationi am method annotation java 注解 Element 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192package com.imooc.test;@Table("user")public class Filter &#123; /** Column column = field.getAnnotation(Column.class);得到的是字段上注解内容，然后通过 String columnName = column.value();得到就是此注解下的字段名， @Column("id") （好比上面的 column，不过只是比如column是一个注解对象） private int id; （columnName 就得到的是 id ） @Table("数据库中的表名") @Column("数据库中的列名/字段名:id/user_name...") */ @Column("id") private int id; @Column("user_name") private String userName; @Column("nick_name") private String nickName; @Column("age") private int age; @Column("city") private String city; @Column("email") private String email; @Column("mobile") private String mobile; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getUserName() &#123; return userName; &#125; public void setUserName(String userName) &#123; this.userName = userName; &#125; public String getNickName() &#123; return nickName; &#125; public void setNickName(String nickName) &#123; this.nickName = nickName; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getCity() &#123; return city; &#125; public void setCity(String city) &#123; this.city = city; &#125; public String getEmail() &#123; return email; &#125; public void setEmail(String email) &#123; this.email = email; &#125; public String getMobile() &#123; return mobile; &#125; public void setMobile(String mobile) &#123; this.mobile = mobile; &#125;&#125; 123456789101112131415package com.imooc.test;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;//作用域：类或接口@Target(&#123;ElementType.TYPE&#125;)//生命周期：运行时@Retention(RetentionPolicy.RUNTIME)public @interface Table &#123; //使用值只有一个：表名 user String value();&#125; 1234567891011121314package com.imooc.test;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;//作用域：字段、枚举的常量@Target(&#123;ElementType.FIELD&#125;)//生命周期：运行时有效@Retention(RetentionPolicy.RUNTIME)public @interface Column &#123; String value();&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485package com.imooc.test;import java.io.ObjectInputStream;import java.lang.reflect.Field;import java.lang.reflect.Method;public class Test &#123; public static void main(String[] args) &#123; Filter f1 = new Filter(); f1.setId(10);//查询 id 为 10 的用户 Filter f2 = new Filter(); f2.setUserName("lucy");//查询用户名为 lucy 的用户 Filter f3 = new Filter(); f3.setEmail("liu@sina.com,zh@163.com,77777@qq.com");//查询邮箱为其中任意一个用户 String sql1 = query(f1); String sql2 = query(f2); String sql3 = query(f3); System.out.println(sql1); System.out.println(sql2); System.out.println(sql3); &#125; private static String query(Filter f)&#123; StringBuilder sb = new StringBuilder(); //获取 class Class c = f.getClass(); //获取 table 的名字 boolean exists = c.isAnnotationPresent(Table.class); if(!exists)&#123; return null; &#125; Table t = (Table) c.getAnnotation(Table.class); String tableName = t.value(); /** * 例如为不定数量的查询条件，我们在后台写查询的时候， 类似于这样的语句 string sql ="select * from table where" 为了使语句通顺不报错，加上 where 1=1 */ sb.append("select * form").append(tableName).append("where 1=1"); //遍历所有的字段 Field[] fArray = c.getDeclaredFields(); for (Field field : fArray) &#123; //处理每个字段对应的 sql //拿到字段名 boolean fExists = field.isAnnotationPresent(Column.class); if(!fExists)&#123; continue; &#125; Column column = field.getAnnotation(Column.class); String columnName = column.value(); //拿到字段值 String filedName = field.getName(); String getMethodName = "get" + filedName.substring(0,1).toUpperCase()+filedName.substring(1); //通过反射取得 method System.out.println(getMethodName); Object fieldValue = null; try &#123; Method getMethod = c.getMethod(getMethodName); fieldValue = getMethod.invoke(f); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; //拼装 sql if(fieldValue==null ||(fieldValue instanceof Integer &amp;&amp; (Integer)fieldValue==0))&#123; continue; &#125; sb.append(" and ").append(filedName); if(fieldValue instanceof String)&#123; sb.append("=").append("'").append(columnName).append("'"); &#125;else if(fieldValue instanceof Integer) &#123; sb.append("=").append(columnName); &#125; &#125; return sb.toString(); &#125;&#125;]]></content>
      <categories>
        <category>Annotation</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>注解</tag>
        <tag>imooc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Reflection 反射]]></title>
    <url>%2F2018%2F07%2F17%2Factive-class%2F</url>
    <content type="text"><![CDATA[反射指的是可以于运行时加载,探知和使用编译期间完全未知的类. 程序在运行状态中, 可以动态加载一个只有名称的类, 对于任意一个已经加载的类,都能够知道这个类的所有属性和方法; 对于任意一个对象,都能调用他的任意一个方法和属性; 加载完类之后, 在堆内存中会产生一个Class类型的对象(一个类只有一个Class对象), 这个对象包含了完整的类的结构信息,而且这个Class对象就像一面镜子,透过这个镜子看到类的结构,所以被称之为:反射。 不是所有的实例化都是 new ，new 时必须知道这个类是什么，而很多时候做不到预先知道类名，很多框架如 Spring 应用了反射的原理。 new 创建的对象是 静态加载类，在编译时就需要加载所有可能用到的类，若在编译时找不到类直接报错。一个功能有问题，其他功能都无法使用。 class 为类类型/字节码（编译后的类） OfficeBetter.java 1234567891011121314151617181920212223class OfficeBetter&#123; public static void main(String args [])&#123; try&#123; //动态加载类，在运行时加载 Class c = Class.forName(args[0]); OfficeAble oa = (OfficeAble)c.newInstance(); oa.start(); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; &#125;&#125; OfficeAble.java 1234567interface OfficeAble&#123; //创建接口，由使用者来实现该接口,重写 start 方法 public void start();&#125; Word.java 123456789class Word implements OfficeAble&#123; public void start()&#123; System.out.println("word--starts"); &#125;&#125; 编译 javac *.java 运行 java OfficeBetter Word (main 类 + 实现接口类) 输出结果 word–starts 获取类的信息首先要获取类的类类型 Class c1 = int.class; //int 的类类型 String c2 = String.class //String 的类类型 void c3 = void.class System.out.println(c1.getName()); //打印包含包名的类的名称 System.out.println(c2.getSimpleName()); //打印不包含包名的类的名称 System.out.println(c3.getName()); //打印结果：void 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package com.imooc.reflect;public class ClassUtil &#123; public static void PrintClassMessage(Object obj) &#123; //传递的是哪个子类的对象，c 就是该子类的类类型 Class c = obj.getClass(); //getMethods() 获取所有 public 的函数，包括父类继承而来的 //getDeclaredMethods() 获取的是该类自己声明的方法，不问访问权限； Method [] ms = c.getMethods(); for(int i = 0; i &lt; ms.length; i++)&#123; //得到方法返回值类型的类类型 Class returnType = ms[i].getReturnType(); System.out.print(returnType.getName()+""); //得到方法的名称 System.out.print(ms[i].getName()+"("); //获取参数类型，得到的是参数列表的类型的类类型 Class [] paramTypes = ms[i].getParameterTypes(); for(Class class1:paramTypes)&#123; System.out.print(class1.getName()+","); &#125; System.out.println(")"); &#125; public static void printFieldMessage(Object obj) &#123; Class c = obj.getClass(); //成员变量也是对象； Field[] fs = c.getDeclaredFields(); for (Field field : fs) &#123; Class fieldType = field.getType(); String typeName = fieldType.getName(); //得到成员变量名称 String fieldName = field.getName(); System.out.println(typeName + " " + fieldName); &#125; &#125; //打印对象的构造函数信息 public static void printConMessage(Object obj)&#123; Class c = obj.getClass(); /*构造函数也是对象 java.lang.Constructor 封装了构造函数的信息 getConstructors 获取所有的 public 的构造函数 Constructor []cs = c.getConstructors(); */ Constructor [] cs = c.getDeclaredConstructors(); for (Constructor constructor : cs) &#123; System.out.print(constructor.getName()+"("); //获取构造函数的参数列表--&gt;得到的是参数列表的类类型 Class[] parameterTypes = constructor.getParameterTypes(); for (Class class1 : parameterTypes) &#123; System.out.print(class1.getName()+","); &#125; System.out.println(")"); &#125; &#125;&#125; 1234567891011package com.imooc.reflect;//PrintClassMessage 方法测试类public class ClassDemo3 &#123; public static void main(String[] args) &#123; String s = &quot;hello&quot;; ClassUtil.PrintClassMessage(s); Integer n1 = 1; ClassUtil.PrintClassMessage(n1); &#125;&#125; 123456789package com.imooc.reflect;//printieldMessage() 方法测试类public class ClassDemo4 &#123; public static void main(String[] args) &#123; ClassUtil.printFieldMessage(&quot;hello&quot;); System.out.println(&quot;==========&quot;); ClassUtil.printFieldMessage(new Integer(1)); &#125;&#125; 12345678package com.imooc.reflect;//printConMessage() 方法测试类public class ClassDemo5 &#123; public static void main(String[] args) &#123; ClassUtil.printConMessage(&quot;hello&quot;); ClassUtil.printConMessage(new Integer(1)); &#125;&#125; 方法的反射操作method.invoke(对象，参数列表) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package com.imooc.reflect;import java.lang.reflect.Method;public class MethodDemo1 &#123; public static void main(String[] args) &#123; //获取print(int a,int b)方法，获取一个方法就是获取类的信息，获取类的信息就要获得类的类类型 A a1 = new A(); Class c = a1.getClass(); /** * 获取方法 名称和参数决定 * getMethod 获取的是 public 的方法 * getDelcaredMethod 自己声明的方法 */ try &#123; Method m = c.getMethod("print", int.class, int.class);// 或 Method m = c.getMethod("pirnt", new Class[]&#123;int.class, int.class&#125;); /** * 方法的反射操作 * a1.print(10,20); 方法的反射操作是用 m 对象来进行方法的调用 和 a1.print 调用效果完全相同 * 方法没有返回值，则返回 null ，有返回值则返回具体的返回值 */ Object o = m.invoke(a1, new Object[]&#123;10, 20&#125;); System.out.println("==========="); //获取方法对象 Method m1 = c.getMethod("print", String.class, String.class); //用方法进行反射操作 o = m1.invoke(a1, "Hello", "Word"); System.out.println("==========="); Method m2 = c.getMethod("print"); //或 Method m1 = c.getMethod("print", new Class[]&#123;&#125;); m2.invoke(a1); // 或m2.invoke(a1,new Object[]&#123;&#125;); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125;class A&#123; public void print(int a,int b)&#123; System.out.println(a+b); &#125; public void print(String a,String b)&#123; System.out.println(a.toUpperCase() + "," + b.toLowerCase()); &#125; public void print()&#123; System.out.println("hello Word"); &#125;&#125; 通过反射了解泛型本质class 为类类型/字节码（编译后的类） class/method 等反射操作都是绕过编译的操作 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.imooc.reflect;import java.lang.reflect.Method;import java.util.ArrayList;public class MethodDemo4 &#123; public static void main(String[] args) &#123; ArrayList list = new ArrayList(); //泛型，只能放 String 类型； //防止加入 list1.add(10); 这种操作 ArrayList&lt;String&gt;list1 = new ArrayList&lt;&gt;(); list1.add("hello"); Class c1 = list.getClass(); Class c2 = list1.getClass(); System.out.println(c1 == c2); /** * 反射的操作都是编译之后的操作（跳过编译阶段） * c1 == c2 返回 true 说明编译之后的集合泛型是去泛型化的 * java 中集合的泛型是防止错误输入，只在编译阶段有效，绕过编译就无效 * 验证：通过方法反射操作，绕过编译 */ Method m = null; try &#123; m = c2.getMethod("add", Object.class); m.invoke(list1,10);//绕过编译操作就绕过了泛型 System.out.println(list1.size()); /** * for (String string : list1) &#123; System.out.println(string); &#125; 此时遍历会发生错误异常，提示不能将 int 转换成 String * java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String */ &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>imooc</tag>
        <tag>reflection</tag>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo next 搭建博客]]></title>
    <url>%2F2018%2F07%2F11%2Fblog-create%2F</url>
    <content type="text"><![CDATA[hexo 安装插入图片： node_modules：是依赖包public：存放的是生成的页面scaffolds：命令生成文章等的模板source：用命令创建的各种文章themes：主题_config.yml：整个博客的配置db.json：source解析所得到的package.json：项目所需模块项目的配置信息 接下来依次在命令行输入hexo ghexo s 在浏览器中打开http://localhost:4000/，看到网页则配置结束 将Hexo与github page 联系起来 设置Git的user name和email：(如果是第一次的话) git config --global user.name &quot;crow-song&quot;git config --global user.email &quot;crowsong.end@gmail.com&quot; 设置 ssh 密钥参考：https://blog.csdn.net/love_fdu_llp/article/details/38752365 https://jingyan.baidu.com/article/a65957f4e91ccf24e77f9b11.html 检查本机是否有ssh key设置 $ cd ~/.ssh 或cd .ssh 如果没有则提示： No such file or directory 如果有则进入~/.ssh路径下（ls查看当前路径文件，rm * 删除所有文件) ssh-keygen -t rsa -C &quot;crowsong.end@gmail.com&quot; 生成密钥对 之后全部 enter 就行 秘钥存放路径为：c:/Users/xxxx_000/.ssh/下 查看你生成的公钥：$ cat ~/.ssh/id_rsa.pub 复制公钥到 github 账户的 AccountSettings → SSHKeys → 点击 new SSH Key title 随意填写，公钥复制进文本域内 点击确定 确认设置 验证下这个key是不是正常工作。 $ ssh -T git@github.com # Attempts to ssh to github 键入 yes 看到： Hi username! You’ve successfully authenticated, but GitHub does not # provide shell access. 就表示设置成功。 接下来使用 hexo d 不再需要输入用户和密码了 配置Deployment同样在_config.yml文件中，找到Deployment，然后按照如下修改：repo 中是仓库地址（自己的 git 发布网址） deploy: type:git repo:https://crow-song.github.io/ branch:master 写博客新建一篇博客，执行下面的命令： hexo new post “article title” 这时候在我的 电脑的目录下 ..\hexo\source\ _posts 将会看到 article title.md 文件 用MarDown编辑器打开就可以编辑文章了。文章编辑好之后，运行生成、部署命令： hexo g hexo d 参考：https://blog.csdn.net/gdutxiaoxu/article/details/53576018 hexo的next主题个性化教程 Typora md文档多标签样式： tags: 博客创建 hexo 修改 css 样式，找到目标对应 css 文件，修改 background:#transparent （面板透明色） rgba(255,255,255,.9) 添加网易云音乐插件 在 mian.xxxx.css 中设置位置 .header-music {margin-top: 55px;margin-left: 0px; } nofollw 作用 添加图片 可用样式为 图片放在对应 md 文件的文件夹中 添加链接： ctrl+k 添加背景图： 将括号里面的这里填写背景图片地址替换为你所要显示的背景图片地址，#ffffff表示背景颜色为#ffffff(白色)修改为你想要的背景颜色代码，repeat表示图片平铺，不平铺改为no-repeat，scroll表示图片随对象滚动，图片固定不滚动改为fixed。 头像旋转放大： hover 选择器使用 选择鼠标移到链接上的样式 xxx:hover(xxx 可以是 img 也可以是类选择器等。如果直接使用 img:hover 会将插入图片一起放大) .site-author-image:hover 设置网站图标 Favicon 设置网站图标时使用 ico 图片会无法正常显示，使用 32*32 png 图片即可 Typora markdown 语法 设置标签随机大小与颜色 设置过程中出现 jQuery 报错：Uncaught ReferenceError: $ is not defined 可以添加 jQuery 引用 网站 debug 通过但部署后报错：(index):1 Mixed Content: The page at ‘https://crow-song.github.io/tags/&#39; was loaded over HTTPS, but requested an insecure script ‘http://libs.baidu.com/jquery/1.9.0/jquery.js&#39;. This request has been blocked; the content must be served over HTTPS. 将其 http 改为 https github fork 别人的博客后 404 错误https://github.com/qiubaiying/qiubaiying.github.io/issues/98在code下找到CNAME文件，将里面的内容改为：https://你的Github账号名.github.io，然后点底部的commit changes，应该就可以了 hexo d 或 hexo deploy 无反应解决: 配置文档中 _config.yml 冒号后需要加空格deploy:type: gitrepo: https://github.com/crow-song/crow-song.github.io.gitbranch: master hexo g 错误ERROR Process failed: _posts/article-title.mdYAMLException: can not read a block mapping entry; a multiline key may not be an implicit key at line 4, column 1:md 文档中开头 3 个标题冒号后也需要加空格title: article titledate: 2018-07-11 23:09:21tags: 博客创建]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>博客创建</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
